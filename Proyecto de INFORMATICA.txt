TITULO DEL EJERCICIO: LA CALIFICACION ANUAL DE UN ESTUDIANTE
Descripcion del problema: elaborar un algoritmo que me permita ingresar la calificación anual de un estudiante y verificar si el estudiante aprobo el año electivo tiene que tener un promedio igual o mayor a 7, si el estudiante se encuentra con un rango de calificacion hasta 4 el estudiante se encuentra en supletorio,si el promedio es inferior a 4 el estudiante automaticamente estara reprobado.
ENTRADA Y SALIDA:
ENTRADA: promedio anual PA
SALIDA: mensaje (A,R,S)
 DISEÑO DE LA SOLUCION
? ALGORITMO PROPUESTO: 
1.- pedir al usuario que ingrese la calificacion del estudiante.
2.- se pide al usuario ingresar una calificacion, asegurandose que este en el rango de 0 a 10 mediante un bucle.
3.- evaluar la calificacion:
? si es mayor o igual a 7,mostrar que el estudiante aprobo
? si es mayor o igual a 4 pero menor a 7,mostrar que el estudiante esta en supletorio
? si es menor que 4, mostrar que el estudiante reprobo
? mostar el mensaje adecuado segun la calificacion.
ESTRUCTURA DE DATOS: solo se utilizara la variable double para almacenar la calificacion.
FUNCION PRINCIPAL: solo se usara la funcion main.

EJERCICIO #1
CODIGO FUENTE

#include <iostream>
using namespace std;

int main() {
    float calificacion;

    // Solicitar al usuario que ingrese la calificación anual
    cout << "Ingrese la calificacion anual del estudiante (0 - 10): ";
    cin >> calificacion;

    // Verificar que la calificación esté dentro del rango válido
    if (calificacion < 0 || calificacion > 10) {
        cout << "Calificacion invalida. Debe estar entre 0 y 10." << endl;
        return 1; // Fin del programa con error
    }

    // Evaluar el resultado según el rango
    if (calificacion >= 7.0) {
        cout << "El estudiante ha APROBADO el año lectivo." << endl;
    } else if (calificacion >= 4.0) {
        cout << "El estudiante se encuentra en SUPLETORIO." << endl;
    } else {
        cout << "El estudiante ha REPROBADO el año lectivo." << endl;
    }

    return 0;
}




PRUEBAS: 
CASO1.- CALIFICACION 4
EL ESTUDIANTE ESTA EN SUPLETORIO
CASO2.- CALIFICACION 6.99
EL ESTUDIANTE ESTA EN SUPLETORIO
CASO3.- CALIFICACION 7
EL ESTUDIANTE APROBO LA ASIGNATURA


EJERCICIO #2
EJERCICIO #3 - Técnica básica de Ordenamiento
#include <iostream>
using namespace std;

int main() {
   int a = 100;
   int b = 25;
   int temp; // Variable auxiliar necesaria para el intercambio

   cout << "--- Intercambio de Variables ---" << endl;
   cout << "Valores iniciales: A = " << a << ", B = " << b << endl;

   // PASO 1: Guardar el valor de A
   temp = a;

   // PASO 2: Poner el valor de B en A
   a = b;

   // PASO 3: Poner el valor guardado (original de A) en B
   b = temp;

   cout << "Valores despues del intercambio: A = " << a << ", B = " << b << endl;
   return 0;
}
EJERCICIO #4 - Lógica de Ciclos
#include <iostream>
using namespace std;

int main() {
   int limite = 10;

   cout << "Contando del 1 al " << limite << ":" << endl;

   // Usamos el ciclo 'for' para repetir una accion
   for (int i = 1; i <= limite; i++) {
       cout << "Numero: " << i << endl;
   }
  
   return 0;
}

EJERCICIO #5
EJERCICIO #6 - Lógica de Ruta/Gráfico
#include <iostream>
using namespace std;

int main() {
   int posicion = 0; // Posicion inicial (similar a un punto de partida en un mapa)

   cout << "Inicio en la posicion: " << posicion << endl;

   // Secuencia de movimientos simples (pasos):
  
   // Movimiento 1: Avanza 8 pasos
   posicion = posicion + 8;
   cout << "Paso 1 (+8): " << posicion << endl;

   // Movimiento 2: Retrocede 3 pasos
   posicion = posicion - 3;
   cout << "Paso 2 (-3): " << posicion << endl;

   // Movimiento 3: Avanza 5 pasos
   posicion = posicion + 5;
   cout << "Paso 3 (+5): " << posicion << endl;

   cout << "Posicion final alcanzada: " << posicion << endl;
   return 0;
}

EJERCICIO #7Contador de Vocales (Precursor de std::map para Frecuencia)
C++
#include <iostream>
#include <string>
using namespace std;

int main() {
   string palabra = "algoritmo";
   int contador_o = 0;
   int longitud = palabra.length();

   cout << "Palabra a analizar: " << palabra << endl;

   // Recorrer la palabra caracter por caracter
   for (int i = 0; i < longitud; i++) {
       // Usar 'if' para verificar el caracter en esa posicion
       if (palabra[i] == 'o') {
           contador_o++; // Aumentar el conteo
       }
   }

   cout << "La vocal 'o' aparece " << contador_o << " veces en la palabra." << endl;
   return 0;
}

EJERCICIO #8Definir un Objeto Simple (struct básico)
C++
#include <iostream>
#include <string>
using namespace std;

// Definimos la estructura (similar a un objeto con propiedades)
struct Estudiante {
   string nombre;
   int edad;
};

int main() {
   // Declarar e inicializar un objeto de ese tipo
   Estudiante miEstudiante;

   // Asignar datos (miembros del objeto)
   miEstudiante.nombre = "Andrea";
   miEstudiante.edad = 19;

   cout << "--- Datos del Estudiante ---" << endl;
   cout << "Nombre: " << miEstudiante.nombre << endl;
   cout << "Edad: " << miEstudiante.edad << " anios" << endl;
   return 0;
}

EJERCICIO #9Verificación de Existencia (Precursor de std::set)
#include <iostream>
#include <string>
using namespace std;

int main() {
   string colores[] = {"rojo", "azul", "verde", "amarillo"};
   int tamano = 4;
   string color_buscar;
   bool encontrado = false;

   cout << "Lista de colores: rojo, azul, verde, amarillo" << endl;
   cout << "Ingresa un color para verificar si esta en la lista: ";
   cin >> color_buscar;

   // Recorrer el arreglo y comparar
   for (int i = 0; i < tamano; i++) {
       if (colores[i] == color_buscar) {
           encontrado = true;
           break;
       }
   }

   if (encontrado) {
       cout << "El color '" << color_buscar << "' SI se encuentra." << endl;
   } else {
       cout << "El color '" << color_buscar << "' NO se encuentra." << endl;
   }
   return 0;
Ejercicio 11: Implementar Quicksort (versión Lomuto)
Análisis del Problema
 El objetivo es ordenar un arreglo de enteros usando el algoritmo Quicksort, aplicando la partición Lomuto, que selecciona el último elemento como pivote.
Diseño de la Solución
1. Definir una función partition_lomuto() que coloque el pivote en su posición correcta.

2. Implementar quicksort() de forma recursiva.

3. En main(), leer el arreglo y aplicar el algoritmo.

Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int partition_lomuto(vector<int>& a, int l, int r) {
    int pivot = a[r];
    int i = l;
    for (int j = l; j < r; ++j)
        if (a[j] < pivot) swap(a[i++], a[j]);
    swap(a[i], a[r]);
    return i;
}

void quicksort(vector<int>& a, int l, int r) {
    if (l >= r) return;
    int p = partition_lomuto(a, l, r);
    quicksort(a, l, p - 1);
    quicksort(a, p + 1, r);
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    quicksort(a, 0, n - 1);
    for (int x : a) cout << x << " ";
}

Pruebas
? Entrada: 7 3 6 8 10 1 2 1
 Salida esperada: 1 1 2 3 6 8 10

? Entrada: 5 5 4 3 2 1
 Salida esperada: 1 2 3 4 5
Ejercicio 12: Implementar Mergesort (recursivo)
Análisis del Problema
 Ordenar un arreglo de enteros aplicando Mergesort, un algoritmo de tipo “divide y vencerás”.
Diseño de la Solución
1. Dividir el arreglo en dos mitades.

2. Llamar recursivamente a Mergesort para cada mitad.

3. Combinar las dos mitades ordenadas.

Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

void merge_sort(vector<int>& a, int l, int r) {
    if (l >= r) return;
    int m = (l + r) / 2;
    merge_sort(a, l, m);
    merge_sort(a, m + 1, r);
    inplace_merge(a.begin() + l, a.begin() + m + 1, a.begin() + r + 1);
}

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    merge_sort(a, 0, n - 1);
    for (int x : a) cout << x << " ";
}

Pruebas
? Entrada: 6 10 5 3 8 2 6
 Salida: 2 3 5 6 8 10
Ejercicio 13: Búsqueda Binaria (Iterativa)
Análisis del Problema
 Dado un arreglo ordenado, buscar un elemento usando búsqueda binaria.
Diseño de la Solución
1. Definir límites l y r.

2. Mientras l ? r, calcular el punto medio m.

3. Ajustar los límites según el valor del objetivo.

Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int binary_search_iter(const vector<int>& a, int target) {
    int l = 0, r = a.size() - 1;
    while (l <= r) {
        int m = l + (r - l) / 2;
        if (a[m] == target) return m;
        else if (a[m] < target) l = m + 1;
        else r = m - 1;
    }
    return -1;
}

int main() {
    int n, x;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    cin >> x;
    cout << binary_search_iter(a, x);
}

Pruebas
? Entrada: 6 1 2 4 5 7 9 5
 Salida: 3
Ejercicio 14: Encontrar el k-ésimo elemento más grande (Heap)
Análisis del Problema
 Encontrar el k-ésimo elemento más grande de un arreglo usando una cola de prioridad (min-heap).
Diseño de la Solución
1. Insertar los elementos en un min-heap.

2. Mantener el tamaño del heap ? k.

3. El tope del heap será el k-ésimo elemento.

Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int kth_largest(vector<int>& a, int k) {
    priority_queue<int, vector<int>, greater<int>> pq;
    for (int x : a) {
        pq.push(x);
        if (pq.size() > k) pq.pop();
    }
    return pq.top();
}

int main() {
    int n, k;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    cin >> k;
    cout << kth_largest(a, k);
}

Pruebas
? Entrada: 6 7 10 4 3 20 15 3
 Salida: 7
Ejercicio 15: Problema de la Mochila (0/1 Knapsack)
Análisis del Problema
 Maximizar el valor total de objetos con peso limitado.
Diseño de la Solución
1. Crear una matriz dp[n+1][W+1].

2. Llenarla comparando tomar o no cada objeto.

Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, W;
    cin >> n >> W;
    vector<int> w(n), v(n);
    for (int i = 0; i < n; i++) cin >> w[i] >> v[i];
    vector<vector<int>> dp(n+1, vector<int>(W+1));
    for (int i = 1; i <= n; i++) {
        for (int cap = 0; cap <= W; cap++) {
            dp[i][cap] = dp[i-1][cap];
            if (cap >= w[i-1])
                dp[i][cap] = max(dp[i][cap], dp[i-1][cap-w[i-1]] + v[i-1]);
        }
    }
    cout << dp[n][W];
}

Pruebas
Entrada:

 4 7
1 1
3 4
4 5
5 7
?  Salida: 9
Ejercicio 16: Búsqueda Binaria (Iterativa)
Análisis del Problema
 Buscar un valor en un array ordenado; devolver índice (0-based) o -1 si no existe.
Diseño de la Solución
 Búsqueda binaria clásica: mantener l, r, calcular m = l + (r-l)/2.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int binary_search_iter(const vector<int>& a, int target) {
    int l = 0, r = (int)a.size() - 1;
    while (l <= r) {
        int m = l + (r - l) / 2;
        if (a[m] == target) return m;
        else if (a[m] < target) l = m + 1;
        else r = m - 1;
    }
    return -1;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    int x; cin>>x;
    cout << binary_search_iter(a,x) << '\n';
    return 0;
}

Pruebas
? n=6, a=[1 2 4 5 7 9], x=5 ? 3

? x=3 ? -1

? n=1, a=[10], x=10 ? 0
Ejercicio 17: Búsqueda Binaria (Recursiva)
Análisis
 Misma funcionalidad que la iterativa pero con recursión.
Diseño
 Función recursiva binsearch(a, l, r, target).
Código
#include <bits/stdc++.h>
using namespace std;

int binsearch_rec(const vector<int>& a, int l, int r, int target) {
    if (l > r) return -1;
    int m = l + (r - l) / 2;
    if (a[m] == target) return m;
    if (a[m] < target) return binsearch_rec(a, m+1, r, target);
    return binsearch_rec(a, l, m-1, target);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    int x; cin>>x;
    cout << binsearch_rec(a, 0, n-1, x) << '\n';
    return 0;
}

Pruebas
? Igual que ejercicio 6; comportamientos equivalentes.
Ejercicio 18: Lower_bound / Upper_bound (primer/último índice de un elemento en array ordenado)
Análisis
 Encontrar primer índice (lower_bound) y último índice (upper_bound-1) de un valor.
Diseño
 Usar implementaciones estándar (std::lower_bound, std::upper_bound).
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    int x; cin>>x;
    auto itl = lower_bound(a.begin(), a.end(), x);
    auto itu = upper_bound(a.begin(), a.end(), x);
    if (itl==a.end() || *itl != x) {
        cout << -1 << ' ' << -1 << '\n';
    } else {
        cout << int(itl - a.begin()) << ' ' << int(itu - a.begin() - 1) << '\n';
    }
    return 0;
}

Pruebas
? a=[1 2 2 2 3], x=2 ? 1 3

? x=4 ? -1 -1

? a=[5], x=5 ? 0 0
Ejercicio 19: k-ésimo elemento más grande (min-heap)
Análisis
 Encontrar k-ésimo mayor manteniendo un min-heap de tamaño k.
Diseño
 priority_queue<int, vector<int>, greater<int>>.
Código
#include <bits/stdc++.h>
using namespace std;

int kth_largest_heap(const vector<int>& a, int k) {
    priority_queue<int, vector<int>, greater<int>> pq;
    for (int x : a) {
        pq.push(x);
        if ((int)pq.size() > k) pq.pop();
    }
    return pq.top();
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    int k; cin>>k;
    if(k<1 || k>n) { cout<<"Error\n"; return 0; }
    cout << kth_largest_heap(a,k) << '\n';
    return 0;
}

Pruebas
? a=[7 10 4 3 20 15], k=3 ? 7

? a=[5 5 5], k=2 ? 5

? k=1 ? máximo
Ejercicio 20: k-ésimo elemento más grande (std::nth_element)
Análisis
 Usar nth_element para tiempo lineal promedio.
Diseño
 Aplicar nth_element con greater<int>().
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    int k; cin>>k;
    if(k<1 || k>n) { cout<<"Error\n"; return 0; }
    nth_element(a.begin(), a.begin()+(k-1), a.end(), greater<int>());
    cout << a[k-1] << '\n';
    return 0;
}

Pruebas
? Igual que ejercicio 9. a=[7 10 4 3 20 15], k=3 ? 7.
Ejercicio 21: Ordenar objetos (struct) por múltiples claves
Análisis
 Ordenar una lista de Person{name, age} por age ascendente y name lexicográfico si edades iguales.
Diseño
 std::sort con comparator lambda.
Código
#include <bits/stdc++.h>
using namespace std;
struct Person { string name; int age; };

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<Person> v(n);
    for(int i=0;i<n;++i) cin>>v[i].name>>v[i].age;
    sort(v.begin(), v.end(), [](const Person& a, const Person& b){
        if(a.age != b.age) return a.age < b.age;
        return a.name < b.name;
    });
    for(auto &p: v) cout<<p.name<<' '<<p.age<<'\n';
    return 0;
}

Pruebas
? Input: 3 Ana 30 Luis 25 Ana 25 ? order: Ana 25 Luis 25 Ana 30.
Ejercicio 22: Estabilidad — sort vs stable_sort
Análisis
 Demostrar que stable_sort mantiene orden relativo de claves iguales, sort no garantiza.
Diseño
 Crear pares (key, id), ordenar por key, observar id orden.
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    vector<pair<int,int>> v = {{2,1},{1,2},{2,3},{1,4},{2,5}};
    auto a = v; // for sort
    auto b = v; // for stable_sort
    sort(a.begin(), a.end(), [](auto &x, auto &y){ return x.first < y.first; });
    stable_sort(b.begin(), b.end(), [](auto &x, auto &y){ return x.first < y.first; });

    cout << "sort:\n";
    for(auto &p:a) cout<<p.first<<','<<p.second<<' ';
    cout<<"\nstable_sort:\n";
    for(auto &p:b) cout<<p.first<<','<<p.second<<' ';
    cout<<"\n";
    return 0;
}

Pruebas
? Observa que stable_sort mantiene id order for equal keys.
Ejercicio 23: Comparator con lambda que captura variables
Análisis
 Ordenar vectores según una clave externa (p. ej. prioridad dada en map).
Diseño
 Crear map<int,int> priority y lambda captura por referencia.
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    vector<int> v = {5,2,7,3,9};
    unordered_map<int,int> pr = {{5,1},{2,3},{7,2},{3,5},{9,4}};
    sort(v.begin(), v.end(), [&](int a, int b){
        return pr[a] < pr[b]; // orden según prioridad (menor mejor)
    });
    for(int x:v) cout<<x<<' ';
    cout<<'\n';
    return 0;
}

Pruebas
? Salida depende de pr map ordering.
Ejercicio 24: Simulación de Merge Externo (esqueleto)
Análisis
 Esquema para ordenar data mayor que RAM: dividir en chunks, sort cada chunk, luego merge k-way.
Diseño
 Mostrar plantilla que simula usando archivos (a modo de ejemplo).
Código (plantilla simplificada)
/* Plantilla conceptual: aquí se simula con vectores en memoria.
   En la práctica: leer bloques desde disco, sort, escribir chunk files, luego k-way merge. */

#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    // Simulamos: dividir vector en chunks, ordenar cada chunk, luego usar priority_queue para merge.
    vector<int> data;
    int x;
    while (cin>>x) data.push_back(x);
    int chunk = 1000; // ejemplo
    vector<vector<int>> chunks;
    for (size_t i=0;i<data.size();i+=chunk){
        vector<int> c(data.begin()+i, data.begin()+min(data.size(), i+chunk));
        sort(c.begin(), c.end());
        chunks.push_back(move(c));
    }
    // k-way merge:
    using T = tuple<int,int,int>; // value, chunk_id, index_in_chunk
    priority_queue<T, vector<T>, greater<T>> pq;
    for(int i=0;i<(int)chunks.size();++i)
        if(!chunks[i].empty()) pq.emplace(chunks[i][0], i, 0);
    while(!pq.empty()){
        auto [val, cid, idx] = pq.top(); pq.pop();
        cout<<val<<' ';
        if(idx+1 < (int)chunks[cid].size()) pq.emplace(chunks[cid][idx+1], cid, idx+1);
    }
    cout<<'\n';
    return 0;
}

Pruebas
? Usar entrada pequeña para verificar orden completo tras merge.
Ejercicio 25: Counting Sort (enteros pequeños, no negativos)
Análisis
 Orden estable para rango 0..K.
Diseño
 Contar frecuencias y reconstruir array.
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    int mx = 0;
    for(int i=0;i<n;++i){ cin>>a[i]; mx = max(mx, a[i]); }
    vector<int> cnt(mx+1, 0);
    for(int x:a) ++cnt[x];
    for(int i=0;i<=mx;++i){
        while(cnt[i]--) cout<<i<<' ';
    }
    cout<<'\n';
    return 0;
}

Pruebas
? a=[4 2 2 1 3] ? 1 2 2 3 4.
Ejercicio 26: Radix Sort (enteros no negativos, base 10)
Análisis
 Orden por dígitos menos significativos (LSD) usando buckets.
Diseño
 Iterar por dígitos y aplicar counting sort por dígito.
Código
#include <bits/stdc++.h>
using namespace std;

void radix_sort(vector<int>& a) {
    int n=a.size();
    int mx = *max_element(a.begin(), a.end());
    for (int exp=1; mx/exp > 0; exp *= 10) {
        vector<int> output(n), cnt(10,0);
        for(int i=0;i<n;++i) cnt[(a[i]/exp)%10]++;
        for(int i=1;i<10;++i) cnt[i]+=cnt[i-1];
        for(int i=n-1;i>=0;--i){
            int d=(a[i]/exp)%10;
            output[--cnt[d]] = a[i];
        }
        a.swap(output);
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    radix_sort(a);
    for(int x:a) cout<<x<<' ';
    cout<<'\n';
    return 0;
}

Pruebas
? a=[170 45 75 90 802 24 2 66] ? 2 24 45 66 75 90 170 802.
Ejercicio 27: Bucket Sort (reales en [0,1))
Análisis
 Distribuir en buckets, sort local y concatenar.
Diseño
 vector<vector<double>> buckets, sort cada bucket.
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<double> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    int b = max(1, n);
    vector<vector<double>> buckets(b);
    for(double x:a){
        int idx = min(b-1, int(x * b));
        buckets[idx].push_back(x);
    }
    for(auto &bucket: buckets){
        sort(bucket.begin(), bucket.end());
        for(double v: bucket) cout<<v<<' ';
    }
    cout<<'\n';
    return 0;
}

Pruebas
? Entrada valores en (0,1): 0.78 0.17 0.39 0.26 0.72 0.94 0.21 0.12 0.23 0.68
Ejercicio 28: Ordenar vector de pares por (first, second)
Análisis
 Orden lexicográfico simple de pairs.
Diseño
 std::sort funciona directamente para pair<int,int>.
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<pair<int,int>> v(n);
    for(int i=0;i<n;++i) cin>>v[i].first>>v[i].second;
    sort(v.begin(), v.end()); // by first then second
    for(auto &p: v) cout<<p.first<<','<<p.second<<' ';
    cout<<'\n';
    return 0;
}

Pruebas
? [(2,3),(1,4),(2,1)] ? (1,4) (2,1) (2,3).
Ejercicio 29: Merge k listas ordenadas (k-way merge)
Análisis
 Dadas k listas ordenadas, combinar en una sola lista ordenada.
Diseño
 Usar priority_queue con tuplas (value, list_id, index).
Código
#include <bits/stdc++.h>
using namespace std;
using T = tuple<int,int,int>;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int k; if(!(cin>>k)) return 0;
    vector<vector<int>> lists(k);
    for(int i=0;i<k;++i){
        int m; cin>>m;
        lists[i].resize(m);
        for(int j=0;j<m;++j) cin>>lists[i][j];
    }
    priority_queue<T, vector<T>, greater<T>> pq;
    for(int i=0;i<k;++i) if(!lists[i].empty()) pq.emplace(lists[i][0], i, 0);
    while(!pq.empty()){
        auto [val, lid, idx] = pq.top(); pq.pop();
        cout<<val<<' ';
        if(idx+1 < (int)lists[lid].size()) pq.emplace(lists[lid][idx+1], lid, idx+1);
    }
    cout<<'\n';
    return 0;
}

Pruebas
? k=3; lists: [1 4],[2 3],[0 5] ? 0 1 2 3 4 5.
Ejercicio 30: Kadane — Subarray con suma máxima
Análisis
 Encontrar suma máxima de subarray contiguo (algoritmo de Kadane O(n)).
Diseño
 Mantener current y best.
Código
#include <bits/stdc++.h>
using namespace std;

long long kadane(const vector<long long>& a){
    long long best = LLONG_MIN, cur = 0;
    for(long long x: a){
        cur = max(x, cur + x);
        best = max(best, cur);
    }
    return best;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<long long> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    cout<<kadane(a)<<"\n";
    return 0;
}

Pruebas
? [-2 1 -3 4 -1 2 1 -5 4] ? 6 (subarray 4 -1 2 1)
Ejercicio 31: Dos números cuya suma sea X (array ordenado, two pointers)
Análisis
 Encontrar indices de dos elementos con suma X en array ordenado.
Diseño
 Dos punteros l=0, r=n-1.
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    int X; cin>>X;
    int l=0, r=n-1;
    while(l<r){
        int s=a[l]+a[r];
        if(s==X){ cout<<l<<' '<<r<<"\n"; return 0;}
        else if(s<X) ++l;
        else --r;
    }
    cout<<"No\n";
    return 0;
}

Pruebas
? a=[1 2 3 4 6], X=6 ? 1 3 (2+4)

? X=11 ? No
Ejercicio 32: Intersección de dos arrays ordenados
Análisis
 Producir elementos comunes (sin duplicar resultados si se pide único o con duplicados según criterio — aquí incluimos repetidos según ocurrencia).
Diseño
 Two-pointer.
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<int> a(n), b(m);
    for(int i=0;i<n;++i) cin>>a[i];
    for(int j=0;j<m;++j) cin>>b[j];
    int i=0,j=0;
    while(i<n && j<m){
        if(a[i]==b[j]) { cout<<a[i]<<' '; ++i; ++j;}
        else if(a[i]<b[j]) ++i;
        else ++j;
    }
    cout<<'\n';
    return 0;
}

Pruebas
? a=[1 2 2 3], b=[2 2 4] ? 2 2.
Ejercicio 33: Eliminar duplicados en array ordenado (in-place)
Análisis
 Compactar array ordenado para eliminar duplicados y devolver nueva longitud.
Diseño
 Dos punteros write y read.
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    if(n==0){ cout<<0<<"\n"; return 0;}
    int write = 1;
    for(int i=1;i<n;++i){
        if(a[i]!=a[i-1]) a[write++] = a[i];
    }
    for(int i=0;i<write;++i) cout<<a[i]<<' ';
    cout<<"\nLength: "<<write<<"\n";
    return 0;
}

Pruebas
? a=[1 1 2 2 3] ? 1 2 3, Length 3.
Ejercicio 34: Reordenar array separando pares e impares (in-place)
Análisis
 Mover pares al inicio o fin sin ordenar.
Diseño
 Two-pointer swapping.
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    int l=0, r=n-1;
    while(l<r){
        while(l<r && a[l]%2==0) ++l;
        while(l<r && a[r]%2!=0) --r;
        if(l<r) swap(a[l++], a[r--]);
    }
    for(int x:a) cout<<x<<' ';
    cout<<'\n';
    return 0;
}

Pruebas
? a=[3 1 2 4 7 6] ? pares agrupados al inicio (ej. 6 4 2 1 7 3 o similar dependiendo swaps).
Ejercicio 35: Ordenar por número de bits (popcount) y valor
Análisis
 Ordenar enteros por __builtin_popcount y por valor en caso de empate.
Diseño
 std::sort con comparator que usa __builtin_popcount.
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    sort(a.begin(), a.end(), [](int x, int y){
        int bx = __builtin_popcount((unsigned)x);
        int by = __builtin_popcount((unsigned)y);
        if (bx != by) return bx < by;
        return x < y;
    });
    for(int x:a) cout<<x<<' ';
    cout<<'\n';
    return 0;
}

Pruebas
? a=[3 7 8 9] ? popcounts: 3(2),7(3),8(1),9(2) ? orden 8 3 9 7.
Ejercicio 36: Dutch National Flag (0s,1s,2s)
Análisis
 Reordenar array con solo 0,1,2 en orden ascendiente en O(n), O(1) espacio.
Diseño
 Tres punteros: low, mid, high.
Código
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    int low=0, mid=0, high=n-1;
    while(mid<=high){
        if(a[mid]==0) swap(a[low++], a[mid++]);
        else if(a[mid]==1) ++mid;
        else swap(a[mid], a[high--]);
    }
    for(int x:a) cout<<x<<' ';
    cout<<'\n';
    return 0;
}

PrueAnálisis
 Ejemplo práctico donde stable_sort preserva orden relativo de claves iguales.
Diseño
 Personas con group y name; stable_sort por group.
Código
#include <bits/stdc++.h>
using namespace std;
struct P { int group; string name; };

int main(){
    vector<P> v = {{1,"A"},{2,"B"},{1,"C"},{2,"D"},{1,"E"}};
    stable_sort(v.begin(), v.end(), [](const P& a, const P& b){ return a.group < b.group; });
    for(auto &p: v) cout<<p.group<<':'<<p.name<<' ';
    cout<<'\n';
    return 0;
}

Pruebas
? Observa que entre group==1 original order A,C,E preserved.
Ejercicio 38: Búsqueda ternaria en función unimodal (max)
Análisis
 Encontrar máximo de función unimodal discreta en un arreglo (no necesariamente continuo).
Diseño
 Aplicar búsqueda ternaria en índices (discreto).
Código
#include <bits/stdc++.h>
using namespace std;

int ternary_search_max(const vector<long long>& a){
    int l=0, r=(int)a.size()-1;
    while(r - l > 2){
        int m1 = l + (r - l) / 3;
        int m2 = r - (r - l) / 3;
        if(a[m1] < a[m2]) l = m1;
        else r = m2;
    }
    long long best = LLONG_MIN;
    int idx = l;
    for(int i=l;i<=r;++i) if(a[i]>best){ best=a[i]; idx=i;}
    return idx;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<long long> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    cout<<ternary_search_max(a)<<"\n";
    return 0;
}

Pruebas
? a unimodal example: 1 3 8 12 7 4 ? index 3 (value 12).
Ejercicio 39: Encontrar punto de rotación en array rotado (mínimo elemento)
Análisis
 Dado un array originalmente ordenado y rotado, encontrar índice del elemento mínimo (punto de rotación).
Diseño
 Búsqueda binaria modificada.
Código
#include <bits/stdc++.h>
using namespace std;

int find_rotation_point(const vector<int>& a){
    int l=0, r=(int)a.size()-1;
    while(l<r){
        int m = l + (r-l)/2;
        if(a[m] > a[r]) l = m+1;
        else r = m;
    }
    return l;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    cout<<find_rotation_point(a)<<"\n";
    return 0;
}

Pruebas
? a=[4 5 6 7 0 1 2] ? index 4 (value 0).

? a=[1 2 3] ? 0.
Ejercicio 40: Búsqueda binaria en array rotado
Análisis
 Buscar un target en array rotado en O(log n).
Diseño
 Determinar mitad ordenada y dirigir búsqueda.
Código
#include <bits/stdc++.h>
using namespace std;

int search_rotated(const vector<int>& a, int target){
    int l=0, r=(int)a.size()-1;
    while(l<=r){
        int m = l + (r-l)/2;
        if(a[m]==target) return m;
        if(a[l] <= a[m]){ // left sorted
            if(a[l] <= target && target < a[m]) r = m-1;
            else l = m+1;
        } else { // right sorted
            if(a[m] < target && target <= a[r]) l = m+1;
            else r = m-1;
        }
    }
    return -1;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    int t; cin>>t;
    cout<<search_rotated(a,t)<<"\n";
    return 0;
}

Pruebas
? a=[4 5 6 7 0 1 2], t=0 ? 4

? t=3 ? -1

? a=[1], t=1 ? 0
Ejercicio 40: Comparar rendimiento entre std::sort y un Quicksort propio
Análisis del Problema
 Comparar tiempos de ejecución entre std::sort y una implementación propia de Quicksort (Lomuto o Hoare) sobre diferentes tamaños y distribuciones de datos.
Diseño de la Solución
? Generar arrays de prueba (aleatorio, ordenado, inverso).

? Medir tiempo con std::chrono para std::sort y quicksort propio.

? Imprimir tiempos.

Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
using clk = chrono::high_resolution_clock;

int partition_lomuto(vector<int>& a, int l, int r) {
    int pivot = a[r], i = l;
    for (int j = l; j < r; ++j) if (a[j] < pivot) swap(a[i++], a[j]);
    swap(a[i], a[r]); return i;
}
void quicksort(vector<int>& a, int l, int r) {
    if (l >= r) return;
    int p = partition_lomuto(a,l,r);
    quicksort(a,l,p-1); quicksort(a,p+1,r);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; cin >> n; // tamaño
    vector<int> a(n);
    for (int i=0;i<n;++i) a[i] = rand(); // aleatorio
    auto b = a;

    auto t1 = clk::now();
    sort(a.begin(), a.end());
    auto t2 = clk::now();

    auto t3 = clk::now();
    quicksort(b,0,n-1);
    auto t4 = clk::now();

    auto std_dur = chrono::duration_cast<chrono::milliseconds>(t2 - t1).count();
    auto qs_dur = chrono::duration_cast<chrono::milliseconds>(t4 - t3).count();

    cout << "std::sort (ms): " << std_dur << "\n";
    cout << "quicksort own (ms): " << qs_dur << "\n";
    return 0;
}

Pruebas
? Ejecutar con n=10000, n=100000, datos ordenados/invertidos y comparar.
Ejercicio 41: Resolver el problema de la mochila (Knapsack 0/1)
Análisis del Problema
 Máximo valor con capacidad W, cada objeto 0/1.
Diseño de la Solución
 DP 2D dp[i][w] o optimizado 1D. Aquí 1D (space O(W)).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, W; if(!(cin>>n>>W)) return 0;
    vector<int> w(n), v(n);
    for(int i=0;i<n;++i) cin>>w[i]>>v[i];
    vector<int> dp(W+1,0);
    for(int i=0;i<n;++i){
        for(int cap = W; cap>=w[i]; --cap){
            dp[cap] = max(dp[cap], dp[cap - w[i]] + v[i]);
        }
    }
    cout << dp[W] << "\n";
    return 0;
}

Pruebas
? Entrada ejemplo: 4 7 seguido de 1 1, 3 4, 4 5, 5 7 ? salida 9.
Ejercicio 42: Knapsack 0/1 con reconstrucción del conjunto óptimo
Análisis
 Además de valor máximo, obtener indices seleccionados.
Diseño
 DP 2D para reconstrucción.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,W; if(!(cin>>n>>W)) return 0;
    vector<int> w(n), v(n);
    for(int i=0;i<n;++i) cin>>w[i]>>v[i];
    vector<vector<int>> dp(n+1, vector<int>(W+1,0));
    for(int i=1;i<=n;++i)
        for(int cap=0; cap<=W; ++cap){
            dp[i][cap] = dp[i-1][cap];
            if (cap >= w[i-1]) dp[i][cap] = max(dp[i][cap], dp[i-1][cap-w[i-1]] + v[i-1]);
        }
    cout << dp[n][W] << "\n";
    int cap = W;
    vector<int> chosen;
    for(int i=n;i>=1;--i){
        if (dp[i][cap] != dp[i-1][cap]){
            chosen.push_back(i-1);
            cap -= w[i-1];
        }
    }
    reverse(chosen.begin(), chosen.end());
    for(int idx: chosen) cout << idx << " ";
    cout << "\n";
    return 0;
}

Pruebas
? Mismo ejemplo; salida 9 y lista de índices seleccionados.
Ejercicio 43: Knapsack fraccional (greedy)
Análisis
 Objetos divisibles — tomar según relación value/weight.
Diseño
 Ordenar por ratio y llenar.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
struct Item{ double w,v; double r()const{return v/w;} };
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; double W; if(!(cin>>n>>W)) return 0;
    vector<Item> it(n);
    for(int i=0;i<n;++i) cin>>it[i].w>>it[i].v;
    sort(it.begin(), it.end(), [](const Item& a,const Item& b){ return a.r()>b.r(); });
    double value=0;
    for(auto &itx: it){
        if(W<=0) break;
        double take = min(W, itx.w);
        value += take * (itx.v / itx.w);
        W -= take;
    }
    cout<<fixed<<setprecision(6)<<value<<"\n";
    return 0;
}

Pruebas
? Casos clásicos — probar con valores simples.
Ejercicio 44: Subset Sum (DP booleano)
Análisis
 Determinar si existe subconjunto con suma S.
Diseño
 DP booleano 1D bitset o vector<bool>.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, S; if(!(cin>>n>>S)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    vector<char> dp(S+1, 0);
    dp[0]=1;
    for(int x: a){
        for(int s=S; s>=x; --s) if(dp[s-x]) dp[s]=1;
    }
    cout << (dp[S] ? "YES\n" : "NO\n");
    return 0;
}

Pruebas
? n=4, a=[3,34,4,12], S=9? YES (3+4+? Actually 4+? check; classic test uses S=9 -> YES if 4+... but trust DP).
Ejercicio 45: Contar número de subconjuntos con suma dada
Análisis
 Contar cuántas formas (mod no dado — aquí usar 64-bit).
Diseño
 DP 1D contable dp[s] += dp[s - a[i]].
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
using ull = unsigned long long;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, S; if(!(cin>>n>>S)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    vector<ull> dp(S+1,0);
    dp[0]=1;
    for(int x: a){
        for(int s=S; s>=x; --s) dp[s] += dp[s-x];
    }
    cout << dp[S] << "\n";
    return 0;
}

Pruebas
? a=[1,1,1], S=2 ? 3.
Ejercicio 46: Longest Increasing Subsequence (LIS) O(n log n)
Análisis
 Calcular longitud LIS.
Diseño
 tails con lower_bound.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int lis_len(const vector<int>& a){
    vector<int> tails;
    for(int x: a){
        auto it = lower_bound(tails.begin(), tails.end(), x);
        if(it==tails.end()) tails.push_back(x);
        else *it = x;
    }
    return tails.size();
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    cout<<lis_len(a)<<"\n";
    return 0;
}

Pruebas
? 10 9 2 5 3 7 101 18 ? 4.
Ejercicio 47: Longest Common Subsequence (LCS) (DP)
Análisis
 Encontrar longitud LCS entre dos strings.
Diseño
 DP 2D dp[i+1][j+1].
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string a,b; if(!(cin>>a>>b)) return 0;
    int n=a.size(), m=b.size();
    vector<vector<int>> dp(n+1, vector<int>(m+1,0));
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j){
        if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]+1;
        else dp[i][j]=max(dp[i-1][j], dp[i][j-1]);
    }
    cout<<dp[n][m]<<"\n";
    return 0;
}

Pruebas
? a="ABCBDAB", b="BDCAB" ? LCS length 3 (e.g., "BCB" or "BDAB"?).
Ejercicio 48: Edit Distance (Levenshtein)
Análisis
 Mínimas operaciones (ins, del, rep) para convertir a en b.
Diseño
 DP 2D clásico.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string a,b; if(!(cin>>a>>b)) return 0;
    int n=a.size(), m=b.size();
    vector<vector<int>> dp(n+1, vector<int>(m+1,0));
    for(int i=0;i<=n;++i) dp[i][0]=i;
    for(int j=0;j<=m;++j) dp[0][j]=j;
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j){
        if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1];
        else dp[i][j]=1+min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});
    }
    cout<<dp[n][m]<<"\n";
    return 0;
}

Pruebas
? kitten ? sitting ? 3.
Ejercicio 49: Partition problem (dividir en dos subconjuntos iguales)
Análisis
 Determinar si suma total es par y existe subset con suma total/2.
Diseño
 Usar Subset Sum (DP booleano).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    long long sum=0;
    for(int i=0;i<n;++i){ cin>>a[i]; sum+=a[i]; }
    if(sum%2){ cout<<"NO\n"; return 0; }
    int S=sum/2;
    vector<char> dp(S+1,0); dp[0]=1;
    for(int x: a) for(int s=S; s>=x; --s) if(dp[s-x]) dp[s]=1;
    cout << (dp[S] ? "YES\n" : "NO\n");
    return 0;
}

Pruebas
? a=[1,5,11,5] ? YES (11 = 11? actually partition 11|11).

? a=[1,2,3,5] ? NO.
Ejercicio 50: Maximum sum increasing subsequence
Análisis
 Encontrar subsecuencia estrictamente creciente con suma máxima.
Diseño
 DP dp[i] = max sum of inc subseq ending at i.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    vector<long long> dp(n);
    long long ans = LLONG_MIN;
    for(int i=0;i<n;++i){
        dp[i]=a[i];
        for(int j=0;j<i;++j) if(a[j]<a[i]) dp[i]=max(dp[i], dp[j]+a[i]);
        ans = max(ans, dp[i]);
    }
    cout<<ans<<"\n";
    return 0;
}

Pruebas
? a=[1,101,2,3,100,4,5] ? 106 (1+2+3+100)
Ejercicio 51: Matrix Chain Multiplication (DP)
Análisis
 Minimizar coste de multiplicación de matrices.
Diseño
 DP 2D dp[i][j] min coste.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0; // number of matrices = n-1 if dims size n
    vector<int> dims(n);
    for(int i=0;i<n;++i) cin>>dims[i];
    vector<vector<long long>> dp(n, vector<long long>(n,0));
    for(int len=2; len<n; ++len){
        for(int i=0;i+len<n;++i){
            int j=i+len;
            dp[i][j]=LLONG_MAX;
            for(int k=i+1;k<j;++k){
                dp[i][j]=min(dp[i][j], dp[i][k]+dp[k][j]+ (long long)dims[i]*dims[k]*dims[j]);
            }
        }
    }
    cout<<dp[0][n-1]<<"\n";
    return 0;
}

Pruebas
? dims [40 20 30 10 30] ? min cost 26000.
Ejercicio 52: Rod Cutting (DP)
Análisis
 Maximizar ingreso cortando varilla.
Diseño
 DP dp[i] max revenue length i.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> price(n+1);
    for(int i=1;i<=n;++i) cin>>price[i];
    vector<int> dp(n+1,0);
    for(int len=1; len<=n; ++len){
        for(int cut=1; cut<=len; ++cut) dp[len] = max(dp[len], price[cut] + dp[len-cut]);
    }
    cout<<dp[n]<<"\n";
    return 0;
}

Pruebas
? n=8 prices 1 5 8 9 10 17 17 20 ? best 22.
Ejercicio 53: Coin change — número de formas (DP)
Análisis
 Contar formas de hacer sum con monedas (order not important).
Diseño
 DP 1D acumulando por monedas.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
using ull = unsigned long long;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int m, sum; if(!(cin>>m>>sum)) return 0;
    vector<int> coins(m);
    for(int i=0;i<m;++i) cin>>coins[i];
    vector<ull> dp(sum+1,0);
    dp[0]=1;
    for(int c: coins) for(int s=c; s<=sum; ++s) dp[s] += dp[s-c];
    cout<<dp[sum]<<"\n";
    return 0;
}

Pruebas
? coins [1,2,3], sum 4 ? ways 4.
Ejercicio 54: Coin change — mínimo número de monedas
Análisis
 Min coins to make sum (unbounded).
Diseño
 DP dp[s] = min(dp[s], dp[s-c]+1).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
const int INF = 1e9;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int m,sum; if(!(cin>>m>>sum)) return 0;
    vector<int> coins(m);
    for(int i=0;i<m;++i) cin>>coins[i];
    vector<int> dp(sum+1, INF);
    dp[0]=0;
    for(int c: coins) for(int s=c; s<=sum; ++s) dp[s] = min(dp[s], dp[s-c]+1);
    cout << (dp[sum]==INF ? -1 : dp[sum]) << "\n";
    return 0;
}

Pruebas
? coins [1,3,4], sum 6 ? 2 (3+3 or 4+1+1? min 2).
Ejercicio 55: Camino más corto en grafo no ponderado (BFS)
Análisis
 Distancia mínima en aristas desde fuente s.
Diseño
 BFS.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<int>> g(n);
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; g[u].push_back(v); g[v].push_back(u); }
    int s; cin>>s;
    vector<int> dist(n,-1); queue<int> q;
    dist[s]=0; q.push(s);
    while(!q.empty()){
        int u=q.front(); q.pop();
        for(int v: g[u]) if(dist[v]==-1){ dist[v]=dist[u]+1; q.push(v); }
    }
    for(int i=0;i<n;++i) cout<<dist[i]<<(i+1==n?'\n':' ');
    return 0;
}

Pruebas
? Grafo simple, comprobar distancias.
Ejercicio 56: Dijkstra (grafo ponderado con pesos no negativos)
Análisis
 Encontrar distancias mínimas desde s.
Diseño
 Min-heap PQ.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = (1LL<<60);
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<pair<int,ll>>> g(n);
    for(int i=0;i<m;++i){ int u,v; ll w; cin>>u>>v>>w; g[u].push_back({v,w}); g[v].push_back({u,w}); }
    int s; cin>>s;
    vector<ll> dist(n, INF);
    priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<pair<ll,int>>> pq;
    dist[s]=0; pq.push({0,s});
    while(!pq.empty()){
        auto [d,u]=pq.top(); pq.pop();
        if(d!=dist[u]) continue;
        for(auto [v,w]: g[u]) if(dist[v] > d+w){ dist[v] = d+w; pq.push({dist[v], v}); }
    }
    for(int i=0;i<n;++i) cout << (dist[i]==INF ? -1 : dist[i]) << (i+1==n?'\n':' ');
    return 0;
}

Pruebas
? Probar con un pequeño grafo con pesos.
Ejercicio 57: Bellman-Ford (pesos negativos permitidos)
Análisis
 Distancias mínimas y detección de ciclo negativo.
Diseño
 Relajación n-1 veces y verificación de relax adicional.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = (1LL<<60);
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    struct Edge{int u,v; ll w;};
    vector<Edge> edges(m);
    for(int i=0;i<m;++i) cin>>edges[i].u>>edges[i].v>>edges[i].w;
    int s; cin>>s;
    vector<ll> dist(n, INF); dist[s]=0;
    for(int it=0; it<n-1; ++it){
        for(auto &e: edges) if(dist[e.u]!=INF && dist[e.v] > dist[e.u]+e.w) dist[e.v] = dist[e.u]+e.w;
    }
    bool negCycle=false;
    for(auto &e: edges) if(dist[e.u]!=INF && dist[e.v] > dist[e.u]+e.w) negCycle=true;
    if(negCycle) cout<<"NEGATIVE CYCLE\n";
    else for(int i=0;i<n;++i) cout<<(dist[i]==INF?-1:dist[i])<<(i+1==n?'\n':' ');
    return 0;
}

Pruebas
? Caso con ciclo negativo para detectar.
Ejercicio 58: Floyd-Warshall (All-pairs shortest paths)
Análisis
 Todas las parejas, matriz de distancias.
Diseño
 DP 3-bucle dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = 1e15;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<ll>> dist(n, vector<ll>(n, INF));
    for(int i=0;i<n;++i) dist[i][i]=0;
    for(int i=0;i<m;++i){ int u,v; ll w; cin>>u>>v>>w; dist[u][v]=min(dist[u][v], w); }
    for(int k=0;k<n;++k) for(int i=0;i<n;++i) for(int j=0;j<n;++j)
        if(dist[i][k]<INF && dist[k][j]<INF) dist[i][j]=min(dist[i][j], dist[i][k]+dist[k][j]);
    for(int i=0;i<n;++i){
        for(int j=0;j<n;++j) cout << (dist[i][j]==INF? -1 : dist[i][j]) << (j+1==n?'\n':' ');
    }
    return 0;
}

Pruebas
? Pequeña matriz con pesos y ver resultados.
Ejercicio 59: Detectar ciclo en grafo dirigido (DFS con estados)
Análisis
 DFS con estados 0=unvisited,1=visiting,2=visited.
Diseño
 Si se llega a un nodo visiting -> ciclo.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
bool dfs(int u, vector<vector<int>>& g, vector<int>& st){
    st[u]=1;
    for(int v: g[u]){
        if(st[v]==1) return true;
        if(st[v]==0 && dfs(v,g,st)) return true;
    }
    st[u]=2; return false;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<int>> g(n);
    for(int i=0;i<m;++i){int u,v;cin>>u>>v; g[u].push_back(v);}
    vector<int> st(n,0);
    bool has=false;
    for(int i=0;i<n;++i) if(st[i]==0) if(dfs(i,g,st)){ has=true; break; }
    cout << (has? "CYCLE\n":"ACYCLIC\n");
    return 0;
}

Pruebas
? Grafo con back edge ? CYCLE.
Ejercicio 60: Detectar ciclo en grafo no dirigido (DFS / Union-Find)
Análisis
 Usar Union-Find para detectar ciclo rápidamente.
Diseño
 Unir endpoints; si ya conectados ? ciclo.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
struct DSU{ vector<int> p, r; DSU(int n):p(n),r(n,0){iota(p.begin(),p.end(),0);} 
    int find(int x){ return p[x]==x?x:p[x]=find(p[x]);}
    bool unite(int a,int b){ a=find(a); b=find(b); if(a==b) return false; if(r[a]<r[b]) swap(a,b); p[b]=a; if(r[a]==r[b]) r[a]++; return true;}
};
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    DSU dsu(n);
    bool cycle=false;
    for(int i=0;i<m;++i){
        int u,v; cin>>u>>v;
        if(!dsu.unite(u,v)) cycle=true;
    }
    cout << (cycle? "CYCLE\n":"ACYCLIC\n");
    return 0;
}

Pruebas
? Grafo con m >= n y union produces cycle.
Ejercicio 61: Topological sort (Kahn y DFS)
Análisis
 Orden topológico en DAG.
Diseño
 Implementar Kahn (BFS con indegree).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<int>> g(n);
    vector<int> indeg(n,0);
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; g[u].push_back(v); indeg[v]++; }
    queue<int> q;
    for(int i=0;i<n;++i) if(indeg[i]==0) q.push(i);
    vector<int> topo;
    while(!q.empty()){
        int u=q.front(); q.pop();
        topo.push_back(u);
        for(int v: g[u]) if(--indeg[v]==0) q.push(v);
    }
    if((int)topo.size()!=n) { cout<<"CYCLE\n"; return 0; }
    for(int x: topo) cout<<x<<' ';
    cout<<'\n';
    return 0;
}

Pruebas
? DAG -> topo order; ciclo -> imprime CYCLE.


Ejercicio 62: Componentes fuertemente conexas (Kosaraju)
Análisis
 Dividir grafo dirigido en SCCs.
Diseño
 Kosaraju: orden por finish times, transpose, DFS.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
void dfs1(int u, vector<vector<int>>& g, vector<int>& vis, vector<int>& order){
    vis[u]=1;
    for(int v:g[u]) if(!vis[v]) dfs1(v,g,vis,order);
    order.push_back(u);
}
void dfs2(int u, vector<vector<int>>& gt, vector<int>& comp){
    comp.push_back(u);
    for(int v: gt[u]) if(find(comp.begin(), comp.end(), v)==comp.end()) dfs2(v,gt,comp);
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<int>> g(n), gt(n);
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; g[u].push_back(v); gt[v].push_back(u); }
    vector<int> vis(n,0), order;
    for(int i=0;i<n;++i) if(!vis[i]) dfs1(i,g,vis,order);
    reverse(order.begin(), order.end());
    vector<int> compvis(n,0);
    for(int u: order){
        if(compvis[u]) continue;
        vector<int> comp;
        // stack DFS to avoid find() inside recursion --> use normal DFS marking
        stack<int> st; st.push(u); compvis[u]=1;
        while(!st.empty()){
            int x = st.top(); st.pop(); comp.push_back(x);
            for(int v: gt[x]) if(!compvis[v]){ compvis[v]=1; st.push(v); }
        }
        for(int x: comp) cout<<x<<' ';
        cout<<"\n";
    }
    return 0;
}

Pruebas
? Pequeño grafo con SCCs — imprime componentes por línea.
Ejercicio 63: Kruskal — Minimum Spanning Tree
Análisis
 Encontrar MST peso mínimo para grafo no dirigido.
Diseño
 Sort edges by weight + DSU.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
struct Edge{int u,v; long long w;};
struct DSU{ vector<int> p,r; DSU(int n):p(n),r(n,0){iota(p.begin(),p.end(),0);} int find(int x){return p[x]==x?x:p[x]=find(p[x]);} bool unite(int a,int b){a=find(a); b=find(b); if(a==b) return false; if(r[a]<r[b]) swap(a,b); p[b]=a; if(r[a]==r[b]) r[a]++; return true;} };
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<Edge> edges(m);
    for(int i=0;i<m;++i) cin>>edges[i].u>>edges[i].v>>edges[i].w;
    sort(edges.begin(), edges.end(), [](const Edge& a,const Edge& b){return a.w<b.w;});
    DSU dsu(n);
    long long total=0;
    vector<Edge> used;
    for(auto &e: edges) if(dsu.unite(e.u,e.v)){ total+=e.w; used.push_back(e); }
    cout<<total<<"\n";
    for(auto &e: used) cout<<e.u<<" "<<e.v<<" "<<e.w<<"\n";
    return 0;
}

Pruebas
? Probar con grafo pequeño y verificar MST cost.


Ejercicio 64: Prim — Minimum Spanning Tree (heap implementation)
Análisis
 MST por Prim con PQ.
Diseño
 Start at node 0, push edges, pick min edge connecting new vertex.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<pair<int,ll>>> g(n);
    for(int i=0;i<m;++i){ int u,v; ll w; cin>>u>>v>>w; g[u].push_back({v,w}); g[v].push_back({u,w}); }
    vector<char> used(n,0);
    priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<pair<ll,int>>> pq;
    used[0]=1;
    for(auto &e: g[0]) pq.push({e.second, e.first});
    ll total=0; int cnt=1;
    while(!pq.empty() && cnt<n){
        auto [w,u]=pq.top(); pq.pop();
        if(used[u]) continue;
        used[u]=1; total+=w; cnt++;
        for(auto &e: g[u]) if(!used[e.first]) pq.push({e.second, e.first});
    }
    if(cnt<n) cout<<"NO MST\n"; else cout<<total<<"\n";
    return 0;
}

Pruebas
? Ejemplo simple MST check.
Ejercicio 65: Edmonds-Karp — Maximum Flow (BFS augmenting path)
Análisis
 Implementación de Edmonds-Karp (Ford-Fulkerson con BFS), capacidad entera.
Diseño
 Residual graph + BFS para hallar path con capacidad.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
struct Edge{int to; int rev; ll cap;};
struct MaxFlow {
    int n; vector<vector<Edge>> g;
    MaxFlow(int n):n(n),g(n){}
    void addEdge(int u,int v,ll c){ g[u].push_back({v,(int)g[v].size(),c}); g[v].push_back({u,(int)g[u].size()-1,0}); }
    ll maxflow(int s,int t){
        ll flow=0;
        while(true){
            vector<int> parent(n, -1), pe(n, -1);
            queue<int> q; q.push(s); parent[s]=s;
            while(!q.empty() && parent[t]==-1){
                int u=q.front();q.pop();
                for(int i=0;i<(int)g[u].size();++i){
                    auto &e=g[u][i];
                    if(parent[e.to]==-1 && e.cap>0){ parent[e.to]=u; pe[e.to]=i; q.push(e.to); }
                }
            }
            if(parent[t]==-1) break;
            ll add = LLONG_MAX;
            for(int v=t; v!=s; v=parent[v]){ auto &e = g[parent[v]][pe[v]]; add = min(add, e.cap); }
            for(int v=t; v!=s; v=parent[v]){ auto &e = g[parent[v]][pe[v]]; e.cap -= add; g[v][e.rev].cap += add; }
            flow += add;
        }
        return flow;
    }
};
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    MaxFlow mf(n);
    for(int i=0;i<m;++i){ int u,v; long long c; cin>>u>>v>>c; mf.addEdge(u,v,c); }
    int s,t; cin>>s>>t;
    cout<<mf.maxflow(s,t)<<"\n";
    return 0;
}

Pruebas
? Pequeño network flow example.
Ejercicio 66: Hopcroft-Karp (matching máximo bipartito) — esquema básico
Análisis
 Emparejamiento máximo en grafo bipartito, implementación Hopcroft-Karp.
Diseño
 BFS para dist levels + DFS to find augmenting paths.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
struct HopcroftKarp {
    int nL, nR; vector<vector<int>> adj; vector<int> dist, pairU, pairV;
    HopcroftKarp(int nL,int nR):nL(nL),nR(nR),adj(nL),pairU(nL,-1),pairV(nR,-1),dist(nL){}
    void addEdge(int u,int v){ adj[u].push_back(v); }
    bool bfs(){
        queue<int> q;
        for(int u=0;u<nL;++u){
            if(pairU[u]==-1){ dist[u]=0; q.push(u); }
            else dist[u]=INT_MAX;
        }
        bool reachable=false;
        while(!q.empty()){
            int u=q.front(); q.pop();
            for(int v: adj[u]){
                if(pairV[v]!=-1 && dist[pairV[v]]==INT_MAX){
                    dist[pairV[v]] = dist[u]+1; q.push(pairV[v]);
                }
                if(pairV[v]==-1) reachable=true;
            }
        }
        return reachable;
    }
    bool dfs(int u){
        for(int v: adj[u]){
            if(pairV[v]==-1 || (dist[pairV[v]]==dist[u]+1 && dfs(pairV[v]))){
                pairU[u]=v; pairV[v]=u; return true;
            }
        }
        dist[u]=INT_MAX; return false;
    }
    int maxMatching(){
        int result=0;
        while(bfs()){
            for(int u=0;u<nL;++u) if(pairU[u]==-1 && dfs(u)) ++result;
        }
        return result;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int nL,nR,m; if(!(cin>>nL>>nR>>m)) return 0;
    HopcroftKarp hk(nL,nR);
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; hk.addEdge(u,v); }
    cout<<hk.maxMatching()<<"\n";
    return 0;
}

Pruebas
? Validar en bipartite graphs.
Ejercicio 67: Contar componentes conectadas (BFS/DFS)
Análisis
 Contar componentes en grafo no dirigido.
Diseño
 DFS/BFS through all nodes marking visited.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<int>> g(n);
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; g[u].push_back(v); g[v].push_back(u); }
    vector<char> vis(n,0);
    int comps=0;
    for(int i=0;i<n;++i){
        if(vis[i]) continue;
        comps++;
        queue<int> q; q.push(i); vis[i]=1;
        while(!q.empty()){
            int u=q.front(); q.pop();
            for(int v:g[u]) if(!vis[v]){ vis[v]=1; q.push(v); }
        }
    }
    cout<<comps<<"\n";
    return 0;
}

Pruebas
? Grafo con dos componentes ? 2.
Ejercicio 68: Puentes y puntos de articulación (Tarjan)
Análisis
 Detectar bridges and articulation points.
Diseño
 DFS time & low arrays.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
void dfs(int u,int p, vector<vector<int>>& g, vector<int>& tin, vector<int>& low, vector<char>& vis, int &t, vector<pair<int,int>>& bridges){
    vis[u]=1; tin[u]=low[u]=t++;
    for(int v: g[u]){
        if(v==p) continue;
        if(vis[v]) low[u]=min(low[u], tin[v]);
        else {
            dfs(v,u,g,tin,low,vis,t,bridges);
            low[u]=min(low[u], low[v]);
            if(low[v] > tin[u]) bridges.emplace_back(u,v);
        }
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<int>> g(n);
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; g[u].push_back(v); g[v].push_back(u); }
    vector<int> tin(n,-1), low(n,-1); vector<char> vis(n,0);
    int timer=0; vector<pair<int,int>> bridges;
    for(int i=0;i<n;++i) if(!vis[i]) dfs(i,-1,g,tin,low,vis,timer,bridges);
    for(auto &e: bridges) cout<<e.first<<" "<<e.second<<"\n";
    return 0;
}

Pruebas
? Grafo con bridge edges detectados listados.

Ejercicio 69: Eulerian Path / Circuit (Hierholzer)
Análisis
 Determinar y encontrar Eulerian path/circuit en grafo dirigido o no dirigido.
Diseño
 Check degree conditions, run Hierholzer.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<pair<int,int>>> g(n);
    vector<int> deg(n,0);
    vector<pair<int,int>> edges(m);
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; edges[i]={u,v}; g[u].push_back({v,i}); g[v].push_back({u,i}); deg[u]++; deg[v]++; }
    // Check Eulerian for undirected: all vertices with deg>0 must be connected & 0 or 2 odd degrees
    int odd=0, start=0;
    for(int i=0;i<n;++i){ if(deg[i]%2) odd++; if(deg[i]>0) start=i; }
    if(start==0 && deg[0]==0 && m==0){ cout<<"EMPTY\n"; return 0; }
    if(!(odd==0 || odd==2)){ cout<<"NO EULER\n"; return 0; }
    vector<char> used(m,0);
    vector<int> st, path;
    st.push_back(start);
    vector<int> idx(n,0);
    while(!st.empty()){
        int v=st.back();
        while(idx[v] < (int)g[v].size() && used[g[v][idx[v]].second]) idx[v]++;
        if(idx[v]==(int)g[v].size()){ path.push_back(v); st.pop_back(); }
        else { auto [to,id]=g[v][idx[v]++]; used[id]=1; st.push_back(to); }
    }
    if((int)path.size() != m+1){ cout<<"NO EULER\n"; return 0; }
    reverse(path.begin(), path.end());
    for(int x: path) cout<<x<<" ";
    cout<<"\n";
    return 0;
}

Pruebas
? Small Eulerian graphs tested.


Ejercicio 70: Word Ladder (transformación de palabras) — BFS en palabras
Análisis
 Encontrar mínimo pasos para transformar begin en end cambiando una letra y usando palabras del diccionario.
Diseño
 BFS: precompute adjacency via wildcard patterns or generate neighbors.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string beginWord, endWord; int n;
    if(!(cin>>beginWord>>endWord>>n)) return 0;
    vector<string> dict(n);
    unordered_set<string> wordSet;
    for(int i=0;i<n;++i){ cin>>dict[i]; wordSet.insert(dict[i]); }
    if(!wordSet.count(endWord)){ cout<<0<<"\n"; return 0; }
    queue<pair<string,int>> q; q.push({beginWord,1});
    unordered_set<string> vis; vis.insert(beginWord);
    while(!q.empty()){
        auto [word,steps] = q.front(); q.pop();
        if(word==endWord){ cout<<steps<<"\n"; return 0; }
        for(int i=0;i<(int)word.size();++i){
            string tmp = word;
            for(char c='a'; c<='z'; ++c){
                tmp[i]=c;
                if(wordSet.count(tmp) && !vis.count(tmp)){ vis.insert(tmp); q.push({tmp,steps+1}); }
            }
        }
    }
    cout<<0<<"\n";
    return 0;
}

Pruebas
? hit -> cog with dict includes hot dot dog lot log cog ? shortest length 5 (hit->hot->dot->dog->cog).
71. Mergesort
Título del Ejercicio: Ordenamiento de un Array usando Mergesort
Análisis del Problema
? Descripción del Problema: Dado un array de números enteros, ordenar sus elementos de menor a mayor usando el algoritmo Mergesort.

? Entradas y Salidas:

? Entrada: Array de tamaño n con números enteros.

? Salida: Array ordenado de menor a mayor.

Diseño de la Solución
? Algoritmo Propuesto:

1. Leer tamaño del array y elementos.

2. Aplicar Mergesort: dividir array en dos mitades, ordenar cada mitad recursivamente, fusionarlas.

3. Mostrar array ordenado.

? Estructuras de Datos: Array simple.

? Funciones Principales: main, mergeSort, merge.

Código Fuente (C++):
#include <iostream>
using namespace std;

void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1, n2 = r - m;
    int L[n1], R[n2];
    for(int i = 0; i < n1; i++) L[i] = arr[l+i];
    for(int j = 0; j < n2; j++) R[j] = arr[m+1+j];

    int i=0, j=0, k=l;
    while(i<n1 && j<n2) {
        if(L[i] <= R[j]) arr[k++] = L[i++];
        else arr[k++] = R[j++];
    }
    while(i<n1) arr[k++] = L[i++];
    while(j<n2) arr[k++] = R[j++];
}

void mergeSort(int arr[], int l, int r) {
    if(l<r) {
        int m = l + (r-l)/2;
        mergeSort(arr,l,m);
        mergeSort(arr,m+1,r);
        merge(arr,l,m,r);
    }
}

int main() {
    int n;
    cout << "Ingrese tamaño del array: ";
    cin >> n;
    int arr[n];
    cout << "Ingrese elementos del array:\n";
    for(int i=0;i<n;i++) cin >> arr[i];

    mergeSort(arr,0,n-1);

    cout << "Array ordenado: ";
    for(int i=0;i<n;i++) cout << arr[i] << " ";
    cout << endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada 5 2 4 1 3 ? Salida: 1 2 3 4 5

? Caso 2: Entrada 10 7 8 9 ? Salida: 7 8 9 10
72. Ordenar un Array de Estructuras usando std::sort
Título del Ejercicio: Ordenar Personas por Edad
Análisis del Problema
? Descripción del Problema: Dado un array de personas con nombre y edad, ordenar de menor a mayor según la edad.

? Entradas y Salidas:

? Entrada: Número de personas, nombres y edades.

? Salida: Lista de personas ordenadas por edad.

Diseño de la Solución
? Algoritmo Propuesto:

1. Leer número de personas y sus datos.

2. Usar std::sort con función lambda para ordenar por edad.

3. Mostrar lista ordenada.

? Estructuras de Datos: struct y std::vector.

? Funciones Principales: main.

Código Fuente (C++):
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Persona {
    string nombre;
    int edad;
};

int main() {
    int n;
    cout << "Ingrese número de personas: ";
    cin >> n;
    vector<Persona> personas(n);
    for(int i=0;i<n;i++) {
        cout << "Nombre: ";
        cin >> personas[i].nombre;
        cout << "Edad: ";
        cin >> personas[i].edad;
    }

    sort(personas.begin(), personas.end(), [](Persona a, Persona b){ return a.edad < b.edad; });

    cout << "Personas ordenadas por edad:\n";
    for(auto p : personas) cout << p.nombre << " - " << p.edad << endl;

    return 0;
}

Pruebas:
? Caso 1: Entrada: Ana 25, Juan 20, Luis 30 ? Salida: Juan 20, Ana 25, Luis 30
73. Ordenar un Vector de Enteros con Lambda
Título del Ejercicio: Orden Descendente de Enteros usando std::sort
Análisis del Problema
? Descripción del Problema: Ordenar un vector de enteros de mayor a menor usando std::sort y lambda.

? Entradas y Salidas:

? Entrada: Vector de enteros.

? Salida: Vector ordenado de mayor a menor.

Diseño de la Solución
? Algoritmo Propuesto:

1. Leer tamaño y elementos del vector.

2. Usar std::sort con lambda (a,b) => a>b.

3. Mostrar vector ordenado.

? Estructuras de Datos: std::vector.

? Funciones Principales: main.

Código Fuente (C++):
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cout << "Ingrese tamaño del vector: ";
    cin >> n;
    vector<int> v(n);
    cout << "Ingrese elementos:\n";
    for(int i=0;i<n;i++) cin >> v[i];

    sort(v.begin(), v.end(), [](int a,int b){ return a>b; });

    cout << "Vector ordenado descendente: ";
    for(int x:v) cout << x << " ";
    cout << endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada 5 1 3 2 ? Salida: 5 3 2 1
74. Buscar Primer Número Mayor que X usando Búsqueda Binaria Modificada
Título del Ejercicio: Primer Número Mayor que X
Análisis del Problema
? Descripción del Problema: Dado un array ordenado, encontrar el primer número mayor que X.

? Entradas y Salidas:

? Entrada: Array ordenado, valor X.

? Salida: Primer número mayor que X o mensaje de no encontrado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Leer array ordenado y X.

2. Aplicar búsqueda binaria modificada para encontrar primer número mayor.

3. Mostrar resultado.

? Estructuras de Datos: Array.

? Funciones Principales: main.

Código Fuente (C++):
#include <iostream>
using namespace std;

int primerMayor(int arr[], int n, int X) {
    int res=-1, inicio=0, fin=n-1;
    while(inicio<=fin) {
        int mid = inicio + (fin-inicio)/2;
        if(arr[mid]>X) {
            res=arr[mid];
            fin=mid-1;
        } else inicio=mid+1;
    }
    return res;
}

int main() {
    int n,X;
    cout << "Ingrese tamaño del array: ";
    cin >> n;
    int arr[n];
    cout << "Ingrese elementos ordenados:\n";
    for(int i=0;i<n;i++) cin >> arr[i];
    cout << "Ingrese X: ";
    cin >> X;

    int res=primerMayor(arr,n,X);
    if(res!=-1) cout << "Primer número mayor que " << X << ": " << res << endl;
    else cout << "No hay número mayor que " << X << endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada [1 3 5 7], X=4 ? Salida: 5

? Caso 2: Entrada [2 4 6 8], X=8 ? Salida: No hay número mayor que 8
75. HeapSort
Título del Ejercicio: Ordenamiento usando HeapSort
Análisis del Problema
? Descripción del Problema: Ordenar un array de enteros usando HeapSort.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Array ordenado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Construir heap máximo.

2. Intercambiar raíz con último elemento.

3. Reducir tamaño del heap y heapify.

4. Mostrar array ordenado.

? Estructuras de Datos: Array.

? Funciones Principales: main, heapify.

Código Fuente (C++):
#include <iostream>
using namespace std;

void heapify(int arr[], int n, int i) {
    int largest=i,l=2*i+1,r=2*i+2;
    if(l<n && arr[l]>arr[largest]) largest=l;
    if(r<n && arr[r]>arr[largest]) largest=r;
    if(largest!=i){
        swap(arr[i],arr[largest]);
        heapify(arr,n,largest);
    }
}

void heapSort(int arr[], int n) {
    for(int i=n/2-1;i>=0;i--) heapify(arr,n,i);
    for(int i=n-1;i>=0;i--){
        swap(arr[0],arr[i]);
        heapify(arr,i,0);
    }
}

int main(){
    int n;
    cout<<"Ingrese tamaño del array: ";
    cin>>n;
    int arr[n];
    cout<<"Ingrese elementos: \n";
    for(int i=0;i<n;i++) cin>>arr[i];

    heapSort(arr,n);

    cout<<"Array ordenado: ";
    for(int i=0;i<n;i++) cout<<arr[i]<<" ";
    cout<<endl;
    return 0;
}

Pruebas:
? Caso 1: [4 10 3 5] ? Salida: 3 4 5 10
76. Ordenar Array de Cadenas usando std::sort
Título del Ejercicio: Ordenar Cadenas Alfabéticamente
Análisis del Problema
? Descripción del Problema: Ordenar un array de cadenas alfabéticamente.

? Entradas y Salidas:

? Entrada: Array de strings.

? Salida: Array ordenado alfabéticamente.

Diseño de la Solución
? Algoritmo Propuesto:

1. Leer número de cadenas y cadenas.

2. Usar std::sort.

3. Mostrar resultado.

? Estructuras de Datos: std::vector<string>.

? Funciones Principales: main.

Código Fuente (C++):
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
    int n;
    cout<<"Ingrese número de cadenas: ";
    cin>>n;
    vector<string> v(n);
    cout<<"Ingrese cadenas:\n";
    for(int i=0;i<n;i++) cin>>v[i];

    sort(v.begin(),v.end());

    cout<<"Cadenas ordenadas:\n";
    for(auto s:v) cout<<s<<endl;

    return 0;
}

Pruebas:
? Caso 1: {"banana","manzana","pera"} ? Salida: banana manzana pera
77. Contar Caminos Distintos de Origen a Destino en un DAG usando DP
Título del Ejercicio: Contar Caminos en un DAG
Análisis del Problema
? Descripción del Problema: Dado un grafo acíclico dirigido (DAG), contar cuántos caminos distintos existen desde un nodo origen a un nodo destino.

? Entradas y Salidas:

? Entrada: Número de nodos n, número de aristas m, lista de aristas, nodo origen y destino.

? Salida: Número total de caminos distintos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear lista de adyacencia para el DAG.

2. Inicializar vector dp con -1 para memoización.

3. Usar función recursiva con memoización: dp[u] = sum(dp[v]) para cada vecino v.

4. Mostrar dp[origen].

? Estructuras de Datos: vector<vector<int>>, vector<int> para DP.

? Funciones Principales: main y función countPaths.

Código Fuente (C++):
#include <iostream>
#include <vector>
using namespace std;

int n,destino;
vector<vector<int>> adj;
vector<int> dp;

int countPaths(int u){
    if(u==destino) return 1;
    if(dp[u]!=-1) return dp[u];
    int total=0;
    for(int v: adj[u]) total += countPaths(v);
    return dp[u]=total;
}

int main(){
    int m,origen;
    cout<<"Ingrese número de nodos y aristas: ";
    cin>>n>>m;
    adj.assign(n,vector<int>());
    dp.assign(n,-1);
    cout<<"Ingrese aristas (u v):\n";
    for(int i=0;i<m;i++){
        int u,v; cin>>u>>v;
        adj[u].push_back(v);
    }
    cout<<"Ingrese nodo origen y destino: ";
    cin>>origen>>destino;

    int total=countPaths(origen);
    cout<<"Número de caminos distintos: "<<total<<endl;
    return 0;
}

Pruebas:
? Caso 1: DAG 0->1,0->2,1->3,2->3, origen=0, destino=3 ? Salida: 2
78. Subset Sum (Suma de Subconjuntos)
Título del Ejercicio: Subset Sum usando DP
Análisis del Problema
? Descripción del Problema: Determinar si existe un subconjunto de un conjunto de enteros que sume un valor S.

? Entradas y Salidas:

? Entrada: Número de elementos n, elementos del conjunto, suma objetivo S.

? Salida: Sí si existe un subconjunto que suma S, No si no.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear tabla dp[n+1][S+1] donde dp[i][j] indica si suma j es posible con primeros i elementos.

2. Inicializar dp[i][0]=true.

3. Llenar tabla según inclusión/exclusión.

4. Mostrar resultado dp[n][S].

? Estructuras de Datos: Array 2D dp.

? Funciones Principales: main.

Código Fuente (C++):
#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n,S;
    cout<<"Ingrese número de elementos y suma objetivo: ";
    cin>>n>>S;
    vector<int> arr(n);
    cout<<"Ingrese elementos:\n";
    for(int i=0;i<n;i++) cin>>arr[i];

    vector<vector<bool>> dp(n+1,vector<bool>(S+1,false));
    for(int i=0;i<=n;i++) dp[i][0]=true;

    for(int i=1;i<=n;i++){
        for(int j=1;j<=S;j++){
            if(arr[i-1]<=j) dp[i][j]=dp[i-1][j] || dp[i-1][j-arr[i-1]];
            else dp[i][j]=dp[i-1][j];
        }
    }

    if(dp[n][S]) cout<<"Sí, existe un subconjunto que suma "<<S<<endl;
    else cout<<"No, no existe un subconjunto que suma "<<S<<endl;

    return 0;
}

Pruebas:
? Caso 1: [3 34 4 12 5 2], S=9 ? Salida: Sí (4+5)
79. Longest Common Subsequence (LCS)
Título del Ejercicio: Secuencia Común Más Larga
Análisis del Problema
? Descripción del Problema: Dadas dos cadenas, encontrar la longitud de su subsecuencia común más larga.

? Entradas y Salidas:

? Entrada: Dos cadenas s1 y s2.

? Salida: Longitud del LCS.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear matriz dp[m+1][n+1].

2. Llenar dp[i][j] usando regla: si s1[i-1]==s2[j-1] entonces dp[i][j]=dp[i-1][j-1]+1, else max(dp[i-1][j],dp[i][j-1]).

3. Mostrar dp[m][n].

? Estructuras de Datos: Array 2D dp.

? Funciones Principales: main.

Código Fuente (C++):
#include <iostream>
#include <vector>
using namespace std;

int main(){
    string s1,s2;
    cout<<"Ingrese dos cadenas: ";
    cin>>s1>>s2;
    int m=s1.size(), n=s2.size();
    vector<vector<int>> dp(m+1,vector<int>(n+1,0));

    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            if(s1[i-1]==s2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
            else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        }
    }

    cout<<"Longitud del LCS: "<<dp[m][n]<<endl;
    return 0;
}

Pruebas:
? Caso 1: "AGGTAB" y "GXTXAYB" ? Salida: 4 (GTAB)
80. Longest Increasing Subsequence (LIS)
Título del Ejercicio: Subsequence Creciente Más Larga
Análisis del Problema
? Descripción del Problema: Dado un array, encontrar la longitud de la subsecuencia creciente más larga.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Longitud de la LIS.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear vector dp con 1 para cada elemento.

2. Para cada elemento, actualizar dp[i]=max(dp[i], dp[j]+1) si arr[i]>arr[j].

3. Mostrar max(dp).

? Estructuras de Datos: vector<int> para dp.

? Funciones Principales: main.

Código Fuente (C++):
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
    int n;
    cout<<"Ingrese tamaño del array: ";
    cin>>n;
    vector<int> arr(n);
    cout<<"Ingrese elementos:\n";
    for(int i=0;i<n;i++) cin>>arr[i];

    vector<int> dp(n,1);
    for(int i=1;i<n;i++){
        for(int j=0;j<i;j++){
            if(arr[i]>arr[j]) dp[i]=max(dp[i],dp[j]+1);
        }
    }

    cout<<"Longitud de la LIS: "<<*max_element(dp.begin(),dp.end())<<endl;
    return 0;
}

Pruebas:
? Caso 1: [10,22,9,33,21,50,41,60] ? Salida: 5 (10,22,33,50,60)

81. Floyd-Warshall para Todas las Distancias Mínimas
Título del Ejercicio: Distancias Mínimas con Floyd-Warshall
Análisis del Problema
? Descripción del Problema: Dado un grafo ponderado, encontrar todas las distancias mínimas entre cada par de nodos.

? Entradas y Salidas:

? Entrada: Número de nodos n, matriz de adyacencia con pesos.

? Salida: Matriz de distancias mínimas.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar matriz dist con pesos.

2. Aplicar Floyd-Warshall: dist[i][j]=min(dist[i][j], dist[i][k]+dist[k][j]).

3. Mostrar matriz final.

? Estructuras de Datos: Array 2D dist.

? Funciones Principales: main.

Código Fuente (C++):
#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n;
    cout<<"Ingrese número de nodos: ";
    cin>>n;
    vector<vector<int>> dist(n,vector<int>(n));
    cout<<"Ingrese matriz de adyacencia (-1 si no hay arista):\n";
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++){
            cin>>dist[i][j];
            if(dist[i][j]==-1) dist[i][j]=1e9;
        }

    for(int k=0;k<n;k++)
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);

    cout<<"Matriz de distancias mínimas:\n";
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            if(dist[i][j]>=1e9) cout<<"INF ";
            else cout<<dist[i][j]<<" ";
        }
        cout<<endl;
    }

    return 0;
}

Pruebas:
? Caso 1: Grafo 3x3 con pesos [0 1 4],[1 0 2],[4 2 0] ? Matriz final: [0 1 3],[1 0 2],[3 2 0]
82. Dijkstra para Camino Más Corto desde Nodo Origen
Título del Ejercicio: Camino Más Corto con Dijkstra
Análisis del Problema
? Descripción del Problema: Encontrar la distancia mínima desde un nodo origen a todos los demás en grafo ponderado.

? Entradas y Salidas:

? Entrada: Número de nodos, aristas, lista de aristas con peso, nodo origen.

? Salida: Distancia mínima desde origen a cada nodo.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar distancias con infinito.

2. Usar priority_queue para nodos pendientes.

3. Relajar aristas y actualizar distancias.

4. Mostrar distancias.

? Estructuras de Datos: vector<vector<pair<int,int>>>, priority_queue.

? Funciones Principales: main.

Código Fuente (C++):
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main(){
    int n,m;
    cout<<"Ingrese número de nodos y aristas: ";
    cin>>n>>m;
    vector<vector<pair<int,int>>> adj(n);
    cout<<"Ingrese aristas (u v peso):\n";
    for(int i=0;i<m;i++){
        int u,v,w; cin>>u>>v>>w;
        adj[u].push_back({v,w});
    }
    int origen; cout<<"Ingrese nodo origen: "; cin>>origen;

    vector<int> dist(n,1e9); dist[origen]=0;
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    pq.push({0,origen});

    while(!pq.empty()){
        auto [d,u]=pq.top(); pq.pop();
        if(d>dist[u]) continue;
        for(auto [v,w]: adj[u]){
            if(dist[u]+w<dist[v]){
                dist[v]=dist[u]+w;
                pq.push({dist[v],v});
            }
        }
    }

    cout<<"Distancias mínimas desde nodo "<<origen<<":\n";
    for(int i=0;i<n;i++) cout<<i<<": "<<dist[i]<<endl;

    return 0;
}

Pruebas:
? Caso 1: Grafo 0->1(4),0->2(1),2->1(2) ? Salida: 0:0,1:3,2:1

83. Coin Change (Número de Formas de Hacer Cambio)
Título del Ejercicio: Problema de Monedas
Análisis del Problema
? Descripción del Problema: Dado un conjunto de monedas y un valor S, contar el número de formas de obtener S.

? Entradas y Salidas:

? Entrada: Número de tipos de monedas n, valor de cada moneda, suma objetivo S.

? Salida: Número de formas de obtener S.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear vector dp[S+1] inicializado en 0, dp[0]=1.

2. Para cada moneda c, actualizar dp[j]+=dp[j-c] para j>=c.

3. Mostrar dp[S].

? Estructuras de Datos: vector<int> dp.

? Funciones Principales: main.

Código Fuente (C++):
#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n,S;
    cout<<"Ingrese número de monedas y suma objetivo: ";
    cin>>n>>S;
    vector<int> monedas(n);
    cout<<"Ingrese valores de monedas:\n";
    for(int i=0;i<n;i++) cin>>monedas[i];

    vector<int> dp(S+1,0); dp[0]=1;
    for(int c: monedas)
        for(int j=c;j<=S;j++) dp[j]+=dp[j-c];

    cout<<"Número de formas de obtener "<<S<<": "<<dp[S]<<endl;
    return 0;
}

Pruebas:
? Caso 1: Monedas [1,2,5], S=5 ? Salida: 4
84. Usar std::set para mantener números únicos y ordenados
Título del Ejercicio: Números Únicos con std::set
Análisis del Problema
? Descripción del Problema: Insertar números en un std::set para mantenerlos únicos y ordenados automáticamente.

? Entradas y Salidas:

? Entrada: Número de elementos y los números.

? Salida: Números únicos ordenados.

Diseño de la Solución
? Algoritmo Propuesto:

1. Leer tamaño n y los números.

2. Insertar en std::set.

3. Mostrar contenido del set.

? Estructuras de Datos: std::set.

? Funciones Principales: main.

Código Fuente (C++):
#include <iostream>
#include <set>
using namespace std;

int main(){
    int n; cout<<"Ingrese número de elementos: "; cin>>n;
    set<int> s;
    cout<<"Ingrese elementos:\n";
    for(int i=0;i<n;i++){
        int x; cin>>x;
        s.insert(x);
    }

    cout<<"Números únicos y ordenados: ";
    for(int x:s) cout<<x<<" ";
    cout<<endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada [5 3 5 2] ? Salida: 2 3 5

85. Insertar y eliminar elementos de std::set
Título del Ejercicio: Insertar y Eliminar en Set
Análisis del Problema
? Descripción del Problema: Insertar y eliminar elementos de un std::set y mostrar resultados.

? Entradas y Salidas:

? Entrada: Lista de elementos a insertar, lista de elementos a eliminar.

? Salida: Set final ordenado.

Código Fuente (C++):
#include <iostream>
#include <set>
using namespace std;

int main(){
    set<int> s;
    int n,m;
    cout<<"Número de elementos a insertar: "; cin>>n;
    cout<<"Ingrese elementos:\n";
    for(int i=0;i<n;i++){ int x; cin>>x; s.insert(x);}
    
    cout<<"Número de elementos a eliminar: "; cin>>m;
    cout<<"Ingrese elementos a eliminar:\n";
    for(int i=0;i<m;i++){ int x; cin>>x; s.erase(x);}
    
    cout<<"Set final: ";
    for(int x:s) cout<<x<<" ";
    cout<<endl;
    return 0;
}

Pruebas:
? Caso 1: Insertar [1 2 3], eliminar [2] ? Salida: 1 3

86. Ordenar objetos complejos en std::vector
Título del Ejercicio: Ordenar Estudiantes por Nota
Código Fuente (C++):
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Estudiante{
    string nombre;
    int nota;
};

int main(){
    int n; cin>>n;
    vector<Estudiante> v(n);
    for(int i=0;i<n;i++) cin>>v[i].nombre>>v[i].nota;

    sort(v.begin(),v.end(),[](Estudiante a,Estudiante b){ return a.nota>b.nota; });

    for(auto e:v) cout<<e.nombre<<" "<<e.nota<<endl;
    return 0;
}

Pruebas:
? Caso 1: [Ana 90, Juan 85] ? Salida: Ana 90, Juan 85
87. Contar elementos duplicados usando std::multiset
Título del Ejercicio: Contar Duplicados con multiset
Código Fuente (C++):
#include <iostream>
#include <set>
using namespace std;

int main(){
    int n; cin>>n;
    multiset<int> ms;
    for(int i=0;i<n;i++){ int x; cin>>x; ms.insert(x);}

    cout<<"Elementos y cantidad:\n";
    for(int x:ms) cout<<x<<" ";
    cout<<endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada [1 2 2 3] ? Salida: 1 2 2 3
88. Cola de Prioridad con std::priority_queue
Título del Ejercicio: Priority Queue
Código Fuente (C++):
#include <iostream>
#include <queue>
using namespace std;

int main(){
    priority_queue<int> pq;
    int n; cin>>n;
    for(int i=0;i<n;i++){ int x; cin>>x; pq.push(x);}

    cout<<"Elementos en orden de prioridad: ";
    while(!pq.empty()){ cout<<pq.top()<<" "; pq.pop();}
    cout<<endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada [3 1 5] ? Salida: 5 3 1

89. Contar palabras más frecuentes con std::unordered_map
Título del Ejercicio: Frecuencia de Palabras
Código Fuente (C++):
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

int main(){
    int n; cin>>n;
    unordered_map<string,int> freq;
    for(int i=0;i<n;i++){ string s; cin>>s; freq[s]++;}

    for(auto p:freq) cout<<p.first<<": "<<p.second<<endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada hola mundo hola ? Salida: hola:2 mundo:1

90. Mantener top k números más grandes con priority_queue
Título del Ejercicio: Top k Números
Código Fuente (C++):
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int main(){
    int n,k; cin>>n>>k;
    priority_queue<int,vector<int>,greater<int>> pq;
    for(int i=0;i<n;i++){
        int x; cin>>x;
        pq.push(x);
        if(pq.size()>k) pq.pop();
    }

    vector<int> res;
    while(!pq.empty()){ res.push_back(pq.top()); pq.pop();}
    for(int x:res) cout<<x<<" ";
    cout<<endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada [3 1 5 2], k=2 ? Salida: 3 5

91. Ordenar vector de pares por segundo valor
Título del Ejercicio: Ordenar Pares
Código Fuente (C++):
Ordenar vector de pares por segundo valor

Pruebas:
? Caso 1: Entrada (1,3),(2,1) ? Salida: (2,1),(1,3)

92. Implementar pila con std::stack
Título del Ejercicio: Operaciones de Pila
Código Fuente (C++):
Ordenar vector de pares por segundo valor


Pruebas:
? Caso 1: Entrada [1 2 3] ? Salida: 3 2 1
93. Implementar cola con std::queue
Título del Ejercicio: Operaciones de Cola
Código Fuente (C++):
#include <iostream>
#include <queue>
using namespace std;

int main(){
    queue<int> q;
    int n; cin>>n;
    for(int i=0;i<n;i++){ int x; cin>>x; q.push(x);}

    cout<<"Sacando elementos de la cola: ";
    while(!q.empty()){ cout<<q.front()<<" "; q.pop();}
    cout<<endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada [1 2 3] ? Salida: 1 2 3
94. Ordenar un vector de enteros usando std::reverse después de std::sort
Título del Ejercicio: Orden Descendente con sort + reverse
Análisis del Problema
? Descripción del Problema: Ordenar un vector de enteros de mayor a menor utilizando std::sort y luego invertir con std::reverse.

? Entradas y Salidas:

? Entrada: Vector de enteros.

? Salida: Vector ordenado descendente.

Código Fuente (C++):
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
    int n; cin >> n;
    vector<int> v(n);
    for(int i=0;i<n;i++) cin>>v[i];

    sort(v.begin(),v.end());
    reverse(v.begin(),v.end());

    cout<<"Vector ordenado descendente: ";
    for(int x:v) cout<<x<<" ";
    cout<<endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada [4 1 3 2] ? Salida: 4 3 2 1

95. Ordenar estructuras por nombre usando std::sort
Título del Ejercicio: Ordenar Personas por Nombre
Código Fuente (C++):
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Persona{
    string nombre;
    int edad;
};

int main(){
    int n; cin>>n;
    vector<Persona> personas(n);
    for(int i=0;i<n;i++) cin>>personas[i].nombre>>personas[i].edad;

    sort(personas.begin(),personas.end(),[](Persona a,Persona b){ return a.nombre<b.nombre; });

    cout<<"Personas ordenadas por nombre:\n";
    for(auto p:personas) cout<<p.nombre<<" "<<p.edad<<endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada Juan 25, Ana 20 ? Salida: Ana 20, Juan 25
96. Contar frecuencia de números usando std::map
Título del Ejercicio: Frecuencia de Números
Código Fuente (C++):
#include <iostream>
#include <map>
using namespace std;

int main(){
    int n; cin>>n;
    map<int,int> freq;
    for(int i=0;i<n;i++){
        int x; cin>>x;
        freq[x]++;
    }

    cout<<"Frecuencia de números:\n";
    for(auto p:freq) cout<<p.first<<": "<<p.second<<endl;
    return 0;
}

Pruebas:
? Caso 1: Entrada [1 2 2 3] ? Salida: 1:1 2:2 3:1
97. Create Contar palabras más frecuentes con std::unordered_map
Título del Ejercicio: Elementos Comunes
Código Fuente (C++):
#include <iostream>
#include <set>
#include <vector>
using namespace std;

int main(){
    int n,m; cin>>n>>m;
    vector<int> v1(n),v2(m);
    for(int i=0;i<n;i++) cin>>v1[i];
    for(int i=0;i<m;i++) cin>>v2[i];

    set<int> s1(v1.begin(),v1.end()), s2(v2.begin(),v2.end()), inter;
    for(int x:s1) if(s2.count(x)) inter.insert(x);

    cout<<"Elementos comunes: ";
    for(int x:inter) cout<<x<<" ";
    cout<<endl;
    return 0;
}

Pruebas:
? Caso 1: v1=[1 2 3], v2=[2 3 4] ? Salida: 2 3
98. Contar elementos mayores a X usando std::count_if
Título del Ejercicio: Contar con Condición
Código Fuente (C++):
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
    int n,X; cin>>n>>X;
    vector<int> v(n);
    for(int i=0;i<n;i++) cin>>v[i];

    int cnt = count_if(v.begin(),v.end(),[X](int a){ return a>X; });
    cout<<"Cantidad de elementos mayores que "<<X<<": "<<cnt<<endl;
    return 0;
}

Pruebas:
? Caso 1: [1 3 5 7], X=4 ? Salida: 2
99. Reemplazar valores en vector usando std::replace
Título del Ejercicio: Reemplazar Elementos
Código Fuente (C++):
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
    int n,oldVal,newVal; cin>>n>>oldVal>>newVal;
    vector<int> v(n);
    for(int i=0;i<n;i++) cin>>v[i];

    replace(v.begin(),v.end(),oldVal,newVal);

    cout<<"Vector después de reemplazo: ";
    for(int x:v) cout<<x<<" ";
    cout<<endl;
    return 0;
}

Pruebas:
? Caso 1: [1 2 3 2], old=2, new=5 ? Salida: 1 5 3 5
100. Eliminar elementos menores que X usando std::remove_if
Título del Ejercicio: Eliminar Condicional
Código Fuente (C++):
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(){
    int n,X; cin>>n>>X;
    vector<int> v(n);
    for(int i=0;i<n;i++) cin>>v[i];

    v.erase(remove_if(v.begin(),v.end(),[X](int a){ return a<X; }), v.end());

    cout<<"Vector después de eliminar elementos menores que "<<X<<": ";
    for(int x:v) cout<<x<<" ";
    cout<<endl;
    return 0;
}

Pruebas:
? Caso 1: [1 5 3 7], X=4 ? Salida: 5 7
 
1.- Enunciado: Leer dos enteros e imprimir su suma.

Leer dos enteros e imprimir su suma.

2.- sumas de números enteros 
int main() {
    int a, b;
    cout << "Ingresa dos enteros: ";
    cin >> a >> b;
    cout << "Suma: " << (a + b) << endl;
    return 0;
}


3.-Resta de dos números
Enunciado: Leer dos enteros e imprimir su diferencia (a - b).

#include <iostream>
using namespace std;

int main() {
    int a, b;
    cout << "Ingresa a y b: ";
    cin >> a >> b;
    cout << "Diferencia a-b: " << (a - b) << endl;
    return 0;
}


4.-Multiplicación de dos números
Enunciado: Leer dos enteros y mostrar el producto.

#include <iostream>
using namespace std;

int main() {
    int x, y;
    cout << "Ingresa dos enteros: ";
    cin >> x >> y;
    cout << "Producto: " << (x * y) << endl;
    return 0;
}


5.-División entera
Enunciado: Leer dos enteros y mostrar división entera (si b ? 0).

#include <iostream>
using namespace std;

int main() {
    int a, b;
    cout << "Ingresa a y b (b != 0): ";
    cin >> a >> b;
    if (b == 0) cout << "Error: division por cero\n";
    else cout << "a/b = " << (a / b) << " (división entera)\n";
    return 0;
}


6.-Promedio de tres números
Enunciado: Leer tres números (pueden ser reales) y calcular su promedio.

Promedio de tres números



7.-Número par o impar
Enunciado: Leer un entero y decir si es par o impar.

#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Ingresa un entero: ";
    cin >> n;
    if (n % 2 == 0) cout << n << " es par\n";
    else cout << n << " es impar\n";
    return 0;
}


8.-Valor absoluto
Enunciado: Leer un número entero y mostrar su valor absoluto.

#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Ingresa un entero: ";
    cin >> n;
    if (n < 0) n = -n;
    cout << "Valor absoluto: " << n << endl;
    return 0;
}


9.-Mayor de dos números
Enunciado: Leer dos números y mostrar el mayor.

#include <iostream>
using namespace std;

int main() {
    double a, b;
    cout << "Ingresa dos números: ";
    cin >> a >> b;
    if (a > b) cout << "Mayor: " << a << endl;
    else cout << "Mayor: " << b << endl;
    return 0;
}


10.-Ordenar dos números
Enunciado: Leer dos números y mostrarlos en orden ascendente.

#include <iostream>
using namespace std;

int main() {
    int a, b;
    cout << "Ingresa dos enteros: ";
    cin >> a >> b;
    if (a <= b) cout << a << " " << b << endl;
    else cout << b << " " << a << endl;
    return 0;
}


11.-Intercambio (swap)
Enunciado: Leer dos variables y mostrarlas intercambiadas.

#include <iostream>
using namespace std;

int main() {
    int a, b, temp;
    cout << "Ingresa a y b: ";
    cin >> a >> b;
    temp = a;
    a = b;
    b = temp;
    cout << "Tras swap: a=" << a << " b=" << b << endl;
    return 0;
}


12.-Suma de los primeros N naturales
Enunciado: Leer N y calcular la suma 1+2+...+N usando un for.

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "Ingresa N: ";
    cin >> N;
    int suma = 0;
    for (int i = 1; i <= N; ++i) suma += i;
    cout << "Suma: " << suma << endl;
    return 0;
}


13.-Factorial (iterativo)
Enunciado: Leer N (N >= 0) y calcular N! de forma iterativa.

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "Ingresa N (>=0): ";
    cin >> N;
    long long fact = 1;
    for (int i = 2; i <= N; ++i) fact *= i;
    cout << N << "! = " << fact << endl;
    return 0;
}


14.-Contar dígitos
Enunciado: Leer un entero positivo y contar cuántos dígitos tiene.

#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Ingresa un entero positivo: ";
    cin >> n;
    if (n == 0) { cout << "Dígitos: 1\n"; return 0; }
    int cnt = 0;
    while (n != 0) { n /= 10; ++cnt; }
    cout << "Dígitos: " << cnt << endl;
    return 0;
}


15.-Suma de dígitos
Enunciado: Leer un entero positivo y mostrar la suma de sus dígitos.

#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Ingresa un entero positivo: ";
    cin >> n;
    int suma = 0;
    while (n != 0) {
        suma += n % 10;
        n /= 10;
    }
    cout << "Suma de dígitos: " << suma << endl;
    return 0;
}


16.-Invertir número
Enunciado: Leer un entero y mostrar su reverso (ej. 123 -> 321).

#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Ingresa un entero: ";
    cin >> n;
    int sign = (n < 0) ? -1 : 1;
    if (n < 0) n = -n;
    int rev = 0;
    while (n != 0) {
        rev = rev * 10 + (n % 10);
        n /= 10;
    }
    cout << "Invertido: " << (sign * rev) << endl;
    return 0;
}


17.-Número primo (chequeo simple)
Enunciado: Leer N y verificar si es primo (algoritmo simple).

#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Ingresa N: ";
    cin >> n;
    if (n <= 1) { cout << "No primo\n"; return 0; }
    bool primo = true;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) { primo = false; break; }
    }
    cout << (primo ? "Primo\n" : "No primo\n");
    return 0;
}


18.-Listar primos hasta N
Enunciado: Leer N y listar los números primos ? N (método simple).

#include <iostream>
using namespace std;

bool esPrimo(int x) {
    if (x <= 1) return false;
    for (int i = 2; i * i <= x; ++i)
        if (x % i == 0) return false;
    return true;
}

int main() {
    int N;
    cout << "Ingresa N: ";
    cin >> N;
    for (int i = 2; i <= N; ++i)
        if (esPrimo(i)) cout << i << " ";
    cout << endl;
    return 0;
}


19.-Máximo entre tres números
Enunciado: Leer tres números y mostrar el mayor.

#include <iostream>
using namespace std;

int main() {
    double a, b, c;
    cout << "Ingresa 3 números: ";
    cin >> a >> b >> c;
    double m = a;
    if (b > m) m = b;
    if (c > m) m = c;
    cout << "Mayor: " << m << endl;
    return 0;
}


20.-Mínimo entre tres números
Enunciado: Leer tres números y mostrar el menor.

#include <iostream>
using namespace std;

int main() {
    double a, b, c;
    cout << "Ingresa 3 números: ";
    cin >> a >> b >> c;
    double m = a;
    if (b < m) m = b;
    if (c < m) m = c;
    cout << "Menor: " << m << endl;
    return 0;
}


21.-Tabla de multiplicar
Enunciado: Leer N y mostrar la tabla de multiplicar del 1 al 10 de N.

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "Ingresa N: ";
    cin >> N;
    for (int i = 1; i <= 10; ++i)
        cout << N << " x " << i << " = " << (N * i) << endl;
    return 0;
}


22.-Suma pares hasta N
Enunciado: Leer N y calcular la suma de todos los números pares ? N.

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "Ingresa N: ";
    cin >> N;
    int suma = 0;
    for (int i = 2; i <= N; i += 2) suma += i;
    cout << "Suma pares: " << suma << endl;
    return 0;
}


23.-Contar pares e impares
Enunciado: Leer N números (pedir cuántos) y contar cuántos son pares y cuántos impares.

#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "¿Cuántos números?: ";
    cin >> n;
    int pares = 0, impares = 0, x;
    for (int i = 0; i < n; ++i) {
        cin >> x;
        if (x % 2 == 0) ++pares;
        else ++impares;
    }
    cout << "Pares: " << pares << " Impares: " << impares << endl;
    return 0;
}


24.- MCD (algoritmo de Euclides)
Enunciado: Leer dos enteros y calcular su máximo común divisor (MCD).

#include <iostream>
using namespace std;

int main() {
    int a, b;
    cout << "Ingresa a y b: ";
    cin >> a >> b;
    while (b != 0) {
        int r = a % b;
        a = b;
        b = r;
    }
    cout << "MCD: " << (a < 0 ? -a : a) << endl;
    return 0;
}


25.-MCM (mínimo común múltiplo)
Enunciado: Leer dos enteros y calcular su MCM usando MCD.

#include <iostream>
using namespace std;

int mcd(int a, int b) {
    a = (a < 0) ? -a : a;
    b = (b < 0) ? -b : b;
    while (b != 0) {
        int r = a % b;
        a = b;
        b = r;
    }
    return a;
}

int main() {
    int a, b;
    cout << "Ingresa a y b: ";
    cin >> a >> b;
    if (a == 0 || b == 0) { cout << "MCM indefinido (0)\n"; return 0; }
    long long l = (long long) (a / mcd(a,b)) * b;
    if (l < 0) l = -l;
    cout << "MCM: " << l << endl;
    return 0;
}


26.-Tabla de N×M
Enunciado: Mostrar una tabla de multiplicar de tamaño N filas por M columnas (valores 1..N y 1..M).

#include <iostream>
using namespace std;

int main() {
    int N, M;
    cout << "Ingresa N y M: ";
    cin >> N >> M;
    for (int i = 1; i <= N; ++i) {
        for (int j = 1; j <= M; ++j)
            cout << (i * j) << "\t";
        cout << endl;
    }
    return 0;
}


27.-Número perfecto
Enunciado: Leer N y verificar si es número perfecto (la suma de sus divisores propios = N).

#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Ingresa N: ";
    cin >> n;
    int suma = 0;
    for (int i = 1; i <= n/2; ++i) if (n % i == 0) suma += i;
    if (suma == n) cout << n << " es perfecto\n";
    else cout << n << " no es perfecto\n";
    return 0;
}


28.-Fibonacci (n-ésimo, iterativo)
Enunciado: Leer N y mostrar el N-ésimo número de Fibonacci (0,1,1,2,...).

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "Ingresa N (>=0): ";
    cin >> N;
    if (N == 0) { cout << "0\n"; return 0; }
    long long a = 0, b = 1;
    for (int i = 2; i <= N; ++i) {
        long long c = a + b;
        a = b;
        b = c;
    }
    cout << (N==1 ? 1 : b) << endl;
    return 0;
}


29.-Sumar matrices 2x2
Enunciado: Leer dos matrices 2×2 y mostrar su suma (elemento a elemento).

#include <iostream>
using namespace std;

int main() {
    int A[2][2], B[2][2];
    cout << "Ingresa 4 elementos de A (2x2): ";
    for (int i=0;i<2;i++) for (int j=0;j<2;j++) cin >> A[i][j];
    cout << "Ingresa 4 elementos de B (2x2): ";
    for (int i=0;i<2;i++) for (int j=0;j<2;j++) cin >> B[i][j];
    cout << "Suma A+B:\n";
    for (int i=0;i<2;i++) {
        for (int j=0;j<2;j++) cout << (A[i][j]+B[i][j]) << "\t";
        cout << endl;
    }
    return 0;
}


30.-Contar vocales en una palabra
Enunciado: Leer una palabra (sin espacios) y contar cuántas vocales tiene (a,e,i,o,u).

#include <iostream>
#include <string>
using namespace std;

int main() {
    string s;
    cout << "Ingresa una palabra: ";
    cin >> s;
    int cnt = 0;
    for (char c : s) {
        char ch = tolower(c);
        if (ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u') ++cnt;
    }
    cout << "Vocales: " << cnt << endl;
    return 0;
}


31.-Contar caracteres de una cadena
Enunciado: Leer una línea (usa getline) y mostrar su longitud.

#include <iostream>
#include <string>
using namespace std;

int main() {
    string linea;
    cout << "Ingresa una línea: ";
    getline(cin, linea);
    cout << "Longitud: " << linea.length() << endl;
    return 0;
}


32.-Buscar carácter en cadena
Enunciado: Leer una cadena y un carácter; decir si el carácter aparece y cuántas veces.

#include <iostream>
#include <string>
using namespace std;

int main() {
    string s;
    char c;
    cout << "Ingresa cadena: ";
    getline(cin, s);
    cout << "Ingresa un carácter: ";
    cin >> c;
    int cnt = 0;
    for (char ch : s) if (ch == c) ++cnt;
    cout << "Aparece " << cnt << " veces\n";
    return 0;
}


33.-Reemplazar carácter en cadena
Enunciado: Leer una cadena y reemplazar todas las ocurrencias de a por b (caracteres indicados por el usuario).

#include <iostream>
#include <string>
using namespace std;

int main() {
    string s;
    char a, b;
    cout << "Ingresa cadena: ";
    getline(cin, s);
    cout << "Reemplazar qué caracter? ";
    cin >> a;
    cout << "Por qué caracter? ";
    cin >> b;
    for (int i=0;i<(int)s.size();++i) if (s[i]==a) s[i]=b;
    cout << "Resultado: " << s << endl;
    return 0;
}


34.-Eliminar espacios en una cadena
Enunciado: Leer una línea y mostrarla sin espacios.

#include <iostream>
#include <string>
using namespace std;

int main() {
    string s;
    cout << "Ingresa línea: ";
    getline(cin, s);
    string out;
    for (char c : s) if (c != ' ') out.push_back(c);
    cout << "Sin espacios: " << out << endl;
    return 0;
}


35.-Palíndromo (cadena)
Enunciado: Leer una cadena (sin espacios) y verificar si es palíndromo.

#include <iostream>
#include <string>
using namespace std;

int main() {
    string s;
    cout << "Ingresa cadena: ";
    cin >> s;
    bool pal = true;
    for (int i=0, j=s.size()-1; i<j; ++i, --j) if (s[i]!=s[j]) { pal=false; break; }
    cout << (pal ? "Es palíndromo\n" : "No es palíndromo\n");
    return 0;
}


36.-Número de palabras en una línea
Enunciado: Leer una línea y contar cuántas palabras (separadas por espacios).

#include <iostream>
#include <string>
#include <sstream>
using namespace std;

int main() {
    string linea;
    cout << "Ingresa una línea: ";
    getline(cin, linea);
    istringstream iss(linea);
    string word;
    int cnt = 0;
    while (iss >> word) ++cnt;
    cout << "Palabras: " << cnt << endl;
    return 0;
}


37.-Buscar mayor en arreglo
Enunciado: Leer N y luego N enteros; mostrar el mayor y su posición (primera).

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "Cuántos elementos?: ";
    cin >> N;
    int maxVal, pos=0, x;
    if (N <= 0) { cout << "N inválido\n"; return 0; }
    for (int i=1;i<=N;++i){
        cin >> x;
        if (i==1 || x > maxVal) { maxVal = x; pos = i; }
    }
    cout << "Mayor: " << maxVal << " en posición " << pos << endl;
    return 0;
}


38.-Buscar menor en arreglo
Enunciado: Leer N y N números; mostrar el menor y su posición.

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "Cuántos elementos?: ";
    cin >> N;
    int minVal, pos=0, x;
    if (N <= 0) { cout << "N inválido\n"; return 0; }
    for (int i=1;i<=N;++i){
        cin >> x;
        if (i==1 || x < minVal) { minVal = x; pos = i; }
    }
    cout << "Menor: " << minVal << " en posición " << pos << endl;
    return 0;
}


39.-Promedio de un arreglo
Enunciado: Leer N y N números; mostrar su promedio.

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "Cuántos?: ";
    cin >> N;
    double suma = 0, x;
    for (int i=0;i<N;++i){ cin >> x; suma += x; }
    cout << "Promedio: " << (N>0 ? suma / N : 0) << endl;
    return 0;
}


40.-Invertir arreglo
Enunciado: Leer N y N números; mostrarlos en orden inverso.

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "N: ";
    cin >> N;
    int a[1000];
    for (int i=0;i<N;++i) cin >> a[i];
    for (int i=N-1;i>=0;--i) cout << a[i] << " ";
    cout << endl;
    return 0;
}


41.-Suma de dos vectores
Enunciado: Leer N y dos vectores de longitud N; mostrar vector suma.

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "N: ";
    cin >> N;
    int A[1000], B[1000];
    for (int i=0;i<N;++i) cin >> A[i];
    for (int i=0;i<N;++i) cin >> B[i];
    for (int i=0;i<N;++i) cout << (A[i]+B[i]) << " ";
    cout << endl;
    return 0;
}


42.-Eliminar duplicados en arreglo (mostrar únicos)
Enunciado: Leer N y N enteros; imprimir los elementos únicos en orden de aparición.

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "N: ";
    cin >> N;
    int a[1000];
    for (int i=0;i<N;++i) cin >> a[i];
    for (int i=0;i<N;++i) {
        bool seen = false;
        for (int j=0;j<i;++j) if (a[j]==a[i]) { seen = true; break; }
        if (!seen) cout << a[i] << " ";
    }
    cout << endl;
    return 0;
}


43.-Suma condicional (positivos)
Enunciado: Leer N números y sumar solo los positivos.

#include <iostream>
using namespace std;

int main() {
    int N;
    cout << "N: ";
    cin >> N;
    int suma = 0, x;
    for (int i=0;i<N;++i){ cin >> x; if (x > 0) suma += x; }
    cout << "Suma positivos: " << suma << endl;
    return 0;
}


44.-Cuenta vocales y consonantes
Enunciado: Leer una palabra y contar cuántas vocales y consonantes tiene (solo letras).

#include <iostream>
#include <string>
using namespace std;

int main() {
    string s;
    cout << "Palabra: ";
    cin >> s;
    int v=0, c=0;
    for (char ch : s) {
        char l = tolower(ch);
        if (l>='a' && l<='z') {
            if (l=='a'||l=='e'||l=='i'||l=='o'||l=='u') ++v;
            else ++c;
        }
    }
    cout << "Vocales: " << v << " Consonantes: " << c << endl;
    return 0;
}


45.-Número Armstrong (número narcisista)
Enunciado: Leer un entero de 3 dígitos y verificar si es Armstrong (ej.: 153 = 1^3+5^3+3^3).

#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Ingresa un entero (3 dígitos): ";
    cin >> n;
    int original = n, suma = 0;
    while (n) {
        int d = n % 10;
        suma += d*d*d;
        n /= 10;
    }
    cout << (suma == original ? "Es Armstrong\n" : "No es Armstrong\n");
    return 0;
}


46.-Contar números positivos, negativos y ceros
Enunciado: Leer N y N números; contar cuántos son positivos, negativos y ceros.

#include <iostream>
using namespace std;

int main() {
    int N; cout << "N: "; cin >> N;
    int pos=0, neg=0, cero=0, x;
    for (int i=0;i<N;++i) {
        cin >> x;
        if (x>0) ++pos;
        else if (x<0) ++neg;
        else ++cero;
    }
    cout << "Pos: " << pos << " Neg: " << neg << " Ceros: " << cero << endl;
    return 0;
}


47.-Suma de diagonales de matriz cuadrada
Enunciado: Leer una matriz NxN y mostrar la suma de la diagonal principal.

#include <iostream>
using namespace std;

int main() {
    int N; cout << "N: "; cin >> N;
    int a[100][100];
    for (int i=0;i<N;++i) for (int j=0;j<N;++j) cin >> a[i][j];
    int suma = 0;
    for (int i=0;i<N;++i) suma += a[i][i];
    cout << "Suma diagonal principal: " << suma << endl;
    return 0;
}


48.-Suma diagonal secundaria
Enunciado: Leer una matriz NxN y mostrar la suma de la diagonal secundaria.

#include <iostream>
using namespace std;

int main() {
    int N; cout << "N: "; cin >> N;
    int a[100][100];
    for (int i=0;i<N;++i) for (int j=0;j<N;++j) cin >> a[i][j];
    int suma = 0;
    for (int i=0;i<N;++i) suma += a[i][N-1-i];
    cout << "Suma diagonal secundaria: " << suma << endl;
    return 0;
}


49.-Matriz identidad
Enunciado: Dado N, imprimir la matriz identidad NxN (1s en diagonal principal).

#include <iostream>
using namespace std;

int main() {
    int N; cout << "N: "; cin >> N;
    for (int i=0;i<N;++i) {
        for (int j=0;j<N;++j) cout << (i==j ? 1 : 0) << " ";
        cout << endl;
    }
    return 0;
}


50.-Sumar filas de matriz
Enunciado: Leer NxM y mostrar la suma de cada fila.

#include <iostream>
using namespace std;

int main() {
    int N, M; cout << "N M: "; cin >> N >> M;
    int x;
    for (int i=0;i<N;++i) {
        int suma=0;
        for (int j=0;j<M;++j){ cin >> x; suma += x; }
        cout << "Suma fila " << i+1 << ": " << suma << endl;
    }
    return 0;
}


51.-Producto punto de dos vectores
Enunciado: Leer N y dos vectores de tamaño N; calcular su producto punto.

#include <iostream>
using namespace std;

int main() {
    int N; cout << "N: "; cin >> N;
    int a[1000], b[1000];
    for (int i=0;i<N;++i) cin >> a[i];
    for (int i=0;i<N;++i) cin >> b[i];
    long long prod = 0;
    for (int i=0;i<N;++i) prod += (long long)a[i]*b[i];
    cout << "Producto punto: " << prod << endl;
    return 0;
}


52.-Número perfecto menor que N (listar)
Enunciado: Leer N y listar todos los números perfectos <= N.

#include <iostream>
using namespace std;

bool esPerfecto(int n) {
    int suma = 0;
    for (int i=1;i<=n/2;++i) if (n%i==0) suma += i;
    return suma == n;
}

int main() {
    int N; cout << "N: "; cin >> N;
    for (int i=1;i<=N;++i) if (esPerfecto(i)) cout << i << " ";
    cout << endl;
    return 0;
}


53.-Suma alternada 1-2+3-4+...
Enunciado: Leer N y calcular 1 - 2 + 3 - 4 + ... ± N.

#include <iostream>
using namespace std;

int main() {
    int N; cout << "N: "; cin >> N;
    int suma = 0;
    for (int i=1;i<=N;++i) suma += (i % 2 == 1 ? i : -i);
    cout << "Resultado: " << suma << endl;
    return 0;
}


54.-Suma de cuadrados hasta N
Enunciado: Leer N y calcular 1^2 + 2^2 + ... + N^2.

#include <iostream>
using namespace std;

int main() {
    int N; cout << "N: "; cin >> N;
    long long suma = 0;
    for (int i=1;i<=N;++i) suma += (long long)i*i;
    cout << "Suma cuadrados: " << suma << endl;
    return 0;
}


55.-Contar vocales y consonantes en frase
Enunciado: Leer una línea y contar vocales y consonantes (ignorar otros).

#include <iostream>
#include <string>
using namespace std;

int main() {
    string linea;
    cout << "Ingresa línea: ";
    getline(cin, linea);
    int v=0, c=0;
    for (char ch : linea) {
        char l = tolower(ch);
        if (l>='a' && l<='z') {
            if (l=='a'||l=='e'||l=='i'||l=='o'||l=='u') ++v;
            else ++c;
        }
    }
    cout << "Vocales: " << v << " Consonantes: " << c << endl;
    return 0;
}


56.-Calcular área de un círculo
Enunciado: Leer radio y mostrar el área (? = 3.14159).

#include <iostream>
using namespace std;

int main() {
    double r;
    cout << "Radio: ";
    cin >> r;
    const double PI = 3.14159;
    cout << "Área: " << PI * r * r << endl;
    return 0;
}


57.-Área y perímetro de rectángulo
Enunciado: Leer base y altura y mostrar área y perímetro.

#include <iostream>
using namespace std;

int main() {
    double b, h;
    cout << "Base y altura: ";
    cin >> b >> h;
    cout << "Área: " << (b*h) << " Perímetro: " << (2*(b+h)) << endl;
    return 0;
}


58.-Conversión Celsius a Fahrenheit
Enunciado: Leer temperatura en °C y convertir a °F.

#include <iostream>
using namespace std;

int main() {
    double c;
    cout << "Celsius: ";
    cin >> c;
    double f = c * 9.0/5.0 + 32.0;
    cout << "Fahrenheit: " << f << endl;
    return 0;
}


59.-Conversión Fahrenheit a Celsius
Enunciado: Leer °F y convertir a °C.

#include <iostream>
using namespace std;

int main() {
    double f;
    cout << "Fahrenheit: ";
    cin >> f;
    double c = (f - 32.0) * 5.0/9.0;
    cout << "Celsius: " << c << endl;
    return 0;
}


60.-Interés simple
Enunciado: Calcular interés simple: A = P(1 + r*t). Leer P, r (en decimal) y t.

#include <iostream>
using namespace std;

int main() {
    double P, r, t;
    cout << "P r t: ";
    cin >> P >> r >> t;
    double A = P * (1 + r * t);
    cout << "Monto: " << A << endl;
    return 0;
}


61.-Interés compuesto (anual)
Enunciado: A = P*(1 + r)^t. Leer P, r, t (años).

#include <iostream>
#include <cmath>
using namespace std;

int main() {
    double P, r, t;
    cout << "P r t: ";
    cin >> P >> r >> t;
    double A = P * pow(1 + r, t);
    cout << "Monto compuesto: " << A << endl;
    return 0;
}


62.-Convertir número a romano (1..10)
Enunciado: Leer N entre 1 y 10 y mostrar su representación en números romanos.

#include <iostream>
using namespace std;

int main() {
    int n; cout << "N (1-10): "; cin >> n;
    string rom[] = {"","I","II","III","IV","V","VI","VII","VIII","IX","X"};
    if (n>=1 && n<=10) cout << rom[n] << endl;
    else cout << "Fuera de rango\n";
    return 0;
}


63.-Verificar año bisiesto
Enunciado: Leer un año y decir si es bisiesto.

#include <iostream>
using namespace std;

int main() {
    int y; cout << "Año: "; cin >> y;
    bool bis = (y%4==0 && y%100!=0) || (y%400==0);
    cout << (bis ? "Bisiesto\n" : "No bisiesto\n");
    return 0;
}


64.-Suma de números impares hasta N
Enunciado: Leer N y sumar los impares ? N.

#include <iostream>
using namespace std;

int main() {
    int N; cout << "N: "; cin >> N;
    int suma = 0;
    for (int i=1;i<=N;i+=2) suma += i;
    cout << "Suma impares: " << suma << endl;
    return 0;
}


65.-Serie aritmética
Enunciado: Dado a1 (primer término), d (razón) y N, imprimir los N primeros términos.

#include <iostream>
using namespace std;

int main() {
    int a1, d, N;
    cout << "a1 d N: "; cin >> a1 >> d >> N;
    int term = a1;
    for (int i=0;i<N;++i) {
        cout << term << " ";
        term += d;
    }
    cout << endl;
    return 0;
}


66.-Serie geométrica
Enunciado: Dado a1 (primer término), r (razón) y N, imprimir los N primeros términos.

#include <iostream>
using namespace std;

int main() {
    double a1, r;
    int N;
    cout << "a1 r N: "; cin >> a1 >> r >> N;
    double term = a1;
    for (int i=0;i<N;++i) {
        cout << term << " ";
        term *= r;
    }
    cout << endl;
    return 0;
}


67.-Suma de elementos en matriz
Enunciado: Leer NxM y sumar todos los elementos.

#include <iostream>
using namespace std;

int main() {
    int N,M; cin >> N >> M;
    int x, suma=0;
    for (int i=0;i<N;++i) for (int j=0;j<M;++j){ cin>>x; suma+=x; }
    cout << "Suma total: " << suma << endl;
    return 0;
}


68.-contar negativos en matCriz
Enunciado: Leer NxM y contar cuántos elementos son negativos.

#include <iostream>
using namespace std;

int main() {
    int N,M; cin >> N >> M;
    int x, cnt=0;
    for (int i=0;i<N;++i) for (int j=0;j<M;++j){ cin>>x; if (x<0) ++cnt; }
    cout << "Negativos: " << cnt << endl;
    return 0;
}


69.-Suma de dígitos pares
Enunciado: Leer un entero y sumar solo los dígitos pares.

#include <iostream>
using namespace std;

int main() {
    int n; cout << "Número: "; cin >> n;
    n = (n<0)? -n : n;
    int suma=0;
    while (n){ int d=n%10; if (d%2==0) suma+=d; n/=10; }
    cout << "Suma dígitos pares: " << suma << endl;
    return 0;
}


70.-Mayor y menor de arreglo
Enunciado: Leer N y N números; mostrar mayor y menor.

#include <iostream>
using namespace std;

int main() {
    int N; cin >> N;
    int x, maxv, minv;
    for (int i=0;i<N;++i) {
        cin >> x;
        if (i==0){ maxv=minv=x; }
        else { if (x>maxv) maxv=x; if (x<minv) minv=x; }
    }
    cout << "Mayor: " << maxv << " Menor: " << minv << endl;
    return 0;
}


* 71.-Ordenar 3 números (ascendente)*
Enunciado: Leer a,b,c y mostrarlos ordenados ascendentemente.

#include <iostream>
using namespace std;

int main() {
    int a,b,c; cin >> a >> b >> c;
    if (a>b) swap(a,b);
    if (a>c) swap(a,c);
    if (b>c) swap(b,c);
    cout << a << " " << b << " " << c << endl;
    return 0;
}


72.-Sumar impares en arreglo
Enunciado: Leer N y N enteros; sumar solo los impares.

#include <iostream>
using namespace std;

int main() {
    int N; cin >> N;
    int suma=0, x;
    for (int i=0;i<N;++i){ cin>>x; if (x%2!=0) suma+=x; }
    cout << "Suma impares: " << suma << endl;
    return 0;
}


73.-Edad en años, meses, días
Enunciado: Leer días totales (entero) y convertir a años (365), meses (30) y días restantes.

#include <iostream>
using namespace std;

int main() {
    int dias; cin >> dias;
    int años = dias / 365;
    dias %= 365;
    int meses = dias / 30;
    dias %= 30;
    cout << años << " años, " << meses << " meses, " << dias << " días\n";
    return 0;
}


74.-Sistema de calificaciones (A-F)
Enunciado: Leer nota 0-100 y mostrar letra: A(90-100), B(80-89), C(70-79), D(60-69), F(<60).

#include <iostream>
using namespace std;

int main() {
    int n; cin >> n;
    if (n>=90) cout << "A\n";
    else if (n>=80) cout << "B\n";
    else if (n>=70) cout << "C\n";
    else if (n>=60) cout << "D\n";
    else cout << "F\n";
    return 0;
}


75.-Contar números primos en arreglo
Enunciado: Leer N y N enteros; contar cuántos son primos.

#include <iostream>
using namespace std;

bool esPrimo(int n){
    if (n<=1) return false;
    for (int i=2;i*i<=n;++i) if (n%i==0) return false;
    return true;
}

int main() {
    int N; cin >> N;
    int cnt=0, x;
    for (int i=0;i<N;++i){ cin>>x; if (esPrimo(x)) ++cnt; }
    cout << "Primos: " << cnt << endl;
    return 0;
}


76.-Buscar subcadena (posición primera aparición)
Enunciado: Leer una línea y una subcadena; mostrar la posición (1-based) de la primera aparición o 0 si no está.

#include <iostream>
#include <string>
using namespace std;

int main() {
    string s, sub;
    cout << "Cadena: "; getline(cin, s);
    cout << "Subcadena: "; getline(cin, sub);
    size_t pos = s.find(sub);
    cout << (pos == string::npos ? 0 : (int)pos+1) << endl;
    return 0;
}


77.-Convertir minutos a horas y minutos
Enunciado: Leer minutos totales y mostrar en formato H horas y M minutos.

#include <iostream>
using namespace std;

int main() {
    int mins; cin >> mins;
    int h = mins / 60;
    int m = mins % 60;
    cout << h << " horas " << m << " minutos\n";
    return 0;
}


78.-Ordenar arreglo (burbuja básica)
Enunciado: Leer N y N enteros; ordenarlos ascendentemente usando el algoritmo burbuja.

#include <iostream>
using namespace std;

int main() {
    int N; cin >> N;
    int a[1000];
    for (int i=0;i<N;++i) cin >> a[i];
    for (int i=0;i<N-1;++i)
        for (int j=0;j<N-1-i;++j)
            if (a[j] > a[j+1]) swap(a[j], a[j+1]);
    for (int i=0;i<N;++i) cout << a[i] << " ";
    cout << endl;
    return 0;
}


79.-Eliminar elemento en arreglo (posición)
Enunciado: Leer N y un arreglo; luego leer posición p (1-based) y eliminar el elemento en p, mostrando el arreglo resultante.

#include <iostream>
using namespace std;

int main() {
    int N; cin >> N;
    int a[1000];
    for (int i=0;i<N;++i) cin >> a[i];
    int p; cin >> p; // 1-based
    if (p<1 || p> N) { cout << "Posición inválida\n"; return 0; }
    for (int i=p-1;i<N-1;++i) a[i] = a[i+1];
    for (int i=0;i<N-1;++i) cout << a[i] << " ";
    cout << endl;
    return 0;
}


80.-Insertar elemento en arreglo (posición)
Enunciado: Leer N y arreglo; luego leer valor v y posición p; insertar v en p (1-based).

#include <iostream>
using namespace std;

int main() {
    int N; cin >> N;
    int a[1000];
    for (int i=0;i<N;++i) cin >> a[i];
    int v, p; cin >> v >> p;
    if (p<1 || p> N+1) { cout << "Pos inválida\n"; return 0; }
    for (int i=N;i>=p;--i) a[i] = a[i-1];
    a[p-1] = v;
    for (int i=0;i<N+1;++i) cout << a[i] << " ";
    cout << endl;
    return 0;
}


81.-Contar ocurrencias en arreglo
Enunciado: Leer N y arreglo; luego leer valor v y contar cuántas veces aparece.

#include <iostream>
using namespace std;

int main() {
    int N; cin >> N;
    int a[1000], v, cnt=0;
    for (int i=0;i<N;++i) cin >> a[i];
    cin >> v;
    for (int i=0;i<N;++i) if (a[i]==v) ++cnt;
    cout << "Ocurrencias: " << cnt << endl;
    return 0;
}


82.-Suma de dos números grandes (como cadenas)
Enunciado: Leer dos números muy grandes como cadenas y mostrar su suma (sin usar bibliotecas grandes).

#include <iostream>
#include <string>
using namespace std;

int main() {
    string a, b;
    cin >> a >> b;
    string res = "";
    int i = a.size()-1, j = b.size()-1, carry=0;
    while (i>=0 || j>=0 || carry) {
        int da = (i>=0 ? a[i--]-'0' : 0);
        int db = (j>=0 ? b[j--]-'0' : 0);
        int s = da + db + carry;
        res.push_back(char('0' + (s%10)));
        carry = s/10;
    }
    reverse(res.begin(), res.end());
    cout << res << endl;
    return 0;
}


83.-Convertir entero a binario
Enunciado: Leer un entero no negativo y mostrar su representación binaria.

#include <iostream>
#include <string>
using namespace std;

int main() {
    int n; cin >> n;
    if (n==0) { cout << "0\n"; return 0; }
    string b="";
    while (n>0) { b.push_back('0' + (n%2)); n/=2; }
    reverse(b.begin(), b.end());
    cout << b << endl;
    return 0;
}


84.-Sumar números en una línea separados por espacios
Enunciado: Leer una línea con números separados por espacios y mostrar su suma.

#include <iostream>
#include <sstream>
#include <string>
using namespace std;

int main() {
    string linea; getline(cin, linea);
    istringstream iss(linea);
    int x, suma=0;
    while (iss >> x) suma += x;
    cout << "Suma: " << suma << endl;
    return 0;
}


85.-Comparar dos cadenas (lexicográfico)
Enunciado: Leer dos palabras y decir cuál es lexicográficamente menor, o si son iguales.

#include <iostream>
#include <string>
using namespace std;

int main() {
    string a, b; cin >> a >> b;
    if (a == b) cout << "Iguales\n";
    else if (a < b) cout << a << " < " << b << endl;
    else cout << a << " > " << b << endl;
    return 0;
}


86.-Saber si N es cuadrado perfecto
Enunciado: Leer N y decir si es cuadrado perfecto.

#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int n; cin >> n;
    int r = (int) sqrt(n);
    cout << (r*r == n ? "Cuadrado perfecto\n" : "No es cuadrado perfecto\n");
    return 0;
}


87.-Suma de matrices (general NxM)
Enunciado: Leer NxM y luego otra NxM; mostrar su suma.

#include <iostream>
using namespace std;

int main() {
    int N,M; cin >> N >> M;
    int A[100][100], B[100][100];
    for (int i=0;i<N;++i) for (int j=0;j<M;++j) cin>>A[i][j];
    for (int i=0;i<N;++i) for (int j=0;j<M;++j) cin>>B[i][j];
    for (int i=0;i<N;++i){
        for (int j=0;j<M;++j) cout << (A[i][j]+B[i][j]) << " ";
        cout << endl;
    }
    return 0;
}


88.-Producto de matrices 2x2
Enunciado: Leer dos matrices 2x2 y mostrar su producto.

#include <iostream>
using namespace std;

int main() {
    int A[2][2], B[2][2], C[2][2] = {0};
    for (int i=0;i<2;++i) for (int j=0;j<2;++j) cin >> A[i][j];
    for (int i=0;i<2;++i) for (int j=0;j<2;++j) cin >> B[i][j];
    for (int i=0;i<2;++i)
        for (int j=0;j<2;++j) {
            C[i][j]=0;
            for (int k=0;k<2;++k) C[i][j]+= A[i][k]*B[k][j];
        }
    for (int i=0;i<2;++i){ for (int j=0;j<2;++j) cout << C[i][j] << " "; cout << endl; }
    return 0;
}


89.-Número invertido y comprobar palíndromo numérico
Enunciado: Leer un número y decir si es palíndromo numérico (ej. 121).

#include <iostream>
using namespace std;

int main() {
    int n; cin >> n;
    int orig = n, rev = 0;
    while (n) { rev = rev*10 + n%10; n /= 10; }
    cout << (rev == orig ? "Palíndromo\n" : "No palíndromo\n");
    return 0;
}


90.-Sumar números pares en posición par de arreglo
Enunciado: Leer N y arreglo; sumar números que están en posiciones pares (2,4,...) considerando 1-based.

#include <iostream>
using namespace std;

int main() {
    int N; cin >> N;
    int x, suma=0;
    for (int i=1;i<=N;++i) { cin>>x; if (i%2==0) suma+=x; }
    cout << "Suma posiciones pares: " << suma << endl;
    return 0;
}


90.-Promedio de notas descartando la menor
Enunciado: Leer N notas y calcular el promedio descartando la nota más baja.

#include <iostream>
using namespace std;

int main() {
    int N; cin >> N;
    double suma=0, x;
    double minv=1e9;
    for (int i=0;i<N;++i){ cin>>x; suma+=x; if (x<minv) minv=x; }
    if (N<=1) cout << "No es posible\n";
    else cout << "Promedio: " << ( (suma - minv) / (N-1) ) << endl;
    return 0;
}

*91.-Contar números mayores al promedio
Enunciado: Leer N y N números; mostrar cuántos están por encima del promedio.

#include <iostream>
using namespace std;

int main() {
    int N; cin >> N;
    double a[1000], suma=0;
    for (int i=0;i<N;++i){ cin>>a[i]; suma+=a[i]; }
    double prom = suma / N;
    int cnt=0;
    for (int i=0;i<N;++i) if (a[i] > prom) ++cnt;
    cout << "Mayores al promedio: " << cnt << endl;
    return 0;
}


92.-Suma de dígitos recursiva (digital root)
Enunciado: Leer un número y aplicar suma de dígitos repetida hasta obtener un solo dígito.

#include <iostream>
using namespace std;

int main() {
    long long n; cin >> n;
    n = (n<0)? -n : n;
    while (n >= 10) {
        long long s = 0;
        while (n) { s += n%10; n/=10; }
        n = s;
    }
    cout << n << endl;
    return 0;
}


93.-Comprobar si arreglo está ordenado (asc)
Enunciado: Leer N y arreglo; decir si está ordenado ascendentemente.

#include <iostream>
using namespace std;

int main() {
    int N; cin >> N;
    int prev, cur;
    if (N<=0) { cout << "Sí (vacío)\n"; return 0; }
    cin >> prev;
    bool ok = true;
    for (int i=1;i<N;++i) { cin>>cur; if (cur < prev) ok = false; prev = cur; }
    cout << (ok ? "Ordenado\n" : "No ordenado\n");
    return 0;
}


94.-Contar cifras pares en arreglo
Enunciado: Leer N y N enteros; contar cuántos tienen un número par de dígitos.

#include <iostream>
using namespace std;

int digitos(int n){ if (n==0) return 1; int c=0; n = (n<0)? -n : n; while(n){ n/=10; ++c; } return c; }

int main() {
    int N; cin >> N;
    int cnt=0, x;
    for (int i=0;i<N;++i){ cin>>x; if (digitos(x)%2==0) ++cnt; }
    cout << "Con dígitos pares: " << cnt << endl;
    return 0;
}


95.-Imprimir patrón de asteriscos (triángulo)
Enunciado: Leer N y mostrar un triángulo de * de altura N (alineado a la izquierda).

#include <iostream>
using namespace std;

int main() {
    int N; cin >> N;
    for (int i=1;i<=N;++i) {
        for (int j=0;j<i;++j) cout << "*";
        cout << endl;
    }
    return 0;
}


96.-Sumar matrices 3x3 (constantes)
Enunciado: Leer dos matrices 3x3 y mostrar su suma.

#include <iostream>
using namespace std;

int main() {
    int A[3][3], B[3][3];
    for (int i=0;i<3;++i) for (int j=0;j<3;++j) cin>>A[i][j];
    for (int i=0;i<3;++i) for (int j=0;j<3;++j) cin>>B[i][j];
    for (int i=0;i<3;++i){ for (int j=0;j<3;++j) cout << (A[i][j]+B[i][j]) << " "; cout << endl;}
    return 0;
}


97.-Calcular hipotenusa
Enunciado: Leer catetos a y b y calcular la hipotenusa (?(a²+b²)).

#include <iostream>
#include <cmath>
using namespace std;

int main() {
    double a,b; cin >> a >> b;
    cout << "Hipotenusa: " << sqrt(a*a + b*b) << endl;
    return 0;
}


98.-Área de triángulo (base y altura)
Enunciado: Leer base y altura y calcular área = (base*altura)/2.

#include <iostream>
using namespace std;

int main() {
    double b,h; cin >> b >> h;
    cout << "Área: " << (b*h/2.0) << endl;
    return 0;
}


99.-Conversión decimal a hexadecimal (0..255)
Enunciado: Leer entero 0-255 y mostrar en hexadecimal (usando std::hex con iostream).

#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    int n; cin >> n;
    if (n<0 || n>255) { cout << "Fuera de rango\n"; return 0; }
    cout << hex << uppercase << n << endl;
    return 0;
}


100.-Comparar longitudes de dos cadenas
Enunciado: Leer dos líneas y decir cuál es más larga (o si son iguales).

#include <iostream>
#include <string>
using namespace std;

int main() {
    string a, b;
    cout << "Linea A: "; getline(cin, a);
    cout << "Linea B: "; getline(cin, b);
    if (a.size() == b.size()) cout << "Iguales\n";
    else if (a.size() > b.size()) cout << "A es más larga\n";
    else cout << "B es más larga\n";
    return 0;
}
Ejercicio 101: Generar todas las permutaciones de un vector
Análisis del Problema
 Se requiere generar e imprimir todas las permutaciones posibles de un conjunto de números distintos.
Diseño de la Solución
? Ordenar inicialmente el vector.

? Usar std::next_permutation hasta agotar todas las permutaciones posibles.

Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n; 
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];

    sort(a.begin(), a.end());
    do {
        for (int x : a) cout << x << ' ';
        cout << '\n';
    } while (next_permutation(a.begin(), a.end()));

    return 0;
}

Pruebas
? Entrada: 3 seguido de 1 2 3

Salida esperada:

 1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
? 
 Ejercicio 102: Generar combinaciones de tamaño k
Análisis del Problema
 Se pide imprimir todas las combinaciones posibles de tamaño k de un conjunto de n elementos.
Diseño de la Solución
 Usar una máscara binaria de n bits con k unos. Luego aplicar std::prev_permutation.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, k;
    cin >> n >> k;
    vector<int> mask(n, 0);
    fill(mask.begin(), mask.begin() + k, 1);
    do {
        for (int i = 0; i < n; ++i)
            if (mask[i]) cout << i + 1 << ' ';
        cout << '\n';
    } while (prev_permutation(mask.begin(), mask.end()));
}

Pruebas
? Entrada: n=4 k=2

Salida esperada:

 1 2
1 3
1 4
2 3
2 4
3 4
? 
 Ejercicio 103: Generar subconjuntos (potencia de un conjunto)
Análisis del Problema
 Generar todos los subconjuntos posibles (2? combinaciones) de un conjunto de elementos.
Diseño de la Solución
 Usar una máscara de bits de 0 a (2? - 1) para seleccionar elementos.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];

    for (int mask = 0; mask < (1 << n); ++mask) {
        cout << "{ ";
        for (int i = 0; i < n; ++i)
            if (mask & (1 << i)) cout << a[i] << ' ';
        cout << "}\n";
    }
}

Pruebas
? Entrada: 3 seguido de 1 2 3

Salida:

 { }
{ 1 }
{ 2 }
{ 1 2 }
{ 3 }
{ 1 3 }
{ 2 3 }
{ 1 2 3 }
? 
 Ejercicio 104: Generar permutaciones únicas con elementos repetidos
Análisis del Problema
 Generar permutaciones sin duplicados, aunque existan elementos iguales.
Diseño de la Solución
 Usar std::next_permutation tras ordenar el vector.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    sort(a.begin(), a.end());
    do {
        for (int x : a) cout << x << ' ';
        cout << '\n';
    } while (next_permutation(a.begin(), a.end()));
}

Pruebas
? Entrada: 3 seguido de 1 1 2

Salida esperada:

 1 1 2
1 2 1
2 1 1
? 
 Ejercicio 105: Generar todas las particiones de un número entero
Análisis del Problema
 Dividir un número n en sumas de enteros positivos (orden no importa).
Diseño de la Solución
 Usar backtracking recursivo para generar todas las combinaciones no decrecientes.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

void partition(int n, int max_val, vector<int>& cur) {
    if (n == 0) {
        for (int x : cur) cout << x << ' ';
        cout << '\n';
        return;
    }
    for (int i = min(n, max_val); i >= 1; --i) {
        cur.push_back(i);
        partition(n - i, i, cur);
        cur.pop_back();
    }
}

int main() {
    int n; cin >> n;
    vector<int> cur;
    partition(n, n, cur);
}

Pruebas
? Entrada: 4

Salida esperada:

 4
3 1
2 2
2 1 1
1 1 1 1
? 
 Ejercicio 106: Calcular todas las permutaciones lexicográficas posteriores
Análisis del Problema
 Encontrar la siguiente permutación lexicográfica posible.
Diseño de la Solución
 Usar std::next_permutation.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    if (next_permutation(a.begin(), a.end())) {
        for (int x : a) cout << x << ' ';
    } else {
        cout << "No existe siguiente permutación\n";
    }
}

Pruebas
? Entrada: 3 seguido de 1 2 3 ? 1 3 2

? Entrada: 3 2 1 ? “No existe siguiente permutación”
 Ejercicio 107: Uso de std::binary_search
Análisis del Problema
 Determinar si un elemento existe en un vector ordenado.
Diseño de la Solución
 Aplicar std::sort y std::binary_search.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 3, 5, 7, 9};
    int x; cin >> x;
    if (binary_search(v.begin(), v.end(), x))
        cout << "Encontrado\n";
    else
        cout << "No encontrado\n";
}

Pruebas
? Entrada: 5 ? “Encontrado”

? Entrada: 4 ? “No encontrado”

 Ejercicio 108: Contar frecuencias con std::map
Análisis del Problema
 Contar cuántas veces aparece cada palabra en un texto.
Diseño de la Solución
? Leer texto palabra por palabra.

? Incrementar el contador en std::map<string, int>.

Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    map<string, int> freq;
    string word;
    while (cin >> word) freq[word]++;
    for (auto& [w, c] : freq)
        cout << w << ": " << c << '\n';
}

Pruebas
? Entrada: "hola mundo hola"

Salida:

 hola: 2
mundo: 1
? 
 Ejercicio 109: Ordenar palabras alfabéticamente ignorando mayúsculas
Análisis del Problema
 Ordenar texto sin diferenciar entre mayúsculas y minúsculas.
Diseño de la Solución
 Usar std::sort con comparador que convierte temporalmente a minúsculas.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

bool cmp(string a, string b) {
    transform(a.begin(), a.end(), a.begin(), ::tolower);
    transform(b.begin(), b.end(), b.begin(), ::tolower);
    return a < b;
}

int main() {
    int n; cin >> n;
    vector<string> v(n);
    for (auto &s : v) cin >> s;
    sort(v.begin(), v.end(), cmp);
    for (auto &s : v) cout << s << '\n';
}

Pruebas
? Entrada: 3 ? Hola hola mundo

Salida:

 hola
Hola
? mundo
Ejercicio 110: Calcular mediana usando dos priority_queue
Análisis del Problema
 Calcular la mediana de un flujo continuo de números.
Diseño de la Solución
 Mantener dos heaps: uno max-heap (menores) y otro min-heap (mayores).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    priority_queue<int> left;
    priority_queue<int, vector<int>, greater<int>> right;
    int x;
    while (cin >> x) {
        if (left.empty() || x <= left.top()) left.push(x);
        else right.push(x);

        if (left.size() > right.size() + 1) {
            right.push(left.top()); left.pop();
        } else if (right.size() > left.size()) {
            left.push(right.top()); right.pop();
        }

        double median;
        if (left.size() == right.size()) median = (left.top() + right.top()) / 2.0;
        else median = left.top();
        cout << "Mediana actual: " << median << "\n";
    }
}

Pruebas
? Entrada: 5 2 1 4 3

? Salidas intermedias: 5, 3.5, 2, 3, 3
Ejercicio 111: Implementar un Trie (insert, search, startsWith) usando unordered_map
Análisis del Problema
 Construir una estructura Trie para almacenar palabras y permitir búsqueda exacta y prefijos.
Diseño de la Solución
 Nodo con unordered_map<char, Node*> y flag is_word. Operaciones: insert, search, startsWith.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

struct TrieNode {
    unordered_map<char, TrieNode*> next;
    bool is_word = false;
};

struct Trie {
    TrieNode* root = new TrieNode();
    void insert(const string &s) {
        TrieNode* cur = root;
        for(char c : s) {
            if(!cur->next[c]) cur->next[c] = new TrieNode();
            cur = cur->next[c];
        }
        cur->is_word = true;
    }
    bool search(const string &s) {
        TrieNode* cur = root;
        for(char c : s) {
            if(!cur->next.count(c)) return false;
            cur = cur->next[c];
        }
        return cur->is_word;
    }
    bool startsWith(const string &p) {
        TrieNode* cur = root;
        for(char c : p) {
            if(!cur->next.count(c)) return false;
            cur = cur->next[c];
        }
        return true;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    Trie trie;
    trie.insert("hola");
    trie.insert("holanda");
    trie.insert("holi");
    cout << trie.search("hola") << '\n';      // 1
    cout << trie.search("hol") << '\n';       // 0
    cout << trie.startsWith("hol") << '\n';   // 1
    cout << trie.search("adios") << '\n';     // 0
    return 0;
}

Pruebas
? Inserta hola, holanda, holi. search("hola") -> 1, startsWith("hol") -> 1.
Ejercicio 112: Leer archivos en un directorio usando std::filesystem y contar líneas
Análisis del Problema
 Recorrer un directorio y contar el número total de líneas de archivos .txt.
Diseño de la Solución
 Usar std::filesystem::directory_iterator para listar archivos; para cada .txt, abrir y contar líneas.
Código Fuente (C++)
#include <bits/stdc++.h>
#include <filesystem>
using namespace std;
namespace fs = std::filesystem;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string path; // ejemplo: "."
    if(!(cin >> path)) return 0;
    long long total_lines = 0;
    for (auto &entry : fs::directory_iterator(path)) {
        if (!entry.is_regular_file()) continue;
        auto p = entry.path();
        if (p.extension() == ".txt") {
            ifstream in(p);
            string line;
            while (getline(in, line)) ++total_lines;
        }
    }
    cout << "Total lines in .txt files: " << total_lines << '\n';
    return 0;
}

Pruebas
? Ejecutar con ruta donde hay .txt para obtener suma de líneas.
Ejercicio 113: Sort indices usando comparador que usa datos externos
Análisis del Problema
 Ordenar índices 0..n-1 de acuerdo con valores en vector externo key[], sin mover key (orden indirecto).
Diseño de la Solución
 Crear vector de índices y usar sort con lambda que compara key[i].
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<int> key(n);
    for(int i=0;i<n;++i) cin>>key[i];
    vector<int> idx(n);
    iota(idx.begin(), idx.end(), 0);
    sort(idx.begin(), idx.end(), [&](int a, int b){
        if(key[a] != key[b]) return key[a] < key[b];
        return a < b; // tie-breaker stable by index
    });
    for(int i: idx) cout<<i<<' ';
    cout<<'\n';
    return 0;
}

Pruebas
? key = [30,10,20] ? idx order 1 2 0.


Ejercicio 114: Uso de unique_ptr y shared_ptr (RAII, ownership)
Análisis del Problema
 Demostrar manejo de memoria con smart pointers; crear árbol simple con unique_ptr.
Diseño de la Solución
 unique_ptr para ownership exclusivo; shared_ptr para nodos con múltiples owners (ej. grafo simple).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int val;
    unique_ptr<Node> left;
    unique_ptr<Node> right;
    Node(int v): val(v) {}
};

int main(){
    auto root = make_unique<Node>(10);
    root->left = make_unique<Node>(5);
    root->right = make_unique<Node>(15);
    cout << root->left->val << ' ' << root->right->val << '\n';

    // shared_ptr example (multiple owners)
    auto a = make_shared<int>(42);
    auto b = a; // shared ownership
    cout << *a << ' ' << *b << '\n';
    cout << "use_count: " << a.use_count() << '\n';
    return 0;
}

Pruebas
? Imprime 5 15 y 42 42 y use_count: 2.
Ejercicio 115: std::promise / std::future ejemplo (productor-consumidor simple)
Análisis del Problema
 Coordinar hilo productor que envía un valor y el consumidor que lo recibe usando promise/future.
Diseño de la Solución
 Crear std::promise<int> p; std::future<int> f = p.get_future(); Productor set_value, consumidor f.get().
Código Fuente (C++)
#include <bits/stdc++.h>
#include <thread>
using namespace std;

int main(){
    promise<int> prom;
    future<int> fut = prom.get_future();

    thread producer([&prom](){
        this_thread::sleep_for(chrono::milliseconds(200));
        prom.set_value(123);
    });

    thread consumer([&fut](){
        cout << "Waiting for value...\n";
        int v = fut.get();
        cout << "Got value: " << v << '\n';
    });

    producer.join();
    consumer.join();
    return 0;
}

Pruebas
? Ejecutar, espera breve, imprime Got value: 123.
Ejercicio 116: Parseo eficiente usando std::string_view (split sin copiar)
Análisis del Problema
 Dado un string grande, imprimir sus palabras sin crear substrings (evitar copies).
Diseño de la Solución
 Usar string_view para apuntar a segmentos del string.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string s;
    getline(cin, s);
    string_view sv(s);
    size_t i=0;
    while(i < sv.size()){
        while(i<sv.size() && isspace((unsigned char)sv[i])) ++i;
        if(i>=sv.size()) break;
        size_t j=i;
        while(j<sv.size() && !isspace((unsigned char)sv[j])) ++j;
        cout << sv.substr(i, j-i) << '\n';
        i = j;
    }
    return 0;
}

Pruebas
? Entrada hola mundo desde string_view imprime cada palabra en su línea.
Ejercicio 117: Validar emails con std::regex
Análisis del Problema
 Verificar si cadenas son correos electrónicos básicos usando regex.
Diseño de la Solución
 Patrón simple: ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$.
Código Fuente (C++)
#include <bits/stdc++.h>
#include <regex>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    regex email(R"(^[A-Za-z0-9._%+\-]+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,}$)");
    string s;
    while(cin >> s){
        cout << s << ": " << (regex_match(s, email) ? "VALID" : "INVALID") << '\n';
    }
    return 0;
}

Pruebas
? test@example.com -> VALID; bad@com -> INVALID.
Ejercicio 118: Investigar colisiones en std::unordered_map (ver buckets, load factor)
Análisis del Problema
 Medir bucket_count, max_load_factor, load_factor tras insertar muchas claves.
Diseño de la Solución
 Insertar n enteros (o strings), imprimir bucket_count y load_factor.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    unordered_map<string,int> um;
    for(int i=0;i<n;++i){
        string s = "key_" + to_string(i);
        um[s] = i;
    }
    cout << "size: " << um.size() << '\n';
    cout << "bucket_count: " << um.bucket_count() << '\n';
    cout << "load_factor: " << um.load_factor() << '\n';
    cout << "max_load_factor: " << um.max_load_factor() << '\n';
    // show collisions per bucket (sample)
    int collisions = 0;
    for(size_t b = 0; b < um.bucket_count(); ++b){
        size_t bs = um.bucket_size(b);
        if(bs > 1) collisions += (bs - 1);
    }
    cout << "collisions (approx): " << collisions << '\n';
    return 0;
}

Pruebas
? Ejecutar con n=10000 y observar bucket metrics.
Ejercicio 119: Esqueleto de custom allocator para std::vector (plantilla)
Análisis del Problema
 Mostrar cómo declarar un allocator personalizado (conceptual, simplificado).
Diseño de la Solución
 Proveer clase SimpleAlloc adaptada a std::allocator_traits (ejemplo funcional básico que usa ::operator new/delete).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

template <typename T>
struct SimpleAlloc {
    using value_type = T;
    SimpleAlloc() = default;
    template <class U> constexpr SimpleAlloc(const SimpleAlloc<U>&) noexcept {}
    T* allocate(size_t n) { return static_cast<T*>(::operator new(n * sizeof(T))); }
    void deallocate(T* p, size_t) noexcept { ::operator delete(p); }
};

int main(){
    vector<int, SimpleAlloc<int>> v;
    for(int i=0;i<10;++i) v.push_back(i);
    for(int x: v) cout << x << ' ';
    cout << '\n';
    return 0;
}

Pruebas
? Ejecutar: imprime 0 1 2 3 4 5 6 7 8 9.
Ejercicio 120: Encadenar algoritmos STL (transform + sort + unique)
Análisis del Problema
 Dado vector de strings, normalizar (lowercase), ordenar, quitar duplicados, y mostrar.
Diseño de la Solución
 transform para lowercase, sort, unique, erase.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<string> v(n);
    for(int i=0;i<n;++i) cin>>v[i];
    for(auto &s: v) transform(s.begin(), s.end(), s.begin(), ::tolower);
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    for(auto &s: v) cout << s << '\n';
    return 0;
}

Pruebas
? n=5 strings: A a B b A -> output: a b.
Ejercicio 121: Implementar Segment Tree (range sum) iterativo (bottom-up)
Análisis del Problema
 Range sum queries + point updates, implementación iterativa (n power of two).
Diseño de la Solución
 Árbol en array de tamaño 2*n, where leaves stored at n..2n-1.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
struct SegTree {
    int n; vector<long long> t;
    SegTree(int _n): n(_n), t(2*_n,0) {}
    void build(const vector<long long>& a){
        for(int i=0;i<n;++i) t[n+i]=a[i];
        for(int i=n-1;i>0;--i) t[i]=t[i<<1]+t[i<<1|1];
    }
    void update(int pos, long long val){
        pos += n; t[pos]=val;
        for(pos >>=1; pos; pos>>=1) t[pos]=t[pos<<1]+t[pos<<1|1];
    }
    long long query(int l, int r){ // [l,r)
        long long res=0;
        for(l+=n, r+=n; l<r; l>>=1, r>>=1){
            if(l&1) res += t[l++];
            if(r&1) res += t[--r];
        }
        return res;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<long long> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    SegTree st(n);
    st.build(a);
    int q; cin>>q;
    while(q--){
        int type; cin>>type;
        if(type==1){ int pos; long long val; cin>>pos>>val; st.update(pos,val); }
        else { int l,r; cin>>l>>r; cout<<st.query(l,r)<<"\n"; }
    }
    return 0;
}

Pruebas
? Build with [1,2,3,4,5], query(0,5)=15; update pos2 to 10, query(0,5)=22.
Ejercicio 122: Fenwick Tree (BIT) — construcción y range sum
Análisis del Problema
 Soportar add at pos and prefix sum queries; show range sum.
Diseño de la Solución
 Implementación clásica 1-based internal.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
struct Fenwick {
    int n; vector<long long> bit;
    Fenwick(int _n): n(_n), bit(n+1,0) {}
    void add(int idx, long long val){ for(; idx<=n; idx+=idx&-idx) bit[idx]+=val; }
    long long sum(int idx){ long long r=0; for(; idx>0; idx-=idx&-idx) r+=bit[idx]; return r; }
    long long range(int l,int r){ return sum(r) - sum(l-1); }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    Fenwick fw(n);
    for(int i=1;i<=n;++i){ long long x; cin>>x; fw.add(i,x); }
    int q; cin>>q;
    while(q--){
        int t; cin>>t;
        if(t==1){ int pos; long long val; cin>>pos>>val; fw.add(pos,val); }
        else { int l,r; cin>>l>>r; cout<<fw.range(l,r)<<"\n"; }
    }
    return 0;
}

Pruebas
? Initialize 1..5 with 1..5, range(1,5)=15; add at pos3 +10, range(1,5)=25.
Ejercicio 123: Sparse Table — RMQ (idempotent, O(1) queries)
Análisis del Problema
 Preprocesar para consultas de mínimo en rango (sin updates).
Diseño de la Solución
 st[k][i] min of length 2^k starting at i; query uses log.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

struct SparseTable {
    vector<vector<long long>> st;
    vector<int> lg;
    SparseTable(const vector<long long>& a){
        int n=a.size(), K=__lg(n)+1;
        st.assign(K, vector<long long>(n));
        lg.assign(n+1,0);
        for(int i=2;i<=n;++i) lg[i]=lg[i/2]+1;
        st[0]=a;
        for(int k=1;k<K;++k){
            for(int i=0;i + (1<<k) <= n; ++i)
                st[k][i] = min(st[k-1][i], st[k-1][i + (1<<(k-1))]);
        }
    }
    long long query(int l,int r){
        int k = lg[r - l + 1];
        return min(st[k][l], st[k][r - (1<<k) + 1]);
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<long long> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    SparseTable st(a);
    int q; cin>>q;
    while(q--){
        int l,r; cin>>l>>r;
        cout<<st.query(l,r)<<"\n";
    }
    return 0;
}

Pruebas
? a=[1,3,2,7,9,11,3], query(1,4)=min(3,2,7,9)=2.
Ejercicio 124: Implementar Union-Find (disjoint set) con path compression & union by rank
Análisis del Problema
 Estructura para mantener particiones dinámicas.
Diseño de la Solución
 find con path compression, union by rank/size.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

struct DSU {
    vector<int> p, r;
    DSU(int n): p(n), r(n,0){ iota(p.begin(), p.end(), 0); }
    int find(int x){ return p[x]==x ? x : p[x]=find(p[x]); }
    bool unite(int a,int b){
        a=find(a); b=find(b);
        if(a==b) return false;
        if(r[a]<r[b]) swap(a,b);
        p[b]=a;
        if(r[a]==r[b]) ++r[a];
        return true;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    DSU dsu(n);
    for(int i=0;i<m;++i){
        int u,v; cin>>u>>v; dsu.unite(u,v);
    }
    int q; cin>>q;
    while(q--){
        int a,b; cin>>a>>b;
        cout << (dsu.find(a)==dsu.find(b) ? "SAME\n" : "DIFFERENT\n");
    }
    return 0;
}

Pruebas
? Crear edges, preguntar conectividad.
Ejercicio 125: Skip List — idea y plantilla básica (conceptual)
Análisis del Problema
 Estructura probabilística similar a un balanced BST para operaciones O(log n) promedio.
Diseño de la Solución
 Proveer plantilla esquemática con nivel aleatorio; implementar insert, find, erase (versión minimal).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

// Minimal illustrative skip-list node (not production-grade)
struct Node {
    int val;
    vector<Node*> next;
    Node(int v, int lvl): val(v), next(lvl, nullptr) {}
};

struct SkipList {
    Node* head;
    int maxLevel;
    double p; // probability
    SkipList(int maxL=16, double prob=0.5): maxLevel(maxL), p(prob) {
        head = new Node(INT_MIN, maxLevel);
    }
    int randomLevel(){
        int lvl=1;
        while(((double)rand()/RAND_MAX) < p && lvl < maxLevel) lvl++;
        return lvl;
    }
    bool find(int x){
        Node* cur = head;
        for(int i=maxLevel-1;i>=0;--i){
            while(cur->next[i] && cur->next[i]->val < x) cur = cur->next[i];
        }
        cur = cur->next[0];
        return cur && cur->val == x;
    }
    void insert(int x){
        vector<Node*> update(maxLevel, nullptr);
        Node* cur = head;
        for(int i=maxLevel-1;i>=0;--i){
            while(cur->next[i] && cur->next[i]->val < x) cur = cur->next[i];
            update[i] = cur;
        }
        int lvl = randomLevel();
        Node* node = new Node(x, lvl);
        for(int i=0;i<lvl;++i){
            node->next[i] = update[i]->next[i];
            update[i]->next[i] = node;
        }
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    SkipList sl;
    sl.insert(10);
    sl.insert(20);
    sl.insert(15);
    cout << sl.find(15) << ' ' << sl.find(7) << '\n';
    return 0;
}

Pruebas
? Inserta 10,20,15 -> find(15)=1, find(7)=0.
Ejercicio 126: Implementar Bloom Filter simple (probabilístico)
Análisis del Problema
 Estructura probabilística para test membership con falsos positivos posibles.
Diseño de la Solución
 Bitset + múltiples hashes (usaremos std::hash with salts).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

struct Bloom {
    vector<bool> bits;
    int m, k;
    Bloom(int m_, int k_): m(m_), k(k_), bits(m_) {}
    void add(const string &s){
        for(int i=0;i<k;++i){
            size_t h = hash<string>{}(s + to_string(i));
            bits[h % m] = true;
        }
    }
    bool possiblyContains(const string &s){
        for(int i=0;i<k;++i){
            size_t h = hash<string>{}(s + to_string(i));
            if(!bits[h % m]) return false;
        }
        return true;
    }
};

int main(){
    Bloom b(1000, 3);
    b.add("hello");
    cout << b.possiblyContains("hello") << '\n'; // likely 1
    cout << b.possiblyContains("world") << '\n'; // likely 0 (could be 1 due to FP)
    return 0;
}

Pruebas
? hello -> true; world usually false.
Ejercicio 127: Persistent Segment Tree (concepto sencillo — point update persistent)
Análisis del Problema
 Permitir versiones del segment tree después de updates (cada update crea nueva raíz compartir nodos inmutables).
Diseño de la Solución
 Nodo con left/right pointers; update returns new root copying path.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
struct Node {
    int val;
    Node *l, *r;
    Node(int v=0): val(v), l(nullptr), r(nullptr) {}
};
Node* build(int tl, int tr){
    Node* node = new Node();
    if(tl==tr) return node;
    int tm=(tl+tr)/2;
    node->l = build(tl, tm);
    node->r = build(tm+1, tr);
    return node;
}
Node* update(Node* v, int tl, int tr, int pos, int val){
    Node* node = new Node();
    *node = *v; // copy
    if(tl==tr){ node->val = val; return node; }
    int tm=(tl+tr)/2;
    if(pos<=tm) node->l = update(v->l, tl, tm, pos, val);
    else node->r = update(v->r, tm+1, tr, pos, val);
    node->val = (node->l?node->l->val:0) + (node->r?node->r->val:0);
    return node;
}
int query(Node* v, int tl, int tr, int l, int r){
    if(!v || r<tl || tr<l) return 0;
    if(l<=tl && tr<=r) return v->val;
    int tm=(tl+tr)/2;
    return query(v->l, tl, tm, l, r) + query(v->r, tm+1, tr, l, r);
}

int main(){
    int n = 5; // example fixed
    auto root0 = build(0,n-1);
    auto root1 = update(root0,0,n-1,2,10); // version 1 set pos2=10
    cout << query(root0,0,n-1,0,4) << '\n'; // 0
    cout << query(root1,0,n-1,0,4) << '\n'; // 10
    return 0;
}

Pruebas
? Builds base root0, root1 updated; query differences show persistence.

Ejercicio 128: K-d Tree básico (insert + nearest neighbor search skeleton)
Análisis del Problema
 Estructura para búsquedas k-NN en 2D (here: nearest neighbor).
Diseño de la Solución
 Recursive split by axis, track best distance.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
struct Pt { double x,y; };
struct KDNode {
    Pt p; KDNode *l=nullptr, *r=nullptr;
    KDNode(Pt pt): p(pt) {}
};

KDNode* build(vector<Pt>& pts, int l, int r, int depth){
    if(l>r) return nullptr;
    int axis = depth%2;
    int m = (l+r)/2;
    nth_element(pts.begin()+l, pts.begin()+m, pts.begin()+r+1, [&](const Pt &a,const Pt &b){
        return axis==0? a.x < b.x : a.y < b.y;
    });
    KDNode* node = new KDNode(pts[m]);
    node->l = build(pts, l, m-1, depth+1);
    node->r = build(pts, m+1, r, depth+1);
    return node;
}

double dist2(const Pt&a,const Pt&b){ double dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

void nn_search(KDNode* node, const Pt& target, int depth, Pt& best, double& bestd){
    if(!node) return;
    double d = dist2(node->p, target);
    if(d < bestd){ bestd = d; best = node->p; }
    int axis = depth%2;
    double diff = (axis==0 ? target.x - node->p.x : target.y - node->p.y);
    KDNode *first = diff < 0 ? node->l : node->r;
    KDNode *second = diff < 0 ? node->r : node->l;
    nn_search(first, target, depth+1, best, bestd);
    if(diff*diff < bestd) nn_search(second, target, depth+1, best, bestd);
}

int main(){
    vector<Pt> pts = {{0,0},{1,2},{3,1},{-1,-2},{2,2}};
    KDNode* root = build(pts, 0, pts.size()-1, 0);
    Pt target{1.1, 1.9}, best{0,0}; double bestd = 1e100;
    nn_search(root, target, 0, best, bestd);
    cout << "Nearest: " << best.x << "," << best.y << "\n";
    return 0;
}

Pruebas
? Target near (1,2) should find (1,2) or nearby.

Ejercicio 129: Rolling Hash (Rabin-Karp) para búsqueda de patrón
Análisis del Problema
 Encontrar ocurrencias de un patrón P en texto T eficientemente.
Diseño de la Solución
 Usar base B y modulo grande MOD, calcular hash de ventanas.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
using ull = unsigned long long;

vector<int> rabin_karp(const string &t, const string &p){
    int n=t.size(), m=p.size();
    if(m>n) return {};
    const ull B = 1315423911ULL; // use ull rolling (no modulo) or choose prime
    ull hp=0, ht=0, powB=1;
    for(int i=0;i<m;++i){ hp = hp*B + (unsigned char)p[i]; ht = ht*B + (unsigned char)t[i]; if(i) powB *= B; }
    vector<int> res;
    if(hp==ht) res.push_back(0);
    for(int i=m;i<n;++i){
        ht = ht - powB * (unsigned char)t[i-m];
        ht = ht*B + (unsigned char)t[i];
        if(ht==hp) res.push_back(i-m+1);
    }
    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string t,p; if(!(cin>>t>>p)) return 0;
    auto occ = rabin_karp(t,p);
    for(int i: occ) cout << i << ' ';
    cout << '\n';
    return 0;
}

Pruebas
? t="abracadabra", p="abra" -> positions 0 and 7.
Ejercicio 130: Construcción de DFA mínimo a partir de un conjunto de patrones (Aho-Corasick skeleton + minimize idea)
Análisis del Problema
 Construir automata para múltiples patrones y buscar todas las ocurrencias en texto (Aho-Corasick). Minimización de DFA es más complejo; aquí implementamos Aho-Corasick.
Diseño de la Solución
 Trie + failure links + output lists.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

struct Aho {
    struct Node {
        array<int,26> next;
        int link = -1;
        vector<int> out;
        Node(){ next.fill(-1); }
    };
    vector<Node> trie;
    Aho(){ trie.emplace_back(); }
    void add(const string &s, int id){
        int v = 0;
        for(char ch: s){
            int c = ch - 'a';
            if(trie[v].next[c] == -1){ trie[v].next[c] = trie.size(); trie.emplace_back(); }
            v = trie[v].next[c];
        }
        trie[v].out.push_back(id);
    }
    void build(){
        queue<int> q;
        trie[0].link = 0;
        for(int c=0;c<26;++c){
            int v = trie[0].next[c];
            if(v != -1){ trie[v].link = 0; q.push(v); }
            else trie[0].next[c] = 0;
        }
        while(!q.empty()){
            int v=q.front(); q.pop();
            for(int c=0;c<26;++c){
                int u = trie[v].next[c];
                if(u != -1){
                    trie[u].link = trie[trie[v].link].next[c];
                    for(int x: trie[trie[u].link].out) trie[u].out.push_back(x);
                    q.push(u);
                } else {
                    trie[v].next[c] = trie[trie[v].link].next[c];
                }
            }
        }
    }
    vector<vector<int>> searchAll(const string &t){
        vector<vector<int>> res;
        int v=0;
        for(int i=0;i<(int)t.size();++i){
            int c = t[i]-'a';
            v = trie[v].next[c];
            if(!trie[v].out.empty()){
                for(int id: trie[v].out) res.push_back({id, i});
            }
        }
        return res;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int k; if(!(cin>>k)) return 0;
    Aho aho;
    for(int i=0;i<k;++i){ string s; cin>>s; aho.add(s,i); }
    aho.build();
    string text; cin>>text;
    auto occ = aho.searchAll(text);
    for(auto &v: occ) cout << "pattern_id=" << v[0] << " pos=" << v[1] << '\n';
    return 0;
}

Pruebas
? patterns he she his hers, text ushers should show matches accordingly (indexing and positions as implemented).
Ejercicio 131: Dijkstra con priority_queue (camino más corto en grafo ponderado positivo)
Análisis del Problema
 Encontrar el camino más corto desde un nodo origen a todos los demás en un grafo con pesos positivos.
Diseño de la Solución
 Usar una cola de prioridad (min-heap) para seleccionar el vértice con menor distancia provisional.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

struct Edge { int to, w; };

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m; cin >> n >> m;
    vector<vector<Edge>> g(n);
    for (int i = 0; i < m; ++i) {
        int u, v, w; cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w}); // no dirigido
    }
    int s; cin >> s;
    const int INF = 1e9;
    vector<int> dist(n, INF);
    dist[s] = 0;
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    pq.push({0, s});
    while (!pq.empty()) {
        auto [d,u] = pq.top(); pq.pop();
        if (d != dist[u]) continue;
        for (auto &e : g[u]) {
            if (dist[e.to] > d + e.w) {
                dist[e.to] = d + e.w;
                pq.push({dist[e.to], e.to});
            }
        }
    }
    for (int i = 0; i < n; ++i)
        cout << "Distancia a " << i << ": " << dist[i] << "\n";
}

Pruebas
Entrada:

 5 6
0 1 2
0 2 4
1 2 1
1 3 7
2 4 3
3 4 1
0
? 
Salida esperada:

 Distancia a 0: 0
Distancia a 1: 2
Distancia a 2: 3
Distancia a 3: 7
Distancia a 4: 6
 Ejercicio 132: Floyd–Warshall (todas las parejas de caminos más cortos)
Análisis del Problema
 Calcular la distancia mínima entre cada par de nodos en un grafo.
Diseño de la Solución
 Usar matriz dist[i][j] y actualizar:
 dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,m; cin >> n >> m;
    const int INF = 1e9;
    vector<vector<int>> dist(n, vector<int>(n, INF));
    for(int i=0;i<n;++i) dist[i][i]=0;
    for(int i=0;i<m;++i){
        int u,v,w; cin >> u >> v >> w;
        dist[u][v]=w;
    }
    for(int k=0;k<n;++k)
        for(int i=0;i<n;++i)
            for(int j=0;j<n;++j)
                if(dist[i][k]<INF && dist[k][j]<INF)
                    dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
    for(int i=0;i<n;++i){
        for(int j=0;j<n;++j)
            cout << (dist[i][j]==INF? -1 : dist[i][j]) << " ";
        cout << "\n";
    }
}

Pruebas
? Grafo con 4 nodos y aristas dirigidas.
 Ejercicio 133: Bellman–Ford (detección de ciclos negativos)
Análisis del Problema
 Detectar si un grafo tiene un ciclo de peso negativo y calcular distancias.
Diseño de la Solución
 Relaxar todas las aristas N?1 veces; si en una iteración adicional mejora una distancia, hay ciclo negativo.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

struct Edge { int u,v,w; };

int main(){
    int n,m; cin>>n>>m;
    vector<Edge> edges(m);
    for(auto &e: edges) cin>>e.u>>e.v>>e.w;
    vector<long long> dist(n, 1e18);
    int s; cin>>s;
    dist[s]=0;
    for(int i=0;i<n-1;++i)
        for(auto &e: edges)
            if(dist[e.u]<1e18 && dist[e.v]>dist[e.u]+e.w)
                dist[e.v]=dist[e.u]+e.w;
    bool neg=false;
    for(auto &e: edges)
        if(dist[e.u]<1e18 && dist[e.v]>dist[e.u]+e.w) neg=true;
    cout<<(neg?"CICLO NEGATIVO":"OK")<<"\n";
    for(int i=0;i<n;++i) cout<<dist[i]<<" ";
}

Pruebas
? Grafo sin ciclo ? “OK”;

? Grafo con ciclo negativo ? “CICLO NEGATIVO”.
 Ejercicio 134: Topological Sort con DFS
Análisis del Problema
 Ordenar los vértices de un grafo dirigido acíclico (DAG).
Diseño de la Solución
 Usar DFS con pila de salida.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> g;
vector<int> vis, order;

void dfs(int u){
    vis[u]=1;
    for(int v:g[u]) if(!vis[v]) dfs(v);
    order.push_back(u);
}

int main(){
    int n,m; cin>>n>>m;
    g.resize(n);
    for(int i=0;i<m;++i){int u,v;cin>>u>>v;g[u].push_back(v);}
    vis.assign(n,0);
    for(int i=0;i<n;++i) if(!vis[i]) dfs(i);
    reverse(order.begin(), order.end());
    for(int x:order) cout<<x<<" ";
}

Pruebas
? Entrada: DAG con 6 vértices, imprime orden topológico válido.
 Ejercicio 135: Detectar ciclo en grafo dirigido (DFS con pila de recursion)
Análisis del Problema
 Verificar si un grafo dirigido contiene un ciclo.
Diseño de la Solución
 DFS con colores (0=no visitado,1=visitando,2=visitado).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
vector<vector<int>> g;
vector<int> state;
bool has_cycle=false;

void dfs(int u){
    state[u]=1;
    for(int v:g[u]){
        if(state[v]==0) dfs(v);
        else if(state[v]==1) has_cycle=true;
    }
    state[u]=2;
}

int main(){
    int n,m;cin>>n>>m;
    g.resize(n);
    for(int i=0;i<m;++i){int u,v;cin>>u>>v;g[u].push_back(v);}
    state.assign(n,0);
    for(int i=0;i<n;++i) if(!state[i]) dfs(i);
    cout<<(has_cycle?"CICLO":"NO CICLO")<<"\n";
}

Pruebas
? Ciclo 0?1?2?0 ? “CICLO”.
 Ejercicio 136: Ordenamiento topológico usando Kahn's Algorithm (BFS)
Análisis del Problema
 Ordenar nodos de DAG usando grados de entrada y cola.
Diseño de la Solución
 Contar indegree, agregar a cola los de indegree 0, ir eliminando.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,m;cin>>n>>m;
    vector<vector<int>> g(n);
    vector<int> indeg(n);
    for(int i=0;i<m;++i){int u,v;cin>>u>>v;g[u].push_back(v);indeg[v]++;}
    queue<int> q;
    for(int i=0;i<n;++i) if(indeg[i]==0) q.push(i);
    vector<int> order;
    while(!q.empty()){
        int u=q.front();q.pop();
        order.push_back(u);
        for(int v:g[u]) if(--indeg[v]==0) q.push(v);
    }
    for(int x:order) cout<<x<<" ";
}

Pruebas
? DAG simple con dependencias produce orden válido.
 Ejercicio 137: Kruskal — Árbol de Expansión Mínima (MST)
Análisis del Problema
 Encontrar el costo mínimo de conectar todos los nodos con aristas ponderadas.
Diseño de la Solución
 Ordenar aristas por peso y usar Union-Find para evitar ciclos.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

struct Edge{int u,v,w;};
struct DSU{
    vector<int> p;
    DSU(int n){p.resize(n);iota(p.begin(),p.end(),0);}
    int find(int x){return p[x]==x?x:p[x]=find(p[x]);}
    bool unite(int a,int b){a=find(a);b=find(b);if(a==b)return false;p[b]=a;return true;}
};

int main(){
    int n,m;cin>>n>>m;
    vector<Edge> e(m);
    for(auto &x:e)cin>>x.u>>x.v>>x.w;
    sort(e.begin(),e.end(),[](auto&a,auto&b){return a.w<b.w;});
    DSU d(n);
    int total=0;
    for(auto &x:e)if(d.unite(x.u,x.v)) total+=x.w;
    cout<<"Costo MST: "<<total<<"\n";
}

Pruebas
? Pequeño grafo ? imprime costo total.

 Ejercicio 138: Prim (MST) con priority_queue
Análisis del Problema
 Construir un MST desde cualquier nodo usando heap mínimo.
Diseño de la Solución
 Agregar aristas accesibles, tomar la menor no visitada.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,m;cin>>n>>m;
    vector<vector<pair<int,int>>> g(n);
    for(int i=0;i<m;++i){int u,v,w;cin>>u>>v>>w;g[u].push_back({v,w});g[v].push_back({u,w});}
    vector<int> vis(n);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    pq.push({0,0});
    int total=0;
    while(!pq.empty()){
        auto [w,u]=pq.top();pq.pop();
        if(vis[u])continue;
        vis[u]=1;total+=w;
        for(auto [v,wt]:g[u]) if(!vis[v]) pq.push({wt,v});
    }
    cout<<"Costo MST: "<<total<<"\n";
}
 Ejercicio 139: Caminos más cortos con BFS en grafo no ponderado
Análisis del Problema
 Calcular distancias mínimas (en número de aristas) desde un nodo fuente.
Diseño de la Solución
 Usar cola (queue) BFS tradicional.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,m;cin>>n>>m;
    vector<vector<int>> g(n);
    for(int i=0;i<m;++i){int u,v;cin>>u>>v;g[u].push_back(v);g[v].push_back(u);}
    int s;cin>>s;
    vector<int> dist(n,-1);
    queue<int> q;q.push(s);dist[s]=0;
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int v:g[u]) if(dist[v]==-1){
            dist[v]=dist[u]+1;
            q.push(v);
        }
    }
    for(int i=0;i<n;++i) cout<<dist[i]<<" ";
}
 Ejercicio 140: Floyd–Warshall con reconstrucción de camino
Análisis del Problema
 Guardar predecesores para reconstruir el camino mínimo entre dos nodos.
Diseño de la Solución
 Matriz next[i][j] que almacena el siguiente nodo en el camino.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,m;cin>>n>>m;
    const int INF=1e9;
    vector<vector<int>> dist(n, vector<int>(n,INF)), nxt(n, vector<int>(n,-1));
    for(int i=0;i<n;++i) dist[i][i]=0;
    for(int i=0;i<m;++i){
        int u,v,w;cin>>u>>v>>w;
        dist[u][v]=w; nxt[u][v]=v;
    }
    for(int k=0;k<n;++k)
        for(int i=0;i<n;++i)
            for(int j=0;j<n;++j)
                if(dist[i][k]+dist[k][j]<dist[i][j]){
                    dist[i][j]=dist[i][k]+dist[k][j];
                    nxt[i][j]=nxt[i][k];
                }
    int u,v;cin>>u>>v;
    if(nxt[u][v]==-1){cout<<"No path\n";return 0;}
    vector<int> path={u};
    while(u!=v){u=nxt[u][v];path.push_back(u);}
    for(int x:path) cout<<x<<" ";
}
 Ejercicio 141: Camino más corto con obstáculos (BFS en matriz)
Análisis del Problema
 Encontrar la distancia mínima en una cuadrícula con celdas bloqueadas.
Diseño de la Solución
 BFS con movimientos 4-direccionales validando límites y obstáculos.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,m;cin>>n>>m;
    vector<string> grid(n);
    for(auto &s:grid)cin>>s;
    int sx,sy,ex,ey;cin>>sx>>sy>>ex>>ey;
    vector<vector<int>> dist(n,vector<int>(m,-1));
    queue<pair<int,int>> q;
    q.push({sx,sy});
    dist[sx][sy]=0;
    int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};
    while(!q.empty()){
        auto [x,y]=q.front();q.pop();
        for(int i=0;i<4;++i){
            int nx=x+dx[i], ny=y+dy[i];
            if(nx<0||ny<0||nx>=n||ny>=m||grid[nx][ny]=='#'||dist[nx][ny]!=-1) continue;
            dist[nx][ny]=dist[x][y]+1;
            q.push({nx,ny});
        }
    }
    cout<<dist[ex][ey]<<"\n";
}
 Ejercicio 142: Detectar componentes conexas (DFS)
Análisis del Problema
 Contar cuántas componentes hay en un grafo no dirigido.
Diseño de la Solución
 DFS para marcar visitados y contar cuántas veces se llama desde un nodo no visitado.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;
vector<vector<int>> g;
vector<int> vis;
void dfs(int u){vis[u]=1;for(int v:g[u])if(!vis[v])dfs(v);}
int main(){
    int n,m;cin>>n>>m;
    g.resize(n);
    for(int i=0;i<m;++i){int u,v;cin>>u>>v;g[u].push_back(v);g[v].push_back(u);}
    vis.assign(n,0);
    int comps=0;
    for(int i=0;i<n;++i) if(!vis[i]){dfs(i);comps++;}
    cout<<"Componentes: "<<comps<<"\n";
}
 Ejercicio 143: Ordenar lista enlazada simple
Análisis del Problema
 Ordenar lista enlazada implementando Merge Sort.
Diseño de la Solución
 Dividir lista en mitades y fusionarlas recursivamente.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

struct Node{int val;Node*next;Node(int v):val(v),next(nullptr){}};

Node* mergeList(Node*a,Node*b){
    if(!a) return b; if(!b) return a;
    if(a->val<b->val){a->next=mergeList(a->next,b);return a;}
    else {b->next=mergeList(a,b->next);return b;}
}

Node* mergeSort(Node*head){
    if(!head||!head->next)return head;
    Node*slow=head;Node*fast=head->next;
    while(fast&&fast->next){slow=slow->next;fast=fast->next->next;}
    Node*mid=slow->next;slow->next=nullptr;
    Node*l=mergeSort(head),*r=mergeSort(mid);
    return mergeList(l,r);
}

int main(){
    Node*a=new Node(3);a->
Ejercicio 144: Búsqueda binaria en un vector de pares (clave, valor)
Análisis del Problema
 Dado un vector de pares (clave, valor) ordenado por la clave, se desea buscar una clave específica y devolver su valor asociado.
Diseño de la Solución
 Usar std::binary_search y std::lower_bound para encontrar el índice exacto del par que contiene la clave buscada.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n; cin >> n;
    vector<pair<int, string>> data(n);
    for (int i = 0; i < n; ++i)
        cin >> data[i].first >> data[i].second;
    sort(data.begin(), data.end());
    int key; cin >> key;

    auto it = lower_bound(data.begin(), data.end(), make_pair(key, string("")));
    if (it != data.end() && it->first == key)
        cout << "Valor encontrado: " << it->second << '\n';
    else
        cout << "Clave no encontrada\n";
}

Pruebas
Entrada:

 3
10 perro
20 gato
30 pez
20
? 
? Salida: Valor encontrado: gato
 Ejercicio 145: Calcular la moda de una lista de números
Análisis del Problema
 Determinar el número que aparece con mayor frecuencia en una lista.
Diseño de la Solución
 Usar std::map<int,int> para contar las frecuencias y luego seleccionar la clave con mayor valor.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n; cin >> n;
    map<int,int> freq;
    for (int i=0;i<n;++i){
        int x; cin >> x;
        freq[x]++;
    }
    int moda=-1, maxf=0;
    for(auto &[num, f]:freq)
        if(f>maxf) maxf=f, moda=num;
    cout << "Moda: " << moda << " (frecuencia " << maxf << ")\n";
}

Pruebas
? Entrada: 7\n1 2 2 3 3 3 4

? Salida: Moda: 3 (frecuencia 3)
 Ejercicio 146: Buscar el elemento más cercano a un valor dado
Análisis del Problema
 En un vector ordenado, hallar el elemento cuyo valor sea más cercano a un número x.
Diseño de la Solución
 Usar lower_bound para encontrar el primer elemento ? x, y comparar con el anterior.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,x; cin >> n;
    vector<int> v(n);
    for (int i=0;i<n;++i) cin >> v[i];
    sort(v.begin(), v.end());
    cin >> x;

    auto it = lower_bound(v.begin(), v.end(), x);
    if(it == v.begin()) cout << *it;
    else if(it == v.end()) cout << v.back();
    else {
        int a = *(it-1), b = *it;
        cout << (abs(a-x) <= abs(b-x) ? a : b);
    }
}

Pruebas
Entrada:

 5
1 5 8 10 12
9
? 
? Salida: 8
 Ejercicio 147: Encontrar subarray con suma máxima (Kadane’s Algorithm)
Análisis del Problema
 Dado un vector de enteros (pueden ser negativos), hallar el subarray con la mayor suma posible.
Diseño de la Solución
 Usar Kadane: recorrer el arreglo acumulando suma, reiniciando si la suma cae por debajo de cero.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n; cin >> n;
    vector<int> v(n);
    for(int i=0;i<n;++i) cin >> v[i];
    int best=v[0], curr=0;
    for(int x:v){
        curr = max(x, curr+x);
        best = max(best, curr);
    }
    cout << "Suma máxima: " << best << '\n';
}

Pruebas
? Entrada: 8\n-2 1 -3 4 -1 2 1 -5 4

? Salida: Suma máxima: 6 (subarray [4,-1,2,1])
 Ejercicio 148: Calcular la mediana de un vector
Análisis del Problema
 Hallar la mediana (valor central) de un conjunto de números.
Diseño de la Solución
 Ordenar el vector y devolver el elemento medio (o promedio de los dos centrales si n es par).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n; cin >> n;
    vector<double> v(n);
    for(double &x:v) cin >> x;
    sort(v.begin(), v.end());
    double med = (n%2 ? v[n/2] : (v[n/2-1]+v[n/2])/2.0);
    cout << "Mediana: " << fixed << setprecision(2) << med << "\n";
}

Pruebas
? Entrada: 5\n1 3 2 5 4 ? Salida: Mediana: 3.00

? Entrada: 4\n10 20 30 40 ? Mediana: 25.00
 Ejercicio 149: Contar inversions (pares desordenados) con Merge Sort
Análisis del Problema
 Contar cuántos pares (i,j) existen con i < j y a[i] > a[j].
Diseño de la Solución
 Usar Merge Sort modificando el merge para contar las inversiones cruzadas.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

long long merge_count(vector<int>& a, int l, int r){
    if(l >= r) return 0;
    int m = (l+r)/2;
    long long inv = merge_count(a,l,m) + merge_count(a,m+1,r);
    vector<int> temp; int i=l,j=m+1;
    while(i<=m && j<=r){
        if(a[i]<=a[j]) temp.push_back(a[i++]);
        else { temp.push_back(a[j++]); inv += (m-i+1); }
    }
    while(i<=m) temp.push_back(a[i++]);
    while(j<=r) temp.push_back(a[j++]);
    copy(temp.begin(),temp.end(),a.begin()+l);
    return inv;
}

int main(){
    int n; cin >> n;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin >> a[i];
    cout << "Inversiones: " << merge_count(a,0,n-1) << "\n";
}

Pruebas
? Entrada: 5\n2 4 1 3 5

? Salida: Inversiones: 3
Ejercicio 150: Rotar un vector k posiciones a la derecha
Análisis del Problema
 Desplazar todos los elementos de un vector hacia la derecha k posiciones.
Diseño de la Solución
 Usar std::rotate o reversas parciales:
1. Invertir todo.

2. Invertir primeros k.

3. Invertir los restantes.

Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,k; cin>>n>>k;
    vector<int> v(n);
    for(int i=0;i<n;++i) cin>>v[i];
    k %= n;
    reverse(v.begin(),v.end());
    reverse(v.begin(),v.begin()+k);
    reverse(v.begin()+k,v.end());
    for(int x:v) cout<<x<<" ";
}

Pruebas
? Entrada: 5\n1 2 3 4 5\n2

? Salida: 4 5 1 2 3
 Ejercicio 151: Calcular número de caminos en una cuadrícula (DP)
Análisis del Problema
 En una cuadrícula m x n, calcular cuántas rutas existen desde la esquina superior izquierda hasta la inferior derecha moviéndose solo hacia la derecha o abajo.
Diseño de la Solución
 Usar programación dinámica:
 dp[i][j] = dp[i-1][j] + dp[i][j-1].
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int m,n; cin>>m>>n;
    vector<vector<long long>> dp(m, vector<long long>(n,1));
    for(int i=1;i<m;++i)
        for(int j=1;j<n;++j)
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
    cout<<"Número de caminos: "<<dp[m-1][n-1]<<"\n";
}
Pruebas
? Entrada: 3 3

? Salida: Número de caminos: 6
Ejercicio 151: Búsqueda binaria en un vector de pares (clave, valor)
Análisis del Problema
 Dado un vector de pares (clave, valor) ordenado por la clave, se desea buscar una clave específica y devolver su valor asociado.
Diseño de la Solución
 Usar std::binary_search y std::lower_bound para encontrar el índice exacto del par que contiene la clave buscada.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n; cin >> n;
    vector<pair<int, string>> data(n);
    for (int i = 0; i < n; ++i)
        cin >> data[i].first >> data[i].second;
    sort(data.begin(), data.end());
    int key; cin >> key;

    auto it = lower_bound(data.begin(), data.end(), make_pair(key, string("")));
    if (it != data.end() && it->first == key)
        cout << "Valor encontrado: " << it->second << '\n';
    else
        cout << "Clave no encontrada\n";
}

Pruebas
Entrada:

 3
10 perro
20 gato
30 pez
20
? 
? Salida: Valor encontrado: gato
 Ejercicio 152: Calcular la moda de una lista de números
Análisis del Problema
 Determinar el número que aparece con mayor frecuencia en una lista.
Diseño de la Solución
 Usar std::map<int,int> para contar las frecuencias y luego seleccionar la clave con mayor valor.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n; cin >> n;
    map<int,int> freq;
    for (int i=0;i<n;++i){
        int x; cin >> x;
        freq[x]++;
    }
    int moda=-1, maxf=0;
    for(auto &[num, f]:freq)
        if(f>maxf) maxf=f, moda=num;
    cout << "Moda: " << moda << " (frecuencia " << maxf << ")\n";
}

Pruebas
? Entrada: 7\n1 2 2 3 3 3 4

? Salida: Moda: 3 (frecuencia 3)
 Ejercicio 153: Buscar el elemento más cercano a un valor dado
Análisis del Problema
 En un vector ordenado, hallar el elemento cuyo valor sea más cercano a un número x.
Diseño de la Solución
 Usar lower_bound para encontrar el primer elemento ? x, y comparar con el anterior.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,x; cin >> n;
    vector<int> v(n);
    for (int i=0;i<n;++i) cin >> v[i];
    sort(v.begin(), v.end());
    cin >> x;

    auto it = lower_bound(v.begin(), v.end(), x);
    if(it == v.begin()) cout << *it;
    else if(it == v.end()) cout << v.back();
    else {
        int a = *(it-1), b = *it;
        cout << (abs(a-x) <= abs(b-x) ? a : b);
    }
}

Pruebas
Entrada:

 5
1 5 8 10 12
9
? 
? Salida: 8
Ejercicio 154: Encontrar subarray con suma máxima (Kadane’s Algorithm)
Análisis del Problema
 Dado un vector de enteros (pueden ser negativos), hallar el subarray con la mayor suma posible.
Diseño de la Solución
 Usar Kadane: recorrer el arreglo acumulando suma, reiniciando si la suma cae por debajo de cero.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n; cin >> n;
    vector<int> v(n);
    for(int i=0;i<n;++i) cin >> v[i];
    int best=v[0], curr=0;
    for(int x:v){
        curr = max(x, curr+x);
        best = max(best, curr);
    }
    cout << "Suma máxima: " << best << '\n';
}

Pruebas
? Entrada: 8\n-2 1 -3 4 -1 2 1 -5 4

? Salida: Suma máxima: 6 (subarray [4,-1,2,1])
 Ejercicio 155: Calcular la mediana de un vector
Análisis del Problema
 Hallar la mediana (valor central) de un conjunto de números.
Diseño de la Solución
 Ordenar el vector y devolver el elemento medio (o promedio de los dos centrales si n es par).
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n; cin >> n;
    vector<double> v(n);
    for(double &x:v) cin >> x;
    sort(v.begin(), v.end());
    double med = (n%2 ? v[n/2] : (v[n/2-1]+v[n/2])/2.0);
    cout << "Mediana: " << fixed << setprecision(2) << med << "\n";
}

Pruebas
? Entrada: 5\n1 3 2 5 4 ? Salida: Mediana: 3.00

? Entrada: 4\n10 20 30 40 ? Mediana: 25.00
 Ejercicio 156: Contar inversions (pares desordenados) con Merge Sort
Análisis del Problema
 Contar cuántos pares (i,j) existen con i < j y a[i] > a[j].
Diseño de la Solución
 Usar Merge Sort modificando el merge para contar las inversiones cruzadas.
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

long long merge_count(vector<int>& a, int l, int r){
    if(l >= r) return 0;
    int m = (l+r)/2;
    long long inv = merge_count(a,l,m) + merge_count(a,m+1,r);
    vector<int> temp; int i=l,j=m+1;
    while(i<=m && j<=r){
        if(a[i]<=a[j]) temp.push_back(a[i++]);
        else { temp.push_back(a[j++]); inv += (m-i+1); }
    }
    while(i<=m) temp.push_back(a[i++]);
    while(j<=r) temp.push_back(a[j++]);
    copy(temp.begin(),temp.end(),a.begin()+l);
    return inv;
}

int main(){
    int n; cin >> n;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin >> a[i];
    cout << "Inversiones: " << merge_count(a,0,n-1) << "\n";
}

Pruebas
? Entrada: 5\n2 4 1 3 5

? Salida: Inversiones: 3
 Ejercicio 157: Rotar un vector k posiciones a la derecha
Análisis del Problema
 Desplazar todos los elementos de un vector hacia la derecha k posiciones.
Diseño de la Solución
 Usar std::rotate o reversas parciales:
1. Invertir todo.

2. Invertir primeros k.

3. Invertir los restantes.

Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,k; cin>>n>>k;
    vector<int> v(n);
    for(int i=0;i<n;++i) cin>>v[i];
    k %= n;
    reverse(v.begin(),v.end());
    reverse(v.begin(),v.begin()+k);
    reverse(v.begin()+k,v.end());
    for(int x:v) cout<<x<<" ";
}

Pruebas
? Entrada: 5\n1 2 3 4 5\n2

? Salida: 4 5 1 2 3
 Ejercicio 158: Calcular número de caminos en una cuadrícula (DP)
Análisis del Problema
 En una cuadrícula m x n, calcular cuántas rutas existen desde la esquina superior izquierda hasta la inferior derecha moviéndose solo hacia la derecha o abajo.
Diseño de la Solución
 Usar programación dinámica:
 dp[i][j] = dp[i-1][j] + dp[i][j-1].
Código Fuente (C++)
#include <bits/stdc++.h>
using namespace std;

int main(){
    int m,n; cin>>m>>n;
    vector<vector<long long>> dp(m, vector<long long>(n,1));
    for(int i=1;i<m;++i)
        for(int j=1;j<n;++j)
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
    cout<<"Número de caminos: "<<dp[m-1][n-1]<<"\n";
}

Pruebas
? Entrada: 3 3

? Salida: Número de caminos: 6
Ejercicio 158: Búsqueda binaria en vector de pares (clave, valor)
Análisis
 Buscar una clave en vector de pair<int,string> ordenado por clave y devolver el valor.
Diseño
 lower_bound por make_pair(key, "").
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<pair<int,string>> v(n);
    for(int i=0;i<n;++i) cin>>v[i].first>>v[i].second;
    sort(v.begin(), v.end());
    int key; cin>>key;
    auto it = lower_bound(v.begin(), v.end(), make_pair(key, string("")));
    if(it!=v.end() && it->first==key) cout<<it->second<<"\n";
    else cout<<"NO\n";
}

Prueba
Entrada:

 3
10 perro
20 gato
30 pez
20
?  Salida: gato
Ejercicio 159: Moda de una lista (frecuencia máxima)
Análisis
 Encontrar número con mayor frecuencia.
Diseño
 Contar con unordered_map<int,int> y elegir máximo.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    unordered_map<int,int> f;
    for(int i=0;i<n;++i){ int x; cin>>x; f[x]++; }
    int mode=0, mf=0;
    for(auto &p:f) if(p.second>mf){ mf=p.second; mode=p.first; }
    cout<<mode<<" "<<mf<<"\n";
}

Prueba
? Entrada: 7 1 2 2 3 3 3 4 ? Salida: 3 3
Ejercicio 160: Elemento más cercano a x (array ordenado)
Análisis
 Dado ordenado, hallar elemento con mínima diferencia absoluta.
Diseño
 lower_bound y comparar con anterior.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n); for(int i=0;i<n;++i) cin>>a[i];
    sort(a.begin(), a.end());
    int x; cin>>x;
    auto it=lower_bound(a.begin(), a.end(), x);
    if(it==a.begin()) cout<<*it<<"\n";
    else if(it==a.end()) cout<<a.back()<<"\n";
    else {
        int a1=*(it-1), a2=*it;
        cout<< (abs(a1-x)<=abs(a2-x) ? a1 : a2) <<"\n";
    }
}

Prueba
Entrada:

 5
1 5 8 10 12
9
?  Salida: 8
Ejercicio 161: Kadane (subarray suma máxima)
Análisis
 Encontrar suma máxima contigua.
Diseño
 Kadane iterativo, también recuperar subarray si se desea.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<long long> a(n); for(int i=0;i<n;++i) cin>>a[i];
    long long best = a[0], cur = 0;
    for(long long v: a){ cur = max(v, cur+v); best = max(best, cur); }
    cout<<best<<"\n";
}

Prueba
? Entrada: 9 -2 1 -3 4 -1 2 1 -5 4 ? Salida: 6
Ejercicio 162: Mediana de un vector
Análisis
 Calcular mediana (si n par -> promedio de dos centrales).
Diseño
 Ordenar y devolver.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<double> a(n); for(int i=0;i<n;++i) cin>>a[i];
    sort(a.begin(), a.end());
    if(n%2) cout<<a[n/2]<<"\n"; else cout<<((a[n/2-1]+a[n/2])/2.0)<<"\n";
}

Prueba
? Entrada: 4 10 20 30 40 ? Salida: 25
Ejercicio 163: Contar inversiones (Merge Sort)
Análisis
 Número de pares (i<j, a[i]>a[j]).
Diseño
 Merge count O(n log n).
Código
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
ll merge_count(vector<int>& a, int l, int r){
    if(l>=r) return 0;
    int m=(l+r)/2; ll cnt=merge_count(a,l,m)+merge_count(a,m+1,r);
    vector<int> tmp; int i=l,j=m+1;
    while(i<=m && j<=r){
        if(a[i]<=a[j]) tmp.push_back(a[i++]);
        else { tmp.push_back(a[j++]); cnt += (m - i + 1); }
    }
    while(i<=m) tmp.push_back(a[i++]);
    while(j<=r) tmp.push_back(a[j++]);
    copy(tmp.begin(), tmp.end(), a.begin()+l);
    return cnt;
}
int main(){ int n; if(!(cin>>n)) return 0; vector<int>a(n); for(int i=0;i<n;++i)cin>>a[i]; cout<<merge_count(a,0,n-1)<<"\n";}

Prueba
? Entrada: 5 2 4 1 3 5 ? Salida: 3
Ejercicio 164: Rotar vector k posiciones (derecha)
Análisis
 Rotación en O(n), O(1) espacio usando reverses.
Diseño
 Reverse whole, reverse first k, reverse rest.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n); for(int i=0;i<n;++i) cin>>a[i];
    int k; cin>>k; k%=n;
    reverse(a.begin(), a.end());
    reverse(a.begin(), a.begin()+k);
    reverse(a.begin()+k, a.end());
    for(int x:a) cout<<x<<" ";
    cout<<"\n";
}

Prueba
? Entrada: 5 1 2 3 4 5 2 ? Salida: 4 5 1 2 3
Ejercicio 165: Número de caminos en cuadrícula m×n (DP)
Análisis
 Contar caminos de (0,0) a (m-1,n-1) con movimientos R y D.
Diseño
 DP 2D, dp[i][j]=dp[i-1][j]+dp[i][j-1].
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int m,n; if(!(cin>>m>>n)) return 0;
    vector<vector<long long>> dp(m, vector<long long>(n,0));
    for(int i=0;i<m;++i) dp[i][0]=1;
    for(int j=0;j<n;++j) dp[0][j]=1;
    for(int i=1;i<m;++i) for(int j=1;j<n;++j) dp[i][j]=dp[i-1][j]+dp[i][j-1];
    cout<<dp[m-1][n-1]<<"\n";
}

Prueba
? Entrada: 3 3 ? Salida: 6
Ejercicio 166: Two-sum usando hash (devolver índices)
Análisis
 Encontrar dos índices con suma X (no ordenado).
Diseño
 Recorrido con unordered_map de valor?índice.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<int>a(n); for(int i=0;i<n;++i)cin>>a[i];
    int X; cin>>X;
    unordered_map<int,int> mp;
    for(int i=0;i<n;++i){
        int need = X - a[i];
        if(mp.count(need)){ cout<<mp[need]<<" "<<i<<"\n"; return 0; }
        mp[a[i]] = i;
    }
    cout<<"NO\n";
}

Prueba
? Entrada: 5 2 7 11 15 1 9 (n=5 array then X=9) ? Salida: 0 1 (2+7)
Ejercicio 167: Max en ventana deslizante (deque)
Análisis
 Para cada ventana de tamaño k, hallar el máximo.
Diseño
 Deque mantener índices con valores decrecientes.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<int>a(n); for(int i=0;i<n;++i)cin>>a[i];
    int k; cin>>k;
    deque<int> dq;
    for(int i=0;i<n;++i){
        if(!dq.empty() && dq.front()==i-k) dq.pop_front();
        while(!dq.empty() && a[dq.back()]<=a[i]) dq.pop_back();
        dq.push_back(i);
        if(i>=k-1) cout<<a[dq.front()]<<" ";
    }
    cout<<"\n";
}

Prueba
? Entrada: 8 1 3 -1 -3 5 3 6 7 3 (n=8 arr then k=3) ? Salida: 3 3 5 5 6 7
Ejercicio 168: Mediana en flujo (dos heaps)
Análisis
 Mantener mediana mientras se insertan números uno a uno.
Diseño
 Max-heap left, min-heap right; rebalanceo.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    priority_queue<int> L;
    priority_queue<int, vector<int>, greater<int>> R;
    int x;
    while(cin>>x){
        if(L.empty() || x<=L.top()) L.push(x); else R.push(x);
        if(L.size()>R.size()+1){ R.push(L.top()); L.pop(); }
        else if(R.size()>L.size()){ L.push(R.top()); R.pop(); }
        double med = (L.size()==R.size()) ? (L.top()+R.top())/2.0 : L.top();
        cout<<med<<"\n";
    }
}

Prueba
? Entrada: 5 15 1 3 (sequence) ? Medianas: 5,10,5,4
Ejercicio 169: LRU Cache (list + unordered_map)
Análisis
 Implementar cache LRU con capacidad k: O(1) get/put.
Diseño
 Doble-linked list (std::list) + unordered_map key->iterator.
Código
#include <bits/stdc++.h>
using namespace std;
struct LRU {
    int cap; list<pair<int,int>> l; unordered_map<int, list<pair<int,int>>::iterator> mp;
    LRU(int c):cap(c){}
    int get(int k){
        if(!mp.count(k)) return -1;
        auto it=mp[k]; int val=it->second; l.erase(it); l.push_front({k,val}); mp[k]=l.begin(); return val;
    }
    void put(int k,int v){
        if(mp.count(k)){ l.erase(mp[k]); mp.erase(k); }
        if((int)l.size()==cap){ auto bk=l.back(); mp.erase(bk.first); l.pop_back(); }
        l.push_front({k,v}); mp[k]=l.begin();
    }
};
int main(){
    LRU cache(2);
    cache.put(1,1); cache.put(2,2);
    cout<<cache.get(1)<<"\n"; // 1
    cache.put(3,3);
    cout<<cache.get(2)<<"\n"; // -1
}

Prueba
? Comportamiento según ejemplo (outputs 1 then -1).
Ejercicio 170: Implementar Trie con conteo de prefijos
Análisis
 Soportar insert y contar cuántas palabras tienen un prefijo dado.
Diseño
 Trie node con count de palabras en subárbol.
Código
#include <bits/stdc++.h>
using namespace std;
struct Node{ array<int,26> nxt; int cnt=0; Node(){ nxt.fill(-1); } };
int main(){
    vector<Node> trie(1);
    auto insert = [&](const string&s){
        int v=0; trie[v].cnt++;
        for(char ch:s){
            int c=ch-'a';
            if(trie[v].nxt[c]==-1){ trie[v].nxt[c]=trie.size(); trie.emplace_back(); }
            v=trie[v].nxt[c]; trie[v].cnt++;
        }
    };
    auto prefcnt = [&](const string&p){
        int v=0;
        for(char ch:p){ int c=ch-'a'; if(trie[v].nxt[c]==-1) return 0; v=trie[v].nxt[c]; }
        return trie[v].cnt;
    };
    insert("hello"); insert("hell"); insert("he");
    cout<<prefcnt("he")<<"\n"; // 3
}

Prueba
? prefcnt("he") ? 3
Ejercicio 171: Uso de std::optional para parseo seguro
Análisis
 Mostrar uso de std::optional<T> para retorno que puede fallar.
Diseño
 Función to_int que devuelve optional<int>.
Código
#include <bits/stdc++.h>
using namespace std;
optional<int> to_int(const string& s){
    try{ size_t pos; int v=stoi(s,&pos); if(pos==s.size()) return v; else return nullopt; }
    catch(...) { return nullopt; }
}
int main(){
    string s; while(cin>>s){
        auto v=to_int(s);
        if(v) cout<<"INT "<<*v<<"\n"; else cout<<"BAD\n";
    }
}

Prueba
? Entrada: 123 abc 45 ? Salida: INT 123 BAD INT 45
Ejercicio 172: std::nth_element — encontrar mediana en O(n)
Análisis
 Usar nth_element para hallar k-ésimo.
Diseño
 Call nth_element(v.begin(), v.begin()+k, v.end()).
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0; vector<int>a(n); for(int i=0;i<n;++i)cin>>a[i];
    int k = n/2; nth_element(a.begin(), a.begin()+k, a.end());
    cout<<a[k]<<"\n";
}

Prueba
? Entrada: 5 7 1 3 5 9 ? mediana 5 (depending on order may be 5)
Ejercicio 173: Implementar Segment Tree con Lazy Propagation (range add, range sum)
Análisis
 Range add and range sum queries.
Diseño
 Classic segment tree with lazy array.
Código
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
struct Seg {
    int n; vector<ll> t, lazy;
    Seg(int n):n(n),t(4*n),lazy(4*n,0){}
    void apply(int p,int l,int r,ll val){ t[p]+=val*(r-l+1); lazy[p]+=val; }
    void push(int p,int l,int r){
        if(lazy[p]){
            int m=(l+r)/2;
            apply(p*2,l,m,lazy[p]); apply(p*2+1,m+1,r,lazy[p]); lazy[p]=0;
        }
    }
    void update(int p,int l,int r,int ql,int qr,ll v){
        if(ql>r||qr<l) return;
        if(ql<=l&&r<=qr){ apply(p,l,r,v); return; }
        push(p,l,r); int m=(l+r)/2;
        update(p*2,l,m,ql,qr,v); update(p*2+1,m+1,r,ql,qr,v);
        t[p]=t[p*2]+t[p*2+1];
    }
    ll query(int p,int l,int r,int ql,int qr){
        if(ql>r||qr<l) return 0;
        if(ql<=l&&r<=qr) return t[p];
        push(p,l,r); int m=(l+r)/2;
        return query(p*2,l,m,ql,qr)+query(p*2+1,m+1,r,ql,qr);
    }
};
int main(){
    int n; if(!(cin>>n)) return 0;
    Seg st(n);
    int q; cin>>q;
    while(q--){
        int t; cin>>t;
        if(t==1){ int l,r; long long v; cin>>l>>r>>v; st.update(1,0,n-1,l,r,v); }
        else { int l,r; cin>>l>>r; cout<<st.query(1,0,n-1,l,r)<<"\n"; }
    }
}

Prueba
? n=5, update(0,4,1), query(0,4)=5
Ejercicio 174: Construcción de suffix array (esqueleto O(n log n))
Análisis
 Construir SA para string dado.
Diseño
 Doubling algorithm.
Código (esqueleto, funcional)
#include <bits/stdc++.h>
using namespace std;
vector<int> build_sa(const string &s){
    int n=s.size(), k=1;
    vector<int> sa(n), r(n), tmp(n);
    for(int i=0;i<n;++i){ sa[i]=i; r[i]=s[i]; }
    auto cmp=[&](int a,int b){
        if(r[a]!=r[b]) return r[a]<r[b];
        int ra = a+k<n? r[a+k]: -1;
        int rb = b+k<n? r[b+k]: -1;
        return ra<rb;
    };
    for(k=1;;k<<=1){
        sort(sa.begin(), sa.end(), cmp);
        tmp[sa[0]]=0;
        for(int i=1;i<n;++i) tmp[sa[i]] = tmp[sa[i-1]] + cmp(sa[i-1], sa[i]);
        for(int i=0;i<n;++i) r[i]=tmp[i];
        if(r[sa[n-1]]==n-1) break;
    }
    return sa;
}
int main(){
    string s; if(!(cin>>s)) return 0;
    auto sa = build_sa(s);
    for(int i:sa) cout<<i<<" ";
    cout<<"\n";
}

Prueba
? banana ? SA e.g. 5 3 1 0 4 2 (one valid ordering)
Ejercicio 175: Longest Common Prefix (LCP) array (Kasai)
Análisis
 Calcular LCP entre suffixes adyacentes en SA.
Diseño
 Algoritmo Kasai en O(n).
Código
#include <bits/stdc++.h>
using namespace std;
vector<int> build_sa(const string &s); // assume implemented (as above)
vector<int> build_lcp(const string &s, const vector<int>& sa){
    int n=s.size();
    vector<int> rank(n);
    for(int i=0;i<n;++i) rank[sa[i]]=i;
    vector<int> lcp(max(0,n-1));
    int h=0;
    for(int i=0;i<n;++i){
        if(rank[i]==0) continue;
        int j = sa[rank[i]-1];
        while(i+h<n && j+h<n && s[i+h]==s[j+h]) ++h;
        lcp[rank[i]-1]=h;
        if(h>0) --h;
    }
    return lcp;
}
int main(){
    string s; if(!(cin>>s)) return 0;
    auto sa = build_sa(s);
    auto lcp = build_lcp(s, sa);
    for(int v: lcp) cout<<v<<" ";
    cout<<"\n";
}

Prueba
? banana ? LCP array e.g. 1 3 0 0 2
Ejercicio 176: Rabin-Karp (búsqueda de patrón)
Análisis
 Buscar todas las ocurrencias de patrón P en texto T.
Diseño
 Rolling hash con base y modulo grande (uso ull to avoid modulo).
Código
#include <bits/stdc++.h>
using namespace std;
using ull = unsigned long long;
vector<int> rabin_karp(const string &t,const string &p){
    int n=t.size(), m=p.size();
    if(m>n) return {};
    const ull B=1315423911ULL;
    ull hp=0, ht=0, powB=1;
    for(int i=0;i<m;++i){ hp = hp*B + (unsigned char)p[i]; ht = ht*B + (unsigned char)t[i]; if(i) powB *= B; }
    vector<int> res;
    if(hp==ht) res.push_back(0);
    for(int i=m;i<n;++i){
        ht = ht - powB*(unsigned char)t[i-m];
        ht = ht*B + (unsigned char)t[i];
        if(ht==hp) res.push_back(i-m+1);
    }
    return res;
}
int main(){ string t,p; if(!(cin>>t>>p)) return 0; auto r=rabin_karp(t,p); for(int i:r) cout<<i<<" "; cout<<"\n"; }

Prueba
? abracadabra y abra ? 0 7
Ejercicio 177: Comprimir coordenadas (coordinate compression)
Análisis
 Mapear valores dispersos a rango 0..m-1 manteniendo orden.
Diseño
 Copiar valores, sort unique, map original->index.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<long long> a(n), b;
    for(int i=0;i<n;++i){ cin>>a[i]; b.push_back(a[i]); }
    sort(b.begin(), b.end()); b.erase(unique(b.begin(), b.end()), b.end());
    for(int i=0;i<n;++i){
        int idx = lower_bound(b.begin(), b.end(), a[i]) - b.begin();
        cout<<idx<<" ";
    }
    cout<<"\n";
}

Prueba
? 5 100 500 1000 500 100 ? 0 1 2 1 0
Ejercicio 178: Two pointers — contar pares con suma ? X en array ordenado
Análisis
 Contar pares (i<j) con a[i]+a[j] ? X.
Diseño
 Two pointers l=0, r=n-1; if sum?X add r-l and ++l else --r.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<long long> a(n); for(int i=0;i<n;++i) cin>>a[i];
    sort(a.begin(), a.end());
    long long X; cin>>X; long long cnt=0;
    int l=0, r=n-1;
    while(l<r){
        if(a[l]+a[r]<=X){ cnt += (r-l); ++l; }
        else --r;
    }
    cout<<cnt<<"\n";
}

Prueba
? n=4 a=[1,2,3,4], X=5 ? pares: (1,2),(1,3),(1,4),(2,3)?? check ? output 4
Ejercicio 179: Minimal window substring (sliding window)
Análisis
 Dada string S y T, encontrar substring mínimo de S que contenga todas las letras de T (counts).
Diseño
 Sliding window con counts and formed counter.
Código
#include <bits/stdc++.h>
using namespace std;
string minWindow(string s, string t){
    vector<int> need(128,0);
    for(char c:t) need[c]++;
    int required = 0; for(int c=0;c<128;++c) if(need[c]>0) required++;
    vector<int> window(128,0);
    int formed=0, l=0, r=0, bestL=0, bestLen=INT_MAX;
    while(r<s.size()){
        char c=s[r++]; window[c]++;
        if(window[c]==need[c]) formed++;
        while(l<r && formed==required){
            if(r-l < bestLen){ bestLen=r-l; bestL=l; }
            char d=s[l++]; if(window[d]==need[d]) formed--; window[d]--;
        }
    }
    return bestLen==INT_MAX? string("") : s.substr(bestL,bestLen);
}
int main(){ string s,t; if(!(cin>>s>>t)) return 0; cout<<minWindow(s,t)<<"\n"; }

Prueba
? S=ADOBECODEBANC T=ABC ? output BANC
Ejercicio 180: Longest Palindromic Substring (Manacher)
Análisis
 Encontrar palíndromo más largo en O(n).
Diseño
 Algoritmo de Manacher (implementación estándar).
Código
#include <bits/stdc++.h>
using namespace std;
string manacher(string s){
    string t = "@";
    for(char c:s){ t += '#'; t+=c; }
    t += "#$";
    int n=t.size();
    vector<int> p(n);
    int center=0, right=0;
    for(int i=1;i<n-1;++i){
        int mir = 2*center - i;
        if(i<right) p[i]=min(right-i, p[mir]);
        while(t[i+1+p[i]]==t[i-1-p[i]]) p[i]++;
        if(i+p[i]>right){ center=i; right=i+p[i]; }
    }
    int maxlen=0, centerIndex=0;
    for(int i=1;i<n-1;++i) if(p[i]>maxlen){ maxlen=p[i]; centerIndex=i; }
    int start = (centerIndex - maxlen -1)/2;
    return s.substr(start, maxlen);
}
int main(){ string s; if(!(cin>>s)) return 0; cout<<manacher(s)<<"\n"; }

Prueba
? babad ? bab or aba
Ejercicio 181: Minimum number of swaps to sort array
Analisis
 Contar swaps mínimos para ordenar array con elementos únicos.
Diseño
 Use pair (value,index), sort, and count cycles.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<pair<int,int>> a(n);
    for(int i=0;i<n;++i){ cin>>a[i].first; a[i].second = i; }
    sort(a.begin(), a.end());
    vector<char> vis(n,false);
    int ans=0;
    for(int i=0;i<n;++i){
        if(vis[i] || a[i].second==i) continue;
        int cycle=0, j=i;
        while(!vis[j]){ vis[j]=1; j = a[j].second; cycle++; }
        if(cycle>0) ans += cycle-1;
    }
    cout<<ans<<"\n";
}

Prueba
? 4 4 3 2 1 ? swaps 2? Actually for [4,3,2,1] minimal swaps = 2? For unique check: output 2? (works)
Ejercicio 182: Transformar cadena A en B con operaciones mínimas (edit distance)
Análisis
 Levenshtein distance (insert/delete/replace).
Diseño
 DP 2D.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){ string a,b; if(!(cin>>a>>b)) return 0; int n=a.size(), m=b.size();
 vector<vector<int>> dp(n+1, vector<int>(m+1));
 for(int i=0;i<=n;++i) dp[i][0]=i;
 for(int j=0;j<=m;++j) dp[0][j]=j;
 for(int i=1;i<=n;++i) for(int j=1;j<=m;++j)
   if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1];
   else dp[i][j]=1+min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});
 cout<<dp[n][m]<<"\n";}

Prueba
? kitten ? sitting ? 3
Ejercicio 183: Subset sum count (DP counting)
Análisis
 Contar formas para sumar S.
Diseño
 DP 1D counts (unsigned long long).
Código
#include <bits/stdc++.h>
using namespace std;
using ull = unsigned long long;
int main(){ int n,S; if(!(cin>>n>>S)) return 0; vector<int>a(n); for(int i=0;i<n;++i)cin>>a[i];
 vector<ull> dp(S+1); dp[0]=1;
 for(int x:a) for(int s=S;s>=x;--s) dp[s]+=dp[s-x];
 cout<<dp[S]<<"\n"; }

Prueba
? a=[1,1,1], S=2 ? 3
Ejercicio 184: Partition equal subset sum
Análisis
 ¿Se puede particionar en dos subconjuntos con misma suma?
Diseño
 Subset sum target = total/2 boolean DP.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){ int n; if(!(cin>>n)) return 0; vector<int>a(n); int sum=0; for(int i=0;i<n;++i){cin>>a[i]; sum+=a[i];}
 if(sum%2){ cout<<"NO\n"; return 0; }
 int S=sum/2; vector<char> dp(S+1,0); dp[0]=1;
 for(int x:a) for(int s=S;s>=x;--s) if(dp[s-x]) dp[s]=1;
 cout<<(dp[S]?"YES\n":"NO\n");
}

Prueba
? 4 1 5 11 5 ? YES
Ejercicio 185: TSP (bitmask DP) — costo minimal (n ? 16)
Análisis
 DP sobre subsets: dp[mask][i] min cost to reach mask ending at i.
Diseño
 Standard bitmask DP O(n^2 2^n).
Código (esqueleto)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = 1e15;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<vector<ll>> w(n, vector<ll>(n));
    for(int i=0;i<n;++i) for(int j=0;j<n;++j) cin>>w[i][j];
    int N = 1<<n;
    vector<vector<ll>> dp(N, vector<ll>(n, INF));
    dp[1][0]=0; // start at 0
    for(int mask=1; mask<N; ++mask)
        for(int u=0; u<n; ++u) if(dp[mask][u]<INF)
            for(int v=0; v<n; ++v) if(!(mask & (1<<v)))
                dp[mask | (1<<v)][v] = min(dp[mask | (1<<v)][v], dp[mask][u] + w[u][v]);
    ll ans = INF;
    for(int u=0; u<n; ++u) ans = min(ans, dp[N-1][u] + w[u][0]);
    cout<<ans<<"\n";
}

Prueba
? n small (4) with symmetric weights; check reachable.
Ejercicio 186: Heurística TSP (nearest neighbor) — aproximación rápida
Análisis
 Greedy nearest neighbor for TSP approximation.
Diseño
 Start at node 0, repeatedly go to nearest unvisited.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<vector<int>> w(n, vector<int>(n)); for(int i=0;i<n;++i) for(int j=0;j<n;++j) cin>>w[i][j];
    vector<char> vis(n,false); int cur=0; vis[0]=1; vector<int> tour={0};
    for(int step=1; step<n; ++step){
        int best=-1, bestd=INT_MAX;
        for(int v=0; v<n; ++v) if(!vis[v] && w[cur][v]<bestd){ best=v; bestd=w[cur][v]; }
        vis[best]=1; tour.push_back(best); cur=best;
    }
    // return to start
    tour.push_back(0);
    for(int x:tour) cout<<x<<" ";
    cout<<"\n";
}
Ejercicio 187: Validar paréntesis (stack)
Análisis
 Comprobar si una cadena de paréntesis ()[]{} está bien balanceada.
Diseño
 Usar stack<char> y mapa de pares de cierre->apertura.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    string s; if(!(cin>>s)) return 0;
    stack<char> st;
    unordered_map<char,char> mp = {{')','('},{']','['},{'}','{'}};
    for(char c: s){
        if(c=='('||c=='['||c=='{') st.push(c);
        else {
            if(st.empty() || st.top()!=mp[c]){ cout<<"NO\n"; return 0; }
            st.pop();
        }
    }
    cout << (st.empty() ? "YES\n" : "NO\n");
}

Prueba
? ()[]{} -> YES

? ([)] -> NO
Ejercicio 188: Validar número palíndromo (sin usar string extra)
Análisis
 Determinar si un entero es palíndromo sin convertir a string.
Diseño
 Dar vuelta la mitad del número (evitar overflow).
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    long long x; if(!(cin>>x)) return 0;
    if(x<0 || (x%10==0 && x!=0)){ cout<<"NO\n"; return 0; }
    long long rev=0;
    while(x>rev){
        rev = rev*10 + x%10;
        x /= 10;
    }
    cout << (x==rev || x==rev/10 ? "YES\n" : "NO\n");
}

Prueba
? 121 -> YES

? 10 -> NO
Ejercicio 189: Merge intervals (unir intervalos solapados)
Análisis
 Dado lista de intervalos [l,r], unir los que se solapan.
Diseño
 Ordenar por inicio y fusionar recorriendo.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<pair<int,int>> a(n);
    for(int i=0;i<n;++i) cin>>a[i].first>>a[i].second;
    sort(a.begin(), a.end());
    vector<pair<int,int>> res;
    for(auto &iv: a){
        if(res.empty() || iv.first > res.back().second) res.push_back(iv);
        else res.back().second = max(res.back().second, iv.second);
    }
    for(auto &p: res) cout<<p.first<<" "<<p.second<<"\n";
}

Prueba
? [[1,3],[2,6],[8,10],[15,18]] ? [1,6] [8,10] [15,18]
Ejercicio 190: Insert interval (insertar y fusionar)
Análisis
 Insertar nuevo intervalo en lista ordenada y fusionar solapamientos.
Diseño
 Recolectar menores, fusionar, luego mayores.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<pair<int,int>> a(n);
    for(int i=0;i<n;++i) cin>>a[i].first>>a[i].second;
    pair<int,int> newI; cin>>newI.first>>newI.second;
    vector<pair<int,int>> res;
    int i=0;
    while(i<n && a[i].second < newI.first) res.push_back(a[i++]);
    while(i<n && a[i].first <= newI.second){
        newI.first = min(newI.first, a[i].first);
        newI.second = max(newI.second, a[i].second);
        ++i;
    }
    res.push_back(newI);
    while(i<n) res.push_back(a[i++]);
    for(auto &p: res) cout<<p.first<<" "<<p.second<<"\n";
}

Prueba
? a=[[1,3],[6,9]] new=[2,5] ? [1,5] [6,9]
Ejercicio 191: Buscar skyline (problema clásico — eventos + multiset)
Análisis
 Dado conjunto de edificios (L,R,H), producir líneas del skyline.
Diseño
 Evento (L, -H), (R, +H), ordenar y usar multiset para alturas activas.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<tuple<int,int,int>> b(n);
    for(int i=0;i<n;++i) cin>>get<0>(b[i])>>get<1>(b[i])>>get<2>(b[i]);
    vector<pair<int,int>> events;
    for(auto &t: b){
        int L,R,H; tie(L,R,H)=t;
        events.push_back({L, -H});
        events.push_back({R, H});
    }
    sort(events.begin(), events.end(), [](auto &a, auto &b){
        if(a.first!=b.first) return a.first<b.first;
        return a.second<b.second;
    });
    multiset<int> heights; heights.insert(0);
    int prev=0;
    for(auto &e: events){
        int x=e.first, h=e.second;
        if(h<0) heights.insert(-h);
        else heights.erase(heights.find(h));
        int cur = *heights.rbegin();
        if(cur != prev){ cout<<x<<" "<<cur<<"\n"; prev=cur; }
    }
}

Prueba
? Edificios [(2,9,10),(3,7,15),(5,12,12)] produce puntos del skyline.
Ejercicio 192: Buscar primer y último índice de un elemento (binary search bounds)
Análisis
 Encontrar primer y último índice de x en array ordenado.
Diseño
 lower_bound y upper_bound-1.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n); for(int i=0;i<n;++i) cin>>a[i];
    int x; cin>>x;
    auto itl = lower_bound(a.begin(), a.end(), x);
    auto itu = upper_bound(a.begin(), a.end(), x);
    if(itl==a.end() || *itl!=x) cout<<"-1 -1\n";
    else cout<<int(itl - a.begin())<<" "<<int(itu - a.begin() - 1)<<"\n";
}

Prueba
? a=[1,2,2,2,3], x=2 ? 1 3
Ejercicio 193: Merge two sorted arrays in-place (without extra array) — when space at end
Análisis
 Dado A de tamaño m+n con primeros m validos y B tamaño n, fusionar en A in-place.
Diseño
 Usar 3 punteros desde el final.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int m,n; if(!(cin>>m>>n)) return 0;
    vector<int> A(m+n);
    for(int i=0;i<m;++i) cin>>A[i];
    for(int j=0;j<n;++j) cin>>A[m+j]; // read B into tail for simplicity
    // Instead assume separate B:
    // Alternative: read B separately
    // For clarity, read B separately:
    // (here using A[0..m-1] and B separately:)
    // So redo:
    vector<int> a(m); for(int i=0;i<m;++i) a[i]=A[i];
    vector<int> b(n); for(int j=0;j<n;++j) b[j]=A[m+j];
    int i=m-1, j=n-1, k=m+n-1;
    while(j>=0){
        if(i>=0 && a[i]>b[j]) A[k--]=a[i--];
        else A[k--]=b[j--];
    }
    for(int idx=0; idx<m+n; ++idx) cout<<A[idx]<<" ";
    cout<<"\n";
}

Prueba
? A=[1,3,5,0,0], m=3 B=[2,4], n=2 ? 1 2 3 4 5
Ejercicio 194: Matrix rotation 90° in-place (NxN)
Análisis
 Girar matriz cuadrada 90° (clockwise) sin matriz extra.
Diseño
 Transponer + reverse each row, o layer-by-layer swap.
Código
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<vector<int>> a(n, vector<int>(n));
    for(int i=0;i<n;++i) for(int j=0;j<n;++j) cin>>a[i][j];
    // transpose
    for(int i=0;i<n;++i) for(int j=i+1;j<n;++j) swap(a[i][j], a[j][i]);
    // reverse rows
    for(int i=0;i<n;++i) reverse(a[i].begin(), a[i].end());
    for(int i=0;i<n;++i){ for(int j=0;j<n;++j) cout<<a[i][j]<<" "; cout<<"\n"; }
}

Prueba
? 3x3 matrix rotated as expected.
Ejercicio 195: Check if binary tree is BST (inorder traversal)
Análisis
 Verificar si un árbol binario es árbol de búsqueda válido.
Diseño
 Inorder traversal must be strictly increasing (or non-decreasing depends; here strict).
Código
#include <bits/stdc++.h>
using namespace std;
struct Node{ int v; Node* l; Node* r; Node(int x):v(x),l(nullptr),r(nullptr){} };
bool isBST(Node* root, long long minv=LLONG_MIN, long long maxv=LLONG_MAX){
    if(!root) return true;
    if(root->v <= minv || root->v >= maxv) return false;
    return isBST(root->l, minv, root->v) && isBST(root->r, root->v, maxv);
}
// Example building and test in main:
int main(){
    // Example: build simple tree: 2 / \ 1 3
    Node* root = new Node(2);
    root->l = new Node(1);
    root->r = new Node(3);
    cout << (isBST(root) ? "YES\n" : "NO\n");
    return 0;
}

Prueba
? Tree above ? YES; if right child 0 ? NO.
Ejercicio 196: Lowest Common Ancestor in BST (iterative)
Análisis
 Encontrar LCA de dos nodos en BST.
Diseño
 Iterar desde root: si ambos < root->v go left; if both > go right; else root is LCA.
Código
#include <bits/stdc++.h>
using namespace std;
struct Node{ int v; Node* l; Node* r; Node(int x):v(x),l(nullptr),r(nullptr){} };
Node* lcaBST(Node* root, int a, int b){
    while(root){
        if(a < root->v && b < root->v) root = root->l;
        else if(a > root->v && b > root->v) root = root->r;
        else return root;
    }
    return nullptr;
}
int main(){
    Node* root = new Node(6);
    root->l = new Node(2); root->r = new Node(8);
    root->l->l = new Node(0); root->l->r = new Node(4);
    int a=0,b=4;
    Node* res = lcaBST(root,a,b);
    if(res) cout<<res->v<<"\n"; else cout<<"NO\n";
}

Prueba
? LCA(0,4) ? 2
Ejercicio 197: Serialize / Deserialize binary tree (preorder with nulls)
Análisis
 Convertir árbol a string y reconstruirlo.
Diseño
 Preorder traversal, use # for nulls, separar con comas.
Código
#include <bits/stdc++.h>
using namespace std;
struct Node{ int v; Node* l; Node* r; Node(int x):v(x),l(nullptr),r(nullptr){} };
void serialize(Node* root, ostream &out){
    if(!root){ out << "#,"; return; }
    out << root->v << ",";
    serialize(root->l, out);
    serialize(root->r, out);
}
Node* deserialize(istringstream &in){
    string token;
    if(!getline(in, token, ',')) return nullptr;
    if(token=="#") return nullptr;
    Node* node = new Node(stoi(token));
    node->l = deserialize(in);
    node->r = deserialize(in);
    return node;
}
int main(){
    Node* root = new Node(1);
    root->l = new Node(2); root->r = new Node(3);
    root->r->l = new Node(4); root->r->r = new Node(5);
    ostringstream out;
    serialize(root, out);
    string s = out.str();
    cout << "Serialized: " << s << "\n";
    istringstream in(s);
    Node* root2 = deserialize(in);
    // Serialize again to verify
    ostringstream out2; serialize(root2, out2);
    cout << "Re-serialized: " << out2.str() << "\n";
}

Prueba
? Check serialized equals re-serialized.
Ejercicio 198: Binary tree level order traversal (BFS)
Análisis
 Recorrer árbol por niveles y devolver listas por nivel.
Diseño
 Usar queue<Node*> y delimitar niveles por size.
Código
#include <bits/stdc++.h>
using namespace std;
struct Node{ int v; Node* l; Node* r; Node(int x):v(x),l(nullptr),r(nullptr){} };
int main(){
    Node* root = new Node(1);
    root->l = new Node(2); root->r = new Node(3);
    root->l->l = new Node(4); root->l->r = new Node(5);
    queue<Node*> q; q.push(root);
    while(!q.empty()){
        int sz = q.size();
        for(int i=0;i<sz;++i){
            Node* cur = q.front(); q.pop();
            cout<<cur->v<<" ";
            if(cur->l) q.push(cur->l);
            if(cur->r) q.push(cur->r);
        }
        cout<<"\n";
    }
}

Prueba
? Output levels: 1 then 2 3 then 4 5
Ejercicio 199: Convert sorted array to balanced BST
Análisis
 Construir BST balanceado mínimo a partir de array ordenado.
Diseño
 Usar construcción recursiva mid -> root.
Código
#include <bits/stdc++.h>
using namespace std;
struct Node{ int v; Node* l; Node* r; Node(int x):v(x),l(nullptr),r(nullptr){} };
Node* build(vector<int>& a, int l, int r){
    if(l>r) return nullptr;
    int m = (l+r)/2;
    Node* root = new Node(a[m]);
    root->l = build(a, l, m-1);
    root->r = build(a, m+1, r);
    return root;
}
void inorder(Node* r){ if(!r) return; inorder(r->l); cout<<r->v<<" "; inorder(r->r); }
int main(){
    int n; if(!(cin>>n)) return 0;
    vector<int> a(n); for(int i=0;i<n;++i) cin>>a[i];
    Node* root = build(a,0,n-1);
    inorder(root); cout<<"\n";
}

Prueba
? a=[1,2,3,4,5] -> inorder prints sorted sequence.

Ejercicio 200: Check if two binary trees are isomorphic (structure + values)
Análisis
 Determinar si dos árboles son idénticos (misma estructura y valores).
Diseño
 Recursión: check roots equal and left subtrees equal and right equal.
Código
#include <bits/stdc++.h>
using namespace std;
struct Node{ int v; Node* l; Node* r; Node(int x):v(x),l(nullptr),r(nullptr){} };
bool sameTree(Node* a, Node* b){
    if(!a && !b) return true;
    if(!a || !b) return false;
    if(a->v != b->v) return false;
    return sameTree(a->l, b->l) && sameTree(a->r, b->r);
}
int main(){
    Node* a = new Node(1); a->l = new Node(2); a->r = new Node(3);
    Node* b = new Node(1); b->l = new Node(2); b->r = new Node(3);
    cout << (sameTree(a,b) ? "SAME\n" : "DIFFERENT\n");
    b->r->v = 4;
    cout << (sameTree(a,b) ? "SAME\n" : "DIFFERENT\n");
}

Prueba
? Initially SAME; after change DIFFERENT.

Prueba
? For small complete graphs, produces a tour (not optimal but quick).

Ejercicio 1 — Quicksort con pivote aleatorio (versión in-place, evitar peor caso)
Análisis del problema
 Implementar Quicksort in-place que use un pivote aleatorio para evitar el peor caso (arreglo ya ordenado). Debe ordenar vector<int> de tamaño n en tiempo promedio O(n log n) y espacio O(log n) (recursión).
Diseño de la solución
? Elegir pivote aleatorio entre [l,r].

? Partición (Hoare o Lomuto); aquí usamos partición de Hoare (mejor en práctica con pivote aleatorio).

? Llamadas recursivas sobre subarreglos menores y mayores.

? Para evitar desbordamiento de pila en distribuciones adversas, recursión sobre el subproblema más pequeño primero (tail recursion on larger subarray iterative or recursive on small then loop).

? Complejidad promedio: O(n log n); espacio O(log n) recursión promedio.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using vi = vector<int>;
mt19937_64 rng(chrono::high_resolution_clock::now().time_since_epoch().count());

int hoare_partition(vi &a, int l, int r) {
    uniform_int_distribution<int> dist(l, r);
    int pivot = a[dist(rng)];
    int i = l - 1, j = r + 1;
    while (true) {
        do i++; while (a[i] < pivot);
        do j--; while (a[j] > pivot);
        if (i >= j) return j;
        swap(a[i], a[j]);
    }
}

void quicksort(vi &a, int l, int r) {
    while (l < r) {
        int p = hoare_partition(a, l, r);
        // recurse on smaller partition first
        if (p - l < r - (p + 1)) {
            quicksort(a, l, p);
            l = p + 1;
        } else {
            quicksort(a, p + 1, r);
            r = p;
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; 
    if (!(cin >> n)) return 0;
    vi a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    quicksort(a, 0, n - 1);
    for (int x : a) cout << x << ' ';
    cout << '\n';
    return 0;
}

Pruebas
? Caso 1 (aleatorio): n=7, a=3 6 1 8 2 5 4 ? salida: 1 2 3 4 5 6 8.

? Caso 2 (ya ordenado): 1 2 3 4 5 ? mantiene estabilidad del orden relativo de valores iguales no garantizada; importante: corre rápido porque pivote aleatorio.

? Caso 3 (con duplicados): 4 4 4 4 ? ordenado igual.


Ejercicio 2 — MergeSort estable para objetos (orden por campo primario y secundario)
Análisis del problema
 Ordenar un vector de objetos struct Item { string name; int age; double score; } por age ascendente y score descendente; mantener estabilidad para name si age y score iguales. Implementar MergeSort estable para objetos (O(n log n), uso de memoria O(n)).
Diseño de la solución
? Emplear MergeSort recursivo que construye vectores temporales; el merge debe copiar en orden garantizando estabilidad.

? Comparator: (a.age, -a.score, original_index) — para preservar orden estable ante igualdad, podemos capturar índice original. Pero como MergeSort es estable, si comparator no rompe igualdad se mantiene el orden.

Código (C++)
#include <bits/stdc++.h>
using namespace std;

struct Item {
    string name;
    int age;
    double score;
    int idx; // original index to illustrate stability (not required if sort stable)
};

bool cmp(const Item &a, const Item &b) {
    if (a.age != b.age) return a.age < b.age;
    if (a.score != b.score) return a.score > b.score; // score desc
    return a.idx < b.idx; // tie-breaker to show stability explicitly
}

void merge_sort(vector<Item>& a, int l, int r, vector<Item>& tmp) {
    if (r - l <= 0) return;
    int m = (l + r) >> 1;
    merge_sort(a, l, m, tmp);
    merge_sort(a, m+1, r, tmp);
    int i = l, j = m+1, k = l;
    while (i <= m && j <= r) {
        if (cmp(a[i], a[j])) tmp[k++] = a[i++];
        else tmp[k++] = a[j++];
    }
    while (i <= m) tmp[k++] = a[i++];
    while (j <= r) tmp[k++] = a[j++];
    for (int t = l; t <= r; ++t) a[t] = tmp[t];
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin >> n)) return 0;
    vector<Item> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i].name >> a[i].age >> a[i].score;
        a[i].idx = i;
    }
    vector<Item> tmp(n);
    merge_sort(a, 0, n-1, tmp);
    for (auto &it : a) cout << it.name << ' ' << it.age << ' ' << it.score << '\n';
    return 0;
}

Pruebas
Entrada ejemplo:

 4
Ana 25 88.5
Luis 25 90.0
Maria 22 95.0
Ana2 25 90.0
 Salida (orden por age asc, score desc, estabilidad manteniendo idx):

 Maria 22 95.0
Luis 25 90.0
Ana2 25 90.0
Ana 25 88.5
? 

Ejercicio 3 — k-ésimo más grande con selección determinista (Median of Medians) — O(n) worst-case
Análisis del problema
 Encontrar el k-ésimo elemento más grande (o k-ésimo por orden) en tiempo O(n) en el peor caso usando el algoritmo Median of Medians (Selección determinista). Entrada: vector a de n elementos distintos (o con duplicados), k (1-based: k=1 ? máximo).
Diseño de la solución
? Implementar select(a, l, r, k) usando pivot obtenido por median-of-medians: dividir en grupos de 5, hallar medianas, recursivamente encontrar mediana de las medianas.

? Partición al estilo Lomuto u Hoare con pivot especificado.

? Complejidad worst-case O(n).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using vi = vector<long long>;

int partition(vi &a, int l, int r, long long pivot) {
    int i = l;
    for (int j = l; j <= r; ++j) {
        if (a[j] < pivot) swap(a[i++], a[j]);
    }
    int pivotPos = i;
    for (int j = i; j <= r; ++j) if (a[j] == pivot) { swap(a[pivotPos], a[j]); break; }
    return pivotPos;
}

long long median_of_medians(vi &a, int l, int r) {
    int n = r - l + 1;
    if (n <= 5) {
        sort(a.begin() + l, a.begin() + r + 1);
        return a[l + n/2];
    }
    int cnt = 0;
    for (int i = l; i <= r; i += 5) {
        int sub_r = min(i+4, r);
        sort(a.begin()+i, a.begin()+sub_r+1);
        swap(a[l + cnt], a[i + (sub_r - i)/2]);
        ++cnt;
    }
    // recursively find median of medians stored starting at a[l]
    return median_of_medians(a, l, l + cnt - 1);
}

long long select_kth(vi &a, int l, int r, int k) { // k is 0-based
    if (l == r) return a[l];
    long long pivot = median_of_medians(a, l, r);
    int pivotIndex = partition(a, l, r, pivot);
    int leftSize = pivotIndex - l;
    if (k < leftSize) return select_kth(a, l, pivotIndex - 1, k);
    else if (k == leftSize) return a[pivotIndex];
    else return select_kth(a, pivotIndex + 1, r, k - leftSize - 1);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vi a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    int k; cin>>k; // 1-based: k=1 -> largest
    if(k<1||k>n){ cout<<"Error\n"; return 0; }
    // find k-th largest: convert to (n-k)-th smallest (0-based)
    int idx = n - k;
    long long val = select_kth(a, 0, n-1, idx);
    cout<<val<<"\n";
    return 0;
}

Pruebas
? Entrada: 6 7 10 4 3 20 15 k=3 ? tercer más grande = 7 (orden descendente 20,15,10,7,4,3 ? 3rd=10? Wait: check mapping: n=6, k=3 => idx=3 -> 0-based smallest -> sorted ascending 3,4,7,10,15,20 -> idx=3 => 10 => 3rd largest = 10) Salida: 10.

? Nota: verificar conversion k?idx correctamente.


Ejercicio 4 — Knapsack 0/1 con reconstrucción (DP y recuperación de objetos escogidos)
Análisis del problema
 Dado n objetos con peso w[i] y valor v[i] y capacidad W, encontrar valor máximo y el subconjunto de índices escogidos. Debe entregar tanto el valor óptimo como la lista de elementos seleccionados. Usar DP O(nW) (n hasta ~200, W hasta ~1e4 en ejercicios prácticos).
Diseño de la solución
? DP 2D dp[i][cap] (i objetos considerados) con reconstrucción: si dp[i][cap] != dp[i-1][cap] entonces objeto i-1 fue tomado.

? Para ahorrar memoria, podríamos usar 1D y reconstrucción con tracking, pero 2D más simple para enseñar la técnica.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, W; 
    if(!(cin>>n>>W)) return 0;
    vector<int> w(n), v(n);
    for(int i=0;i<n;++i) cin>>w[i]>>v[i];
    vector<vector<int>> dp(n+1, vector<int>(W+1, 0));
    for(int i=1;i<=n;++i){
        for(int cap=0; cap<=W; ++cap){
            dp[i][cap] = dp[i-1][cap];
            if(cap >= w[i-1]) dp[i][cap] = max(dp[i][cap], dp[i-1][cap - w[i-1]] + v[i-1]);
        }
    }
    int best = dp[n][W];
    cout << "Valor optimo: " << best << "\n";
    // reconstrucción
    int cap = W;
    vector<int> chosen;
    for(int i=n;i>=1;--i){
        if(dp[i][cap] != dp[i-1][cap]){
            chosen.push_back(i-1); // tomar objeto i-1
            cap -= w[i-1];
        }
    }
    reverse(chosen.begin(), chosen.end());
    cout << "Objetos elegidos (indices 0-based):";
    for(int idx: chosen) cout << ' ' << idx;
    cout << '\n';
    return 0;
}

Pruebas
Entrada:

 4 7
1 1
3 4
4 5
5 7
?  Salida: Valor optimo: 9 y Objetos elegidos: 1 2 (ó los índices que correspondan).


Ejercicio 5 — Shortest path con A* (heurística euclidiana) en grid con obstáculos
Análisis del problema
 Implementar A* para encontrar camino mínimo (en número de movimientos) en una cuadrícula R x C con obstáculos (#) entre start (sx,sy) y goal (gx,gy). Usar heurística Euclidiana (o Manhattan si movimiento 4-dir). Demostrar que para 4-direcciones Manhattan es admissible.
Diseño de la solución
? Representar grid, vecinos 4-direccionales.

? g = distancia desde start; h = Manhattan distance to goal; f = g + h.

? Mantener open como priority_queue por menor f (si empate, menor g o por tie-break).

? came_from para reconstruir ruta.

? Complejidad: en práctica, similar a BFS pero visita menos nodos si heurística efectiva.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int,int>;
struct Node {
    int f, g;
    int x, y;
    bool operator<(const Node& other) const {
        if (f != other.f) return f > other.f; // min-heap via reversed comparator
        return g < other.g;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int R,C; if(!(cin>>R>>C)) return 0;
    vector<string> grid(R);
    for(int i=0;i<R;++i) cin>>grid[i];
    int sx, sy, gx, gy; cin>>sx>>sy>>gx>>gy; // zero-based coords
    auto h = [&](int x,int y){ return abs(x-gx)+abs(y-gy); }; // Manhattan (admissible)
    const int INF = 1e9;
    vector<vector<int>> g(R, vector<int>(C, INF));
    vector<vector<pii>> parent(R, vector<pii>(C, {-1,-1}));
    priority_queue<Node> open;
    g[sx][sy]=0;
    open.push({h(sx,sy), 0, sx, sy});
    int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};

    bool found=false;
    while(!open.empty()){
        Node cur = open.top(); open.pop();
        if (cur.x==gx && cur.y==gy){ found=true; break; }
        if (cur.g != g[cur.x][cur.y]) continue; // outdated
        for(int k=0;k<4;++k){
            int nx=cur.x+dx[k], ny=cur.y+dy[k];
            if(nx<0||ny<0||nx>=R||ny>=C) continue;
            if(grid[nx][ny]=='#') continue;
            int ng = cur.g + 1;
            if(ng < g[nx][ny]){
                g[nx][ny] = ng;
                parent[nx][ny] = {cur.x, cur.y};
                open.push({ng + h(nx,ny), ng, nx, ny});
            }
        }
    }
    if(!found){ cout << "NO PATH\n"; return 0; }
    vector<pii> path;
    for(pii at = {gx,gy}; at.first!=-1; at = parent[at.first][at.second]) path.push_back(at);
    reverse(path.begin(), path.end());
    cout << "Length: " << path.size()-1 << "\n";
    for(auto &p: path) cout << p.first << ' ' << p.second << '\n';
    return 0;
}

Pruebas
? Grid 5x5 with obstacles; test start/goal reachable and unreachable. A* debe producir ruta óptima en número de pasos (por la heurística admisible).


Ejercicio 6 — Dinic (Max Flow) implementación eficiente (adj list + level graph + ptr array)
Análisis del problema
 Implementar Dinic para hallar flujo máximo en grafo dirigido con n nodos y m aristas con capacidades no negativas (integers). Debe ser eficiente para grafos medianos/grandes (m hasta ~1e5).
Diseño de la solución
? Grafo con aristas con to, rev_index, cap.

? bfs para construir level graph.

? dfs con ptr para escanear aristas sin repetir.

? Complejidad promedio buena: O(m * sqrt(n)) en práctica o O(min(n^2/3, m^1/2)*m) teórico.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct Edge { int to; int rev; long long cap; };
struct Dinic {
    int n; vector<vector<Edge>> g; vector<int> level, ptr;
    Dinic(int n): n(n), g(n), level(n), ptr(n) {}
    void addEdge(int u, int v, long long c){
        Edge a = {v, (int)g[v].size(), c};
        Edge b = {u, (int)g[u].size(), 0};
        g[u].push_back(a); g[v].push_back(b);
    }
    bool bfs(int s, int t){
        fill(level.begin(), level.end(), -1);
        queue<int> q; q.push(s); level[s]=0;
        while(!q.empty()){
            int v=q.front(); q.pop();
            for(const Edge &e: g[v]) if(e.cap>0 && level[e.to]==-1){
                level[e.to]=level[v]+1; q.push(e.to);
            }
        }
        return level[t]!=-1;
    }
    long long dfs(int v, int t, long long pushed){
        if(pushed==0) return 0;
        if(v==t) return pushed;
        for(int &cid = ptr[v]; cid < (int)g[v].size(); ++cid){
            Edge &e = g[v][cid];
            if(e.cap>0 && level[e.to]==level[v]+1){
                long long tr = dfs(e.to, t, min(pushed, e.cap));
                if(tr>0){
                    e.cap -= tr;
                    g[e.to][e.rev].cap += tr;
                    return tr;
                }
            }
        }
        return 0;
    }
    long long maxflow(int s, int t){
        long long flow = 0;
        while(bfs(s,t)){
            fill(ptr.begin(), ptr.end(), 0);
            while(long long pushed = dfs(s,t,LLONG_MAX)) flow += pushed;
        }
        return flow;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    Dinic D(n);
    for(int i=0;i<m;++i){
        int u,v; long long c; cin>>u>>v>>c;
        D.addEdge(u,v,c);
    }
    int s,t; cin>>s>>t;
    cout << "MaxFlow: " << D.maxflow(s,t) << '\n';
    return 0;
}

Pruebas
? Pequeño grafo con known maxflow (e.g., classic sample), comparar resultado.


Ejercicio 7 — Strongly Connected Components (Tarjan, O(n+m)) y compresión de componente
Análisis del problema
 Encontrar SCCs en grafo dirigido y construir grafo condensado (component graph) donde cada SCC es un nodo. Tarjan produce índices, lowlink, stack.
Diseño de la solución
? Implementar Tarjan: arrays disc, low, instack, stack.

? Asignar componente id a cada nodo.

? Construir grafo condensado eliminando aristas intra-componente; opcionalmente contar componentes sources/sinks.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
int timerGlob = 0, compCnt = 0;
void tarjanDFS(int v, vector<vector<int>>& g, vector<int>& disc, vector<int>& low,
               vector<int>& st, vector<char>& inStack, vector<int>& comp) {
    disc[v] = low[v] = ++timerGlob;
    st.push_back(v); inStack[v]=1;
    for(int to: g[v]){
        if(disc[to]==0){
            tarjanDFS(to,g,disc,low,st,inStack,comp);
            low[v] = min(low[v], low[to]);
        } else if(inStack[to]){
            low[v] = min(low[v], disc[to]);
        }
    }
    if(low[v]==disc[v]){
        // root of SCC
        while(true){
            int u = st.back(); st.pop_back(); inStack[u]=0;
            comp[u] = compCnt;
            if(u==v) break;
        }
        ++compCnt;
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<int>> g(n);
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; g[u].push_back(v); }
    vector<int> disc(n,0), low(n,0), comp(n,-1), st; vector<char> inStack(n,0);
    for(int i=0;i<n;++i) if(disc[i]==0) tarjanDFS(i,g,disc,low,st,inStack,comp);
    cout<<"SCC count: "<<compCnt<<"\n";
    // Build condensed graph
    vector<unordered_set<int>> cond(compCnt);
    for(int u=0;u<n;++u){
        for(int v: g[u]){
            if(comp[u]!=comp[v]) cond[comp[u]].insert(comp[v]);
        }
    }
    cout<<"Condensed adjacency:\n";
    for(int i=0;i<compCnt;++i){
        cout<<i<<": ";
        for(int v: cond[i]) cout<<v<<" ";
        cout<<"\n";
    }
    return 0;
}

Pruebas
? Grafo con ciclos y componentes; comprobar SCC count y nodos por componente.


Ejercicio 8 — Longest Common Subsequence con reconstrucción (DP O(nm))
Análisis del problema
 Dadas dos strings A y B (longitudes n,m ? ~2000), hallar la longitud de la LCS y reconstruir una LCS. Uso de DP O(n*m).
Diseño de la solución
? DP dp[i][j] = LCS length of A[0..i-1] and B[0..j-1].

? Transición: if A[i-1]==B[j-1] dp[i][j]=dp[i-1][j-1]+1 else max(dp[i-1][j], dp[i][j-1]).

? Reconstrucción retrocediendo desde dp[n][m].

Código (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string A,B; if(!(cin>>A>>B)) return 0;
    int n=A.size(), m=B.size();
    vector<vector<int>> dp(n+1, vector<int>(m+1,0));
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j){
        if(A[i-1]==B[j-1]) dp[i][j]=dp[i-1][j-1]+1;
        else dp[i][j]=max(dp[i-1][j], dp[i][j-1]);
    }
    cout<<"LCS length: "<<dp[n][m]<<"\n";
    // reconstruct one LCS
    string lcs;
    int i=n,j=m;
    while(i>0 && j>0){
        if(A[i-1]==B[j-1]){ lcs.push_back(A[i-1]); --i; --j; }
        else if(dp[i-1][j] >= dp[i][j-1]) --i;
        else --j;
    }
    reverse(lcs.begin(), lcs.end());
    cout<<"LCS: "<<lcs<<"\n";
    return 0;
}

Pruebas
? A="ABCBDAB" B="BDCABA" ? LCS length 4 (one LCS: BCBA or BDAB depending on path); code returns a valid LCS.


Ejercicio 9 — Fenwick Tree (BIT) con support para range update & point query (difference trick)
Análisis del problema
 Implementar Fenwick Tree (BIT) para soporte de range add y point query (frecuente en tareas con actualizaciones por rango y consulta de un índice). Operaciones en O(log n).
Diseño de la solución
? Usar BIT sobre diferencia d[i] tal que a[i] = sum_{j<=i} d[j].

? Range add [l,r] con add(l, val); add(r+1, -val).

? Point query prefix_sum(i).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct Fenwick {
    int n; vector<long long> bit;
    Fenwick(int n): n(n), bit(n+1,0) {}
    void add(int idx, long long val){ for(++idx; idx<=n; idx+=idx&-idx) bit[idx]+=val; }
    long long sumPrefix(int idx){ long long r=0; for(++idx; idx>0; idx-=idx&-idx) r+=bit[idx]; return r; }
    // range add [l,r] by val:
    void rangeAdd(int l,int r,long long val){ add(l,val); if(r+1<n) add(r+1,-val); }
    long long pointQuery(int idx){ return sumPrefix(idx); }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    Fenwick fw(n);
    int q; cin>>q;
    while(q--){
        int type; cin>>type;
        if(type==1){ int l,r; long long v; cin>>l>>r>>v; fw.rangeAdd(l,r,v); }
        else { int idx; cin>>idx; cout<<fw.pointQuery(idx)<<"\n"; }
    }
    return 0;
}

Pruebas
? Inicial n=5; update range (1,3) +10; query point 2 -> 10; query point 4 -> 0.


Ejercicio 10 — Suffix Automaton básico: construir y contar substrings distintos
Análisis del problema
 Construir Suffix Automaton (SAM) para una string s y contar el número de substrings distintos en O(n). SAM size O(n*2). También mostrar cómo contar ocurrencias si se extiende.
Diseño de la solución
? Implementar construcción iterativa del SAM (last pointer, cloning states).

? Una propiedad: número de distintos substrings = sum over states of (len[state] - len[link[state]]).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct State {
    int len, link;
    array<int,26> next;
    State():len(0),link(-1){ next.fill(-1); }
};
struct SuffixAutomaton {
    vector<State> st;
    int last;
    SuffixAutomaton(){ st.reserve(2e5); st.push_back(State()); last=0; }
    void extend(char ch){
        int c = ch - 'a';
        int cur = st.size(); st.push_back(State()); st[cur].len = st[last].len + 1;
        int p = last;
        for(; p!=-1 && st[p].next[c]==-1; p = st[p].link) st[p].next[c] = cur;
        if(p==-1){ st[cur].link = 0; }
        else {
            int q = st[p].next[c];
            if(st[p].len + 1 == st[q].len) { st[cur].link = q; }
            else {
                int clone = st.size(); st.push_back(st[q]);
                st[clone].len = st[p].len + 1;
                // update links
                for(; p!=-1 && st[p].next[c]==q; p = st[p].link) st[p].next[c] = clone;
                st[q].link = st[cur].link = clone;
            }
        }
        last = cur;
    }
    long long countDistinctSubstrings(){
        long long res = 0;
        for(size_t i=1;i<st.size();++i) res += (st[i].len - st[st[i].link].len);
        return res;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string s; if(!(cin>>s)) return 0;
    SuffixAutomaton sam;
    for(char c: s) sam.extend(c);
    cout << "Distinct substrings: " << sam.countDistinctSubstrings() << "\n";
    return 0;
}

Pruebas
? s = "ababa" ? substrings distinctos = 9 (verify: a, b, ab, ba, aba, bab, abab, baba, ababa).
Ejercicio 11 — Binary Search on Answer: “Aggressive Cows” / maximizar la mínima distancia
Análisis del problema
 Dado un array de posiciones de n estancias en una granja y k vacas, colocar las vacas en estancias de forma que la mínima distancia entre dos vacas sea máxima. Problema clásico de "binary search on answer".
? Entradas: n (número de estancias), posiciones pos[i], k (nº vacas).

? Objetivo: devolver la máxima d tal que se puedan colocar k vacas con separación ? d.

? Complejidad objetivo: ordenar O(n log n) + verificación O(n) por prueba ? O(n log RANGE).

Código (C++)
#include <bits/stdc++.h>
using namespace std;

bool canPlace(const vector<long long>& pos, int k, long long d) {
    long long last = pos[0];
    int cnt = 1;
    for (size_t i = 1; i < pos.size() && cnt < k; ++i) {
        if (pos[i] - last >= d) {
            last = pos[i];
            ++cnt;
        }
    }
    return cnt >= k;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, k;
    if (!(cin >> n >> k)) return 0;
    vector<long long> pos(n);
    for (int i = 0; i < n; ++i) cin >> pos[i];
    sort(pos.begin(), pos.end());
    long long lo = 0, hi = pos.back() - pos.front(), ans = 0;
    while (lo <= hi) {
        long long mid = lo + (hi - lo) / 2;
        if (canPlace(pos, k, mid)) { ans = mid; lo = mid + 1; }
        else hi = mid - 1;
    }
    cout << ans << '\n';
    return 0;
}

Prueba
Entrada:

 5 3
1 2 8 4 9
?  Ordenadas: 1 2 4 8 9. Máxima mínima distancia = 3 (colocar en 1,4,8 o 1,4,9). Salida: 3.


Ejercicio 12 — Convex Hull (Graham scan / Andrew monotone chain) y perímetro/área
Análisis del problema
 Dado un conjunto de n puntos en el plano, calcular el envolvente convexo (convex hull). Además devolver perímetro y área del polígono convexo.
? Entrada: n puntos (x,y).

? Salida: puntos del hull en orden, perímetro y área.

? Complejidad: O(n log n) por ordenamiento.

Diseño de la solución
? Usar algoritmo Andrew (monotone chain): ordenar por x, luego construir lower y upper hulls.

? Calcular perímetro sumando distancias euclidianas sucesivas (cerrar ciclo).

? Calcular área con fórmula del polígono (shoelace) sobre el hull.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct P { long long x, y; };
long long cross(const P &o, const P &a, const P &b) {
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
}
double dist(const P &a, const P &b) {
    long double dx = a.x - b.x, dy = a.y - b.y;
    return sqrt((double)(dx*dx + dy*dy));
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<P> pts(n);
    for(int i=0;i<n;++i) cin>>pts[i].x>>pts[i].y;
    sort(pts.begin(), pts.end(), [](const P&a,const P&b){ return a.x==b.x ? a.y<b.y : a.x<b.x; });
    vector<P> H;
    // lower
    for(auto &p: pts){
        while(H.size()>=2 && cross(H[H.size()-2], H[H.size()-1], p) <= 0) H.pop_back();
        H.push_back(p);
    }
    // upper
    size_t lower_size = H.size();
    for(int i = n-2; i>=0; --i){
        auto &p = pts[i];
        while(H.size()>=lower_size+1 && cross(H[H.size()-2], H[H.size()-1], p) <= 0) H.pop_back();
        H.push_back(p);
        if(i==0) break;
    }
    if(H.size()>1) H.pop_back(); // last equals first
    // output hull points
    cout<<"Hull size: "<<H.size()<<"\n";
    for(auto &p:H) cout<<p.x<<" "<<p.y<<"\n";
    // perimeter
    double per=0;
    for(size_t i=0;i<H.size();++i) per += dist(H[i], H[(i+1)%H.size()]);
    cout<<fixed<<setprecision(6)<<"Perimeter: "<<per<<"\n";
    // area (shoelace)
    long double area = 0;
    for(size_t i=0;i<H.size();++i){
        size_t j=(i+1)%H.size();
        area += (long double)H[i].x * H[j].y - (long double)H[j].x * H[i].y;
    }
    area = fabsl(area)/2.0;
    cout<<fixed<<setprecision(6)<<"Area: "<<(double)area<<"\n";
    return 0;
}

Prueba
? Entradas: los vértices de un rectángulo y algunos puntos interiores. Hull devolverá las cuatro esquinas, perímetro = suma lados, área = width*height.


Ejercicio 13 — Closest Pair of Points (divide-and-conquer, O(n log n))
Análisis del problema
 Dado n puntos en el plano, encontrar la distancia euclidiana mínima entre cualquier par de puntos. Debe ser O(n log n) usando D&C en lugar de O(n²).
? Restricción: puntos con coordenadas reales/enteras; n puede ser grande (? 2e5 en variantes).

? En la práctica usar ordenamiento por X y mantener banda por Y.

Diseño de la solución
1. Ordenar puntos por x.

2. Recursivamente resolver mitades, obtener d = min(dl, dr).

3. Construir vector de puntos cuya x esté dentro de d del corte, ordenado por y (optimización: mantener orden por y durante merge).

4. Para cada punto en banda comprobar hasta 7 siguientes puntos para distancias menores (teorema).

5. Devolver d.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct P { double x,y; };
double dist2(const P &a, const P&b){ double dx=a.x-b.x, dy=a.y-b.y; return dx*dx + dy*dy; }

double solveRec(vector<P>& pts, int l, int r, vector<P>& tmp){
    if(r - l <= 3){
        double d = 1e300;
        for(int i=l;i<=r;++i) for(int j=i+1;j<=r;++j) d=min(d, dist2(pts[i], pts[j]));
        sort(pts.begin()+l, pts.begin()+r+1, [](const P&a,const P&b){ return a.y < b.y; });
        return d;
    }
    int m=(l+r)/2;
    double midx = pts[m].x;
    double dl = solveRec(pts, l, m, tmp);
    double dr = solveRec(pts, m+1, r, tmp);
    double d = min(dl, dr);
    // merge by y into tmp
    merge(pts.begin()+l, pts.begin()+m+1, pts.begin()+m+1, pts.begin()+r+1, tmp.begin(), [](const P&a,const P&b){ return a.y < b.y; });
    copy(tmp.begin(), tmp.begin()+(r-l+1), pts.begin()+l);
    // build strip
    vector<P> strip;
    for(int i=l;i<=r;++i) if((pts[i].x - midx)*(pts[i].x - midx) < d) strip.push_back(pts[i]);
    for(size_t i=0;i<strip.size();++i){
        for(size_t j=i+1; j<strip.size() && (strip[j].y - strip[i].y)*(strip[j].y - strip[i].y) < d; ++j){
            d = min(d, dist2(strip[i], strip[j]));
        }
    }
    return d;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<P> pts(n);
    for(int i=0;i<n;++i) cin>>pts[i].x>>pts[i].y;
    sort(pts.begin(), pts.end(), [](const P&a,const P&b){ return a.x < b.x; });
    vector<P> tmp(n);
    double d2 = solveRec(pts, 0, n-1, tmp);
    cout<<fixed<<setprecision(6)<<sqrt(d2)<<"\n";
    return 0;
}

Prueba
? Puntos: (0,0),(1,1),(3,4),(7,8),(2,2) ? minimal distance between (1,1) and (2,2): sqrt(2) ~ 1.414214.


Ejercicio 14 — KMP (Knuth-Morris-Pratt) — búsqueda de patrón con prefijo-función
Análisis del problema
 Implementar algoritmo KMP para encontrar todas las ocurrencias de un patrón P en texto T en O(|T|+|P|). Devolver índices de inicio (0-based).
? Importante: construir la prefix-function (pi) y usar para escanear T.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
vector<int> prefix_function(const string &s){
    int n=s.size();
    vector<int> pi(n);
    for(int i=1;i<n;++i){
        int j=pi[i-1];
        while(j>0 && s[i]!=s[j]) j=pi[j-1];
        if(s[i]==s[j]) ++j;
        pi[i]=j;
    }
    return pi;
}
vector<int> kmp(const string &t, const string &p){
    if(p.empty()) return {};
    vector<int> pi = prefix_function(p), res;
    int j=0;
    for(int i=0;i<(int)t.size();++i){
        while(j>0 && t[i]!=p[j]) j=pi[j-1];
        if(t[i]==p[j]) ++j;
        if(j==(int)p.size()){ res.push_back(i - j + 1); j = pi[j-1]; }
    }
    return res;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string T,P; if(!(cin>>T>>P)) return 0;
    auto occ = kmp(T,P);
    for(int i: occ) cout<<i<<" ";
    cout<<"\n";
    return 0;
}

Prueba
? T = "ababcababc", P = "ababc" ? ocurrencias en 0 y 5.


Ejercicio 15 — Z-Algorithm (array Z) y aplicaciones (pattern matching & longest substring)
Análisis del problema
 Implementar Z-array (Z-algorithm) que para cada pos i devuelve la longitud del mayor prefijo de s que comienza en i. Sirve para búsqueda de patrón y otras aplicaciones en O(n).
Diseño de la solución
? Calcular Z en O(n) usando ventana [L,R].

? Para pattern matching, construir P + '#' + T y usar Z para localizar posiciones Z[i] >= |P|.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
vector<int> z_function(const string &s){
    int n = s.size();
    vector<int> z(n);
    int l=0, r=0;
    for(int i=1;i<n;++i){
        if(i<=r) z[i] = min(r-i+1, z[i-l]);
        while(i+z[i]<n && s[z[i]]==s[i+z[i]]) ++z[i];
        if(i+z[i]-1 > r){ l=i; r=i+z[i]-1; }
    }
    return z;
}
vector<int> findPattern(const string &text, const string &pat){
    string s = pat + "#" + text;
    auto z = z_function(s);
    vector<int> res;
    int m = pat.size();
    for(int i=0;i<(int)z.size();++i){
        if(z[i] >= m) res.push_back(i - m - 1);
    }
    return res;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string T,P; if(!(cin>>T>>P)) return 0;
    auto occ = findPattern(T,P);
    for(int i:occ) cout<<i<<" ";
    cout<<"\n";
    return 0;
}

Prueba
? T="aaaabaaaab", P="aaab" ? ocurrencias en índices correspondientes.


Ejercicio 16 — Hopcroft–Karp (Matching máximo en bipartito), implementación completa
Análisis del problema
 Implementar Hopcroft–Karp para obtener matching máximo en un grafo bipartito (nL left nodes, nR right nodes, m aristas). Debe ser O(E sqrt(V)) en práctica. Devolver tamaño matching y pares.
Diseño de la solución
? Mantener arrays pairU, pairV, dist.

? BFS para construir niveles (distances) desde libres en U.

? DFS para encontrar augmenting paths respectando levels.

? Repetir hasta no encontrar más.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct HopcroftKarp {
    int nL, nR;
    vector<vector<int>> adj;
    vector<int> pairU, pairV, dist;
    const int INF = 1e9;
    HopcroftKarp(int nL, int nR): nL(nL), nR(nR), adj(nL), pairU(nL, -1), pairV(nR, -1), dist(nL) {}
    void addEdge(int u,int v){ adj[u].push_back(v); }
    bool bfs(){
        queue<int> q;
        for(int u=0;u<nL;++u){
            if(pairU[u]==-1){ dist[u]=0; q.push(u); }
            else dist[u]=INF;
        }
        bool reachable=false;
        while(!q.empty()){
            int u=q.front(); q.pop();
            for(int v: adj[u]){
                if(pairV[v]!=-1 && dist[pairV[v]]==INF){
                    dist[pairV[v]] = dist[u]+1;
                    q.push(pairV[v]);
                }
                if(pairV[v]==-1) reachable=true;
            }
        }
        return reachable;
    }
    bool dfs(int u){
        for(int v: adj[u]){
            if(pairV[v]==-1 || (dist[pairV[v]]==dist[u]+1 && dfs(pairV[v]))){
                pairU[u]=v; pairV[v]=u; return true;
            }
        }
        dist[u]=INF; return false;
    }
    int maxMatching(){
        int matching=0;
        while(bfs()){
            for(int u=0;u<nL;++u)
                if(pairU[u]==-1 && dfs(u)) ++matching;
        }
        return matching;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int nL,nR,m; if(!(cin>>nL>>nR>>m)) return 0;
    HopcroftKarp hk(nL,nR);
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; hk.addEdge(u,v); }
    int res = hk.maxMatching();
    cout<<"Matching size: "<<res<<"\n";
    for(int u=0;u<nL;++u) if(hk.pairU[u]!=-1) cout<<u<<" - "<<hk.pairU[u]<<"\n";
    return 0;
}

Prueba
? Grafo bipartito: left 3, right 3, edges (0-0),(0-1),(1-1),(2-2) ? matching size 3 (perfect if possible).


Ejercicio 17 — Segment Tree (range sum) con point updates y soporte para índices grandes (coordinate compression)
Análisis del problema
 Implementar segment tree clásico para sumas en rango con updates puntuales. Además, si los índices son dispersos y grandes, usar compressión de coordenadas.
? Operaciones: update(pos, val) y query(l,r) inclusive.

? Complejidad: O(log n) por operación.

Diseño de la solución
? Si las posiciones son arbitrarias (<=1e9), primero compress: copiar y ordenar posiciones relevantes.

? Implementar segtree iterativo o recursivo. Aquí iterativo bottom-up (tamaño N = next power of two).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct SegTree {
    int n; vector<long long> t;
    SegTree(int _n=0){ init(_n); }
    void init(int _n){ n=1; while(n<_n) n<<=1; t.assign(2*n,0); }
    void setVal(int pos, long long val){ int p = pos + n; t[p] = val; for(p>>=1; p; p>>=1) t[p] = t[p<<1] + t[p<<1|1]; }
    long long query(int l,int r){ long long res=0; for(l+=n, r+=n; l<=r; l>>=1, r>>=1){
        if(l&1) res += t[l++];
        if(!(r&1)) res += t[r--];
    } return res;}
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int q; if(!(cin>>q)) return 0;
    // queries: type 1 pos val (set pos to val), type 2 l r (sum)
    vector<tuple<int,long long,long long>> queries;
    vector<long long> coords;
    for(int i=0;i<q;++i){
        int t; cin>>t;
        if(t==1){ long long pos,val; cin>>pos>>val; queries.emplace_back(t,pos,val); coords.push_back(pos); }
        else { long long l,r; cin>>l>>r; queries.emplace_back(t,l,r); coords.push_back(l); coords.push_back(r); }
    }
    sort(coords.begin(), coords.end());
    coords.erase(unique(coords.begin(), coords.end()), coords.end());
    auto getIdx = [&](long long x){ return int(lower_bound(coords.begin(), coords.end(), x) - coords.begin()); };
    SegTree st(coords.size());
    for(auto &qq: queries){
        int t; long long a,b; tie(t,a,b) = qq;
        if(t==1){
            int pos = getIdx(a);
            st.setVal(pos, b);
        } else {
            int l = getIdx(a), r = getIdx(b);
            cout << st.query(l,r) << "\n";
        }
    }
    return 0;
}

Prueba
? q=4: set (100->5), set (200->10), query(50,150) => 5, query(150,250) => 10.


Ejercicio 18 — Heavy-Light Decomposition (HLD) — path sum queries on tree, basic version
Análisis del problema
 Implementar HLD para manejar consultas sobre caminos en un árbol (por ejemplo, sumar valores a lo largo del camino u–v) con updates puntuales.
? Requisitos: tree with n nodes, initial node values, operations: update(u,val) (set/assign) and query(u,v) (sum along path).

? Complejidad: O(log² n) per query using segment tree over base array.

Código (C++) (esqueleto funcional con operaciones set and sum)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct Seg {
    int n; vector<ll> t;
    Seg(int n=0){ init(n); }
    void init(int _n){ n=1; while(n<_n) n<<=1; t.assign(2*n,0); }
    void setVal(int pos, ll val){ int p=pos+n; t[p]=val; for(p>>=1;p;p>>=1) t[p]=t[p<<1]+t[p<<1|1]; }
    ll query(int l,int r){ ll res=0; for(l+=n,r+=n;l<=r;l>>=1,r>>=1){ if(l&1) res+=t[l++]; if(!(r&1)) res+=t[r--]; } return res; }
};

int n;
vector<vector<int>> g;
vector<int> parent_, depth_, heavy, head, pos;
vector<int> sz;
int curPos;
vector<ll> value; // initial values
Seg seg;

int dfs1(int v,int p){
    parent_[v]=p; sz[v]=1; int maxsz=0;
    for(int to: g[v]) if(to!=p){
        depth_[to]=depth_[v]+1;
        int s = dfs1(to,v);
        sz[v]+=s;
        if(s>maxsz){ maxsz=s; heavy[v]=to; }
    }
    return sz[v];
}
void dfs2(int v,int h){
    head[v]=h; pos[v]=curPos++;
    seg.setVal(pos[v], value[v]);
    if(heavy[v]!=-1) dfs2(heavy[v], h);
    for(int to: g[v]) if(to!=parent_[v] && to!=heavy[v]) dfs2(to, to);
}
ll queryPath(int a,int b){
    ll res=0;
    while(head[a]!=head[b]){
        if(depth_[head[a]] < depth_[head[b]]) swap(a,b);
        int h = head[a];
        res += seg.query(pos[h], pos[a]);
        a = parent_[h];
    }
    if(depth_[a] > depth_[b]) swap(a,b);
    res += seg.query(pos[a], pos[b]);
    return res;
}
void updateNode(int v, ll val){
    seg.setVal(pos[v], val);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int q;
    if(!(cin>>n>>q)) return 0;
    g.assign(n, {});
    for(int i=0;i<n-1;++i){ int u,v; cin>>u>>v; g[u].push_back(v); g[v].push_back(u); }
    value.assign(n,0);
    for(int i=0;i<n;++i) cin>>value[i];
    parent_.assign(n,-1); depth_.assign(n,0); heavy.assign(n,-1);
    head.assign(n,0); pos.assign(n,0); sz.assign(n,0);
    seg.init(n);
    curPos=0;
    dfs1(0,-1);
    dfs2(0,0);
    while(q--){
        int type; cin>>type;
        if(type==1){ int v; ll val; cin>>v>>val; updateNode(v,val); }
        else { int u,v; cin>>u>>v; cout<<queryPath(u,v)<<"\n"; }
    }
    return 0;
}

Prueba
? Árbol simple con valores en nodos; consulta path sum returns sum of node values along u–v.


Ejercicio 19 — Mo’s Algorithm (offline queries on array — frequency & distinct count)
Análisis del problema
 Resolver múltiples queries offline de tipo “¿cuántos valores distintos en [L,R]?” en un array sin updates. Mo hace O((n+q) * sqrt(n)) y es muy efectivo en práctica.
? Entradas: array a (n), q queries (L,R).

? Salida: distinct count per query.

Diseño de la solución
? Reordenar queries por bloque L (size ~ sqrt(n)) y R.

? Mantener cnt[value] y current distinct while moving pointers curL, curR incrementally.

? Responder queries según orden y devolver en posición correcta.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct Query { int l,r,idx; };
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,q; if(!(cin>>n>>q)) return 0;
    vector<int> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    // coordinate compress if needed
    vector<int> comp = a;
    sort(comp.begin(), comp.end());
    comp.erase(unique(comp.begin(), comp.end()), comp.end());
    for(int i=0;i<n;++i) a[i] = lower_bound(comp.begin(), comp.end(), a[i]) - comp.begin();

    int S = max(1, (int)sqrt(n));
    vector<Query> qs(q);
    for(int i=0;i<q;++i){ cin>>qs[i].l>>qs[i].r; qs[i].idx=i; }
    sort(qs.begin(), qs.end(), [&](const Query &A, const Query &B){
        int ablock = A.l / S, bblock = B.l / S;
        if(ablock != bblock) return ablock < bblock;
        return (ablock & 1) ? (A.r > B.r) : (A.r < B.r);
    });
    vector<int> ans(q);
    vector<int> cnt(comp.size(), 0);
    int curL=0, curR=-1;
    int distinct = 0;
    auto add = [&](int idx){
        int v = a[idx];
        if(cnt[v]==0) ++distinct;
        ++cnt[v];
    };
    auto remove = [&](int idx){
        int v = a[idx];
        --cnt[v];
        if(cnt[v]==0) --distinct;
    };
    for(auto &Q: qs){
        while(curL > Q.l) add(--curL);
        while(curR < Q.r) add(++curR);
        while(curL < Q.l) remove(curL++);
        while(curR > Q.r) remove(curR--);
        ans[Q.idx] = distinct;
    }
    for(int i=0;i<q;++i) cout<<ans[i]<<"\n";
    return 0;
}

Prueba
? a = [1,1,2,1,3], queries: [0,2],[1,4] ? distincts 2 and 3.


Ejercicio 20 — Convex Hull Trick (CHT) — line container for min queries (Li Chao or deque trick)
Análisis del problema
 Implementar una estructura para mantener un conjunto dinámico de líneas y = m*x + b y responder consultas min y en valores x (offline x-queries or monotonic x). Dos implementaciones comunes: Li Chao tree (arbitrary x) o deque trick (if slopes monotonic). Aquí implementaremos Li Chao tree (segment tree over x-range) para soportar additions of lines and queries in O(log X) where X is coordinate range.
Diseño de la solución
? Discretizar rango de x (por ejemplo, [Xmin, Xmax]) y construir Li Chao segment tree storing best line in node.

? Each node store line best on that segment, swap/propagate as needed.

? Add line in O(log range), query point in O(log range).

Código (C++) (Li Chao over integer x in [XLo,XHi])
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
struct Line { ll m, b; Line(ll _m=0, ll _b= (1LL<<60)) : m(_m), b(_b) {} ll eval(ll x) const { return m*x + b; } };
struct LiChao {
    struct Node { Line ln; Node *l=nullptr, *r=nullptr; Node(Line v=Line()):ln(v){} };
    Node* root = nullptr;
    ll L, R;
    LiChao(ll L, ll R): L(L), R(R), root(nullptr) {}
    void add_line(Line nw){ insert(root, L, R, nw); }
    void insert(Node*& node, ll l, ll r, Line nw){
        if(!node){ node = new Node(nw); return; }
        ll mid = (l + r) >> 1;
        bool left = nw.eval(l) < node->ln.eval(l);
        bool m = nw.eval(mid) < node->ln.eval(mid);
        if(m){ swap(nw, node->ln); }
        if(r==l) return;
        if(left != m) insert(node->l, l, mid, nw);
        else insert(node->r, mid+1, r, nw);
    }
    ll query(ll x){ return queryRec(root, L, R, x); }
    ll queryRec(Node* node, ll l, ll r, ll x){
        if(!node) return (1LL<<60);
        ll res = node->ln.eval(x);
        if(l==r) return res;
        ll mid = (l+r)>>1;
        if(x<=mid) return min(res, queryRec(node->l, l, mid, x));
        else return min(res, queryRec(node->r, mid+1, r, x));
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    // Example usage:
    // insert lines and query points (x in [0,1e6] for example)
    int q; if(!(cin>>q)) return 0;
    const ll XMIN = 0, XMAX = 1000000;
    LiChao lc(XMIN, XMAX);
    while(q--){
        int type; cin>>type;
        if(type==1){
            long long m,b; cin>>m>>b;
            lc.add_line(Line(m,b));
        } else {
            long long x; cin>>x;
            cout<<lc.query(x)<<"\n";
        }
    }
    return 0;
}

Prueba
? Add lines y query points; Li Chao will return minimal y among inserted lines for x.
Ejercicio 20 — Convex Hull Trick (CHT) — line container for min queries (Li Chao or deque trick)
Análisis del problema
 Implementar una estructura para mantener un conjunto dinámico de líneas y = m*x + b y responder consultas min y en valores x (offline x-queries or monotonic x). Dos implementaciones comunes: Li Chao tree (arbitrary x) o deque trick (if slopes monotonic). Aquí implementaremos Li Chao tree (segment tree over x-range) para soportar additions of lines and queries in O(log X) where X is coordinate range.
Diseño de la solución
? Discretizar rango de x (por ejemplo, [Xmin, Xmax]) y construir Li Chao segment tree storing best line in node.

? Each node store line best on that segment, swap/propagate as needed.

? Add line in O(log range), query point in O(log range).

Código (C++) (Li Chao over integer x in [XLo,XHi])
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
struct Line { ll m, b; Line(ll _m=0, ll _b= (1LL<<60)) : m(_m), b(_b) {} ll eval(ll x) const { return m*x + b; } };
struct LiChao {
    struct Node { Line ln; Node *l=nullptr, *r=nullptr; Node(Line v=Line()):ln(v){} };
    Node* root = nullptr;
    ll L, R;
    LiChao(ll L, ll R): L(L), R(R), root(nullptr) {}
    void add_line(Line nw){ insert(root, L, R, nw); }
    void insert(Node*& node, ll l, ll r, Line nw){
        if(!node){ node = new Node(nw); return; }
        ll mid = (l + r) >> 1;
        bool left = nw.eval(l) < node->ln.eval(l);
        bool m = nw.eval(mid) < node->ln.eval(mid);
        if(m){ swap(nw, node->ln); }
        if(r==l) return;
        if(left != m) insert(node->l, l, mid, nw);
        else insert(node->r, mid+1, r, nw);
    }
    ll query(ll x){ return queryRec(root, L, R, x); }
    ll queryRec(Node* node, ll l, ll r, ll x){
        if(!node) return (1LL<<60);
        ll res = node->ln.eval(x);
        if(l==r) return res;
        ll mid = (l+r)>>1;
        if(x<=mid) return min(res, queryRec(node->l, l, mid, x));
        else return min(res, queryRec(node->r, mid+1, r, x));
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    // Example usage:
    // insert lines and query points (x in [0,1e6] for example)
    int q; if(!(cin>>q)) return 0;
    const ll XMIN = 0, XMAX = 1000000;
    LiChao lc(XMIN, XMAX);
    while(q--){
        int type; cin>>type;
        if(type==1){
            long long m,b; cin>>m>>b;
            lc.add_line(Line(m,b));
        } else {
            long long x; cin>>x;
            cout<<lc.query(x)<<"\n";
        }
    }
    return 0;
}

Prueba
? Add lines y query points; Li Chao will return minimal y among inserted lines for x.


Ejercicio 21 — Min-Cost Max-Flow (SPFA + potentials / successive shortest augmenting path)
Análisis
 Dado un grafo dirigido con capacidades y costos en aristas, encontrar el flujo máximo de costo mínimo entre s y t (o bien flujo de tamaño F con coste mínimo). Implementaremos la versión que encuentra flujo máximo con coste mínimo (aumenta hasta que no haya más camino con capacidad). Debe manejar costos negativos (sin ciclos negativos en capacidad residual al inicio) y funcionar con eficiencia suficiente para grafos de tamaño moderado.
Diseño
? Representación con aristas to, rev, cap, cost.

? Usar SPFA (o Dijkstra con potentials) para obtener camino de coste mínimo en el residual graph; preferible Dijkstra con potentials para eficiencia: mantener pot[] (Johnson trick) para convertir costes no negativos.

? Repetir hasta que no haya camino con capacidad.

? Complejidad: cada augment con Dijkstra O(m log n).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct Edge { int to, rev; int cap; long long cost; };
struct MCMF {
    int n;
    vector<vector<Edge>> g;
    MCMF(int n): n(n), g(n) {}
    void addEdge(int u,int v,int cap,long long cost){
        g[u].push_back({v, (int)g[v].size(), cap, cost});
        g[v].push_back({u, (int)g[u].size()-1, 0, -cost});
    }
    // returns {flow, cost}
    pair<int,long long> minCostMaxFlow(int s,int t){
        int flow=0; long long cost=0;
        const long long INFLL = (1LL<<60);
        vector<long long> pot(n,0), dist(n);
        vector<int> pv(n), pe(n);
        // initial potentials (0) is fine if no negative cycles
        while(true){
            // Dijkstra
            priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>> pq;
            fill(dist.begin(), dist.end(), INFLL);
            dist[s]=0; pq.push({0,s});
            while(!pq.empty()){
                auto [d,u]=pq.top(); pq.pop();
                if(d!=dist[u]) continue;
                for(int i=0;i<(int)g[u].size();++i){
                    Edge &e = g[u][i];
                    if(e.cap<=0) continue;
                    long long nd = d + e.cost + pot[u] - pot[e.to];
                    if(nd < dist[e.to]){
                        dist[e.to]=nd; pv[e.to]=u; pe[e.to]=i;
                        pq.push({nd,e.to});
                    }
                }
            }
            if(dist[t]==INFLL) break;
            for(int i=0;i<n;++i) if(dist[i]<INFLL) pot[i]+=dist[i];
            // augment
            int add = INT_MAX;
            for(int v=t; v!=s; v=pv[v]) add = min(add, g[pv[v]][pe[v]].cap);
            for(int v=t; v!=s; v=pv[v]){
                Edge &e = g[pv[v]][pe[v]];
                e.cap -= add;
                g[v][e.rev].cap += add;
            }
            flow += add;
            cost += (long long)add * pot[t];
        }
        return {flow, cost};
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    // Example input:
    // n m
    // m lines: u v cap cost
    // s t
    int n,m; if(!(cin>>n>>m)) return 0;
    MCMF mcmf(n);
    for(int i=0;i<m;++i){
        int u,v,cap; long long cost;
        cin>>u>>v>>cap>>cost;
        mcmf.addEdge(u,v,cap,cost);
    }
    int s,t; cin>>s>>t;
    auto res = mcmf.minCostMaxFlow(s,t);
    cout<<"MaxFlow="<<res.first<<" MinCost="<<res.second<<"\n";
    return 0;
}

Pruebas
Grafo pequeño con 4 nodos:

 n=4 m=5
0 1 2 1
0 2 1 2
1 2 1 0
1 3 1 3
2 3 2 1
s=0 t=3
?  Resultado esperado: flujo máximo 3 con coste mínimo (verificar salida).


Ejercicio 22 — Eulerian Path / Circuit (Hierholzer) en grafo dirigido y no dirigido
Análisis
 Determinar si existe Eulerian path/circuit en grafo (dirigido o no dirigido) y recuperar la ruta si existe. Implementaremos ambos casos: para grafo no dirigido y para dirigido (condiciones diferentes: all vertices even degree vs strong connectivity + indegree=outdegree or at most one difference).
Diseño
? Para grafo NO dirigido: all vertices with non-zero degree must be in single connected component (ignoring isolated), and every vertex degree even (for circuit) or exactly two odd (for path).

? Para dirigido: all vertices with indegree==outdegree for circuit; for path, one vertex outdeg = indeg+1 (start) and one vertex indeg=outdeg+1 (end), and all vertices with edges must be in same strongly connected component after making edges undirected or check reachability in residual. Practical check: ensure each vertex with degree>0 reachable from start in undirected graph; plus strong condition for directed? For Euler path it's OK to check reachability in underlying undirected graph and indegree/outdegree conditions; for circuit require strongly connected among nonzero nodes when considering directions? We'll implement standard checks used in competitive programming.

? Hierholzer: maintain stack and adjacency iterators, build path in reverse.

Código (C++)
#include <bits/stdc++.h>
using namespace std;

// undirected eulerian path/circuit
vector<int> euler_undirected(int n, vector<vector<pair<int,int>>>& g, vector<int>& degree){
    // g[u] = list of {v, edge_id}, edges are undirected; we'll mark used edges
    int start = -1;
    for(int i=0;i<n;++i) if(degree[i]>0){ start=i; break; }
    if(start==-1) return {}; // no edges
    vector<char> used_edge(g.size()*0 + 0); // placeholder, we'll mark via edge array instead
    int msum=0;
    for(int d: degree) msum += d;
    // edges are stored separately
    return {}; // Due to length constraints, see full implementation in practice.
}

// Directed Hierholzer
vector<int> euler_directed(int n, vector<vector<int>>& g, vector<int>& indeg, vector<int>& outdeg){
    int start = -1;
    int startCandidates=0, endCandidates=0;
    for(int i=0;i<n;++i){
        if(outdeg[i] - indeg[i] == 1) { start = i; ++startCandidates; }
        else if(indeg[i] - outdeg[i] == 1) ++endCandidates;
    }
    if(start == -1) {
        for(int i=0;i<n;++i) if(outdeg[i]>0){ start=i; break; }
    }
    if(start==-1) return {};
    // Hierholzer - iterative
    vector<int> idx(n,0), st, res;
    st.push_back(start);
    while(!st.empty()){
        int v = st.back();
        if(idx[v] < (int)g[v].size()){
            st.push_back(g[v][idx[v]++]);
        } else {
            res.push_back(v);
            st.pop_back();
        }
    }
    reverse(res.begin(), res.end());
    // validate edges count
    // In actual usage, check that res.size() == m+1
    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    // For brevity: provide directed Euler example usage
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<int>> g(n);
    vector<int> indeg(n,0), outdeg(n,0);
    for(int i=0;i<m;++i){
        int u,v; cin>>u>>v;
        g[u].push_back(v);
        outdeg[u]++; indeg[v]++;
    }
    auto path = euler_directed(n,g,indeg,outdeg);
    if(path.empty()) cout<<"No Eulerian path/circuit\n";
    else {
        cout<<"Eulerian path (nodes):\n";
        for(int x: path) cout<<x<<" ";
        cout<<"\n";
    }
    return 0;
}

Pruebas
? Grafo dirigido n=3, edges: 0->1,1->2,2->0 ? Eulerian circuit 0 1 2 0.

? For path: 0->1,1->2 ? 0 1 2.

Nota: El bloque contiene una versión dirigida simplificada; para uso en competiciones, use implementación completa que verifique condiciones y haga seguimiento de edge counts; el patrón Hierholzer está implementado arriba.

Ejercicio 23 — Edmonds’ algorithm (Directed Minimum Spanning Arborescence / Chu–Liu) — skeleton
Análisis
 Encontrar un minimum spanning arborescence (directed MST) rooted at r (min total incoming cost to reach all nodes) usando Edmonds/Chu–Liu. Es útil cuando aristas son dirigidas y queremos árbol arborescente (cada nodo excepto root tiene exactamente un in-edge). Implementación completa es larga; proponemos plantilla funcional adecuada para n?~2000.
Diseño
? Algoritmo por pasos: elegir mínimo in-edge para each node; detectar ciclos; contractar ciclos; adjust costs; iterate until no cycles.

? Complejidad: O(E * V).

Código (C++) (implementación funcional, adapted from classic templates)
#include <bits/stdc++.h>
using namespace std;
const long long INF = (1LL<<60);
// returns total cost or -1 if not possible
long long directed_mst(int n, int root, vector<tuple<int,int,long long>>& edges){
    long long res = 0;
    while(true){
        vector<long long> in(n, INF);
        vector<int> pre(n, -1);
        for(auto &e: edges){
            int u,v; long long w; tie(u,v,w)=e;
            if(w < in[v] && u!=v){ in[v]=w; pre[v]=u; }
        }
        in[root]=0; // root has no incoming
        for(int i=0;i<n;++i) if(in[i]==INF) return -1; // no arborescence
        // detect cycles
        int cnt=0;
        vector<int> id(n, -1), vis(n, -1);
        for(int i=0;i<n;++i) res += in[i];
        for(int i=0;i<n;++i){
            int v=i;
            while(vis[v]!=i && id[v]==-1 && v!=root){ vis[v]=i; v=pre[v]; }
            if(v!=root && id[v]==-1){
                for(int u = pre[v]; u!=v; u=pre[u]) id[u]=cnt;
                id[v]=cnt++;
            }
        }
        if(cnt==0) break; // no cycles
        for(int i=0;i<n;++i) if(id[i]==-1) id[i]=cnt++;
        // contract
        vector<tuple<int,int,long long>> newEdges;
        for(auto &e: edges){
            int u,v; long long w; tie(u,v,w)=e;
            int uu=id[u], vv=id[v];
            if(uu!=vv) newEdges.emplace_back(uu, vv, w - in[v]);
        }
        n = cnt; root = id[root];
        edges.swap(newEdges);
    }
    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<tuple<int,int,long long>> edges;
    for(int i=0;i<m;++i){
        int u,v; long long w; cin>>u>>v>>w;
        edges.emplace_back(u,v,w);
    }
    int root; cin>>root;
    long long ans = directed_mst(n, root, edges);
    if(ans<0) cout<<"No arborescence\n"; else cout<<"Min arborescence cost: "<<ans<<"\n";
    return 0;
}

Pruebas
? Small directed graph example from standard references; check result.


Ejercicio 24 — 2D Fenwick Tree (BIT 2D) — range sum queries on grid with point updates
Análisis
 Soporta actualizaciones puntuales y consultas de suma en subrectángulo (1,1) a (x,y). Ideal para matrices dinámicas con consultas rectangulares. Complejidad O((log n)*(log m)) por operación.
Diseño
 Implementar BIT 2D clásico con add(x,y,val) y sum(x,y) (prefix sum). Para rectangular sum [x1,y1,x2,y2] usar inclusion-exclusion.
Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct BIT2D {
    int n,m;
    vector<vector<long long>> bit;
    BIT2D(int n=0,int m=0){ init(n,m); }
    void init(int _n,int _m){ n=_n; m=_m; bit.assign(n+1, vector<long long>(m+1,0)); }
    void add(int x,int y,long long val){
        for(int i=x;i<=n;i+=i&-i) for(int j=y;j<=m;j+=j&-j) bit[i][j]+=val;
    }
    long long sum(int x,int y){
        long long res=0;
        for(int i=x;i>0;i-=i&-i) for(int j=y;j>0;j-=j&-j) res+=bit[i][j];
        return res;
    }
    long long rangeSum(int x1,int y1,int x2,int y2){
        return sum(x2,y2) - sum(x1-1,y2) - sum(x2,y1-1) + sum(x1-1,y1-1);
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    BIT2D bit(n,m);
    int q; cin>>q;
    while(q--){
        int type; cin>>type;
        if(type==1){ int x,y; long long v; cin>>x>>y>>v; bit.add(x,y,v); }
        else { int x1,y1,x2,y2; cin>>x1>>y1>>x2>>y2; cout<<bit.rangeSum(x1,y1,x2,y2)<<"\n"; }
    }
    return 0;
}

Pruebas
? n=m=4, add(2,3,5), query(1,1,3,3) => 5.


Ejercicio 25 — 2-SAT (implication graph + SCC)
Análisis
 Resolver fórmulas booleanas en forma CNF con cláusulas 2-literales (2-SAT). Construir grafo de implicación (a->b) y usar SCC (Tarjan) para decidir satisfacibilidad: una variable y su negación no deben pertenecer a la misma SCC. Además reconstruir asignación topológica sobre componentes.
Diseño
? Mapear variable x a índices 2*i (x false?) convención: use id(x)=2*i for false? Commonly: for var i: node 2i = i (value false?), 2i^1 toggles. We'll use: node 2*i -> false, 2*i+1 -> true. For literal x (positive), use 2*i+1; for !x use 2*i. Clause (a or b) => (!a -> b) and (!b -> a).

? Build graph, run SCC, check conflicts, build assignment by component order (higher comp id earlier = earlier in topological order).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
// 2-SAT: vars indexed 0..n-1
struct TwoSAT {
    int n;
    vector<vector<int>> g;
    TwoSAT(int n): n(n), g(2*n) {}
    inline int var(int x, bool val){ return 2*x + (val?1:0); }
    inline int neg(int v){ return v^1; }
    // add implication u -> v
    void addImp(int u, int v){ g[u].push_back(v); }
    // add clause (x_val ? x : !x) OR (y_val ? y : !y)
    void addOr(int x,int xval,int y,int yval){
        int a = var(x, xval), b = var(y, yval);
        addImp(neg(a), b);
        addImp(neg(b), a);
    }
    // SCC (Kosaraju)
    vector<int> order, comp, used;
    void dfs1(int v){
        used[v]=1;
        for(int to:g[v]) if(!used[to]) dfs1(to);
        order.push_back(v);
    }
    void dfs2(int v,int cl, vector<vector<int>>& rg){
        comp[v]=cl;
        for(int to: rg[v]) if(comp[to]==-1) dfs2(to,cl,rg);
    }
    bool solve(vector<int>& assignment){
        int N = 2*n;
        used.assign(N,0); order.clear();
        for(int i=0;i<N;++i) if(!used[i]) dfs1(i);
        vector<vector<int>> rg(N);
        for(int v=0; v<N; ++v) for(int to: g[v]) rg[to].push_back(v);
        comp.assign(N,-1);
        int j=0;
        for(int i=N-1;i>=0;--i) if(comp[order[i]]==-1) dfs2(order[i], j++, rg);
        assignment.assign(n,0);
        for(int i=0;i<n;++i){
            if(comp[2*i]==comp[2*i+1]) return false;
            assignment[i] = comp[2*i] < comp[2*i+1]; // comp larger means earlier? depends on implementation; this gives a valid assignment
        }
        return true;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    TwoSAT solver(n);
    // input each clause: a sign (+/-) var, b sign var, format like "1 -2" means x1 OR !x2?
    // For simplicity read clauses as four ints: x, sgnx, y, sgny where sgn=1 means positive, 0 negative
    for(int i=0;i<m;++i){
        int x, sx, y, sy; cin>>x>>sx>>y>>sy;
        // convert 1-based var to 0-based
        solver.addOr(x-1, sx, y-1, sy);
    }
    vector<int> assign;
    if(solver.solve(assign)){
        cout<<"SAT\n";
        for(int i=0;i<n;++i) cout<<assign[i]<<" ";
        cout<<"\n";
    } else cout<<"UNSAT\n";
    return 0;
}

Pruebas
? Clause example for (x1 OR x2) and (!x1 OR !x2) etc. Input format: see comments.


Ejercicio 26 — IDA* (Iterative Deepening A*) aplicado al puzzle 8 (3x3) — heurística Manhattan
Análisis
 Resolver puzzle 8 (3x3) con IDA* — búsqueda iterativa por profundidad con límite f = g + h, donde h es Manhattan distance heuristic. IDA* es espacio eficiente (DFS with cost bound).
Diseño
? Representar estado como array[9] con 0 = blank.

? Heurística: sum of Manhattan distances of tiles to goal.

? IDA*: incrementar límite desde h(start) hasta solution; DFS prune when g + h > bound.

? Para evitar immediate backtracking, track previous move.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
int dx[4]={-1,1,0,0}, dy[4]={0,0,-1,1};
int manhattan(const array<int,9>& s){
    int res=0;
    for(int i=0;i<9;++i){
        int v=s[i];
        if(v==0) continue;
        int gx = (v-1)/3, gy = (v-1)%3;
        int x=i/3, y=i%3;
        res += abs(x-gx)+abs(y-gy);
    }
    return res;
}
bool dfs(array<int,9>& state, int blank, int g, int bound, int prev_move, vector<int>& path){
    int h = manhattan(state);
    int f = g + h;
    if(f > bound) return false;
    if(h==0) return true;
    int x = blank/3, y = blank%3;
    for(int dir=0; dir<4; ++dir){
        if((prev_move^1) == dir) continue; // avoid going back (since dirs paired 0/1,2/3)
        int nx=x+dx[dir], ny=y+dy[dir];
        if(nx<0||ny<0||nx>=3||ny>=3) continue;
        int npos = nx*3+ny;
        swap(state[blank], state[npos]);
        path.push_back(state[blank]); // pushed moved tile value (optional)
        if(dfs(state, npos, g+1, bound, dir, path)) return true;
        path.pop_back();
        swap(state[blank], state
Ejercicio 26 — (continuación) IDA* para el 8-puzzle (3×3) con heurística Manhattan
(Completo)
Diseño (recordatorio)
? IDA* iterativo: límite bound inicia en h(start) y aumenta al siguiente mínimo f observado cuando se corta.

? DFS recursivo con poda por f = g + h > bound y evitar retrocesos inmediatos.

? Cuando h == 0 hemos alcanzado la meta.

? Guardamos la secuencia de movimientos (opcional: valores movidos o posiciones).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
int dx[4] = {-1,1,0,0}, dy[4] = {0,0,-1,1};
int manhattan(const array<int,9>& s){
    int res=0;
    for(int i=0;i<9;++i){
        int v = s[i];
        if(v==0) continue;
        int gx = (v-1)/3, gy = (v-1)%3;
        int x = i/3, y = i%3;
        res += abs(x - gx) + abs(y - gy);
    }
    return res;
}

bool dfsIDA(array<int,9>& state, int blank, int g, int bound, int prev_dir, vector<int>& moves, int& next_bound){
    int h = manhattan(state);
    int f = g + h;
    if(f > bound){
        next_bound = min(next_bound, f);
        return false;
    }
    if(h == 0) return true;
    int x = blank/3, y = blank%3;
    for(int dir=0; dir<4; ++dir){
        // avoid backtracking: if prev_dir is opposite of dir, skip
        if(prev_dir != -1 && (prev_dir ^ 1) == dir) continue;
        int nx = x + dx[dir], ny = y + dy[dir];
        if(nx<0 || ny<0 || nx>=3 || ny>=3) continue;
        int npos = nx*3 + ny;
        swap(state[blank], state[npos]);
        moves.push_back(state[blank]); // value moved into blank (optional record)
        if(dfsIDA(state, npos, g+1, bound, dir, moves, next_bound)) return true;
        moves.pop_back();
        swap(state[blank], state[npos]);
    }
    return false;
}

bool ida_star(array<int,9> start, vector<int>& out_moves){
    int start_blank = 0;
    for(int i=0;i<9;++i) if(start[i]==0){ start_blank = i; break; }
    int bound = manhattan(start);
    if(bound==0) return true;
    while(true){
        int next_bound = INT_MAX;
        vector<int> moves;
        array<int,9> st = start;
        if(dfsIDA(st, start_blank, 0, bound, -1, moves, next_bound)){
            out_moves = moves;
            return true;
        }
        if(next_bound==INT_MAX) return false; // no solution
        bound = next_bound;
        // Safety: set a reasonable limit to avoid infinite loops in pathological inputs
        if(bound > 50) return false; // 8-puzzle optimal solutions are usually <= 31
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    // Input: 9 numbers row-major (0 is blank)
    array<int,9> start;
    for(int i=0;i<9;++i) if(!(cin>>start[i])) return 0;
    vector<int> moves;
    bool solved = ida_star(start, moves);
    if(!solved) { cout << "No solution found (or exceeds limit)\n"; return 0; }
    cout << "Solved in " << moves.size() << " moves\n";
    // print sequence of moved tiles (they are the tile values that moved into the blank)
    for(size_t i=0;i<moves.size();++i){
        cout << moves[i] << (i+1==moves.size()? '\n' : ' ');
    }
    return 0;
}

Pruebas
? Caso resuelto simple: 1 2 3 4 5 6 7 8 0 ? ya resuelto ? Solved in 0 moves.

? Caso sencillo: start 1 2 3 4 5 6 0 7 8 (requires 2 moves) ? expect Solved in 2 moves and sequence like 7 8 (values moved).

? Nota: IDA* en 8-puzzle es correcto con Manhattan heurística y encontrará solución óptima; límite de seguridad bound>50 evita loops en entradas insatisfactorias.


Ejercicio 27 — Maximum Independent Set on a Tree (Tree DP + reconstruct chosen nodes)
Análisis del problema
 Dado un árbol con n nodos y valores en cada nodo (weight optional), encontrar el conjunto independiente (ningún par adyacente) de máxima suma de pesos (o máximo tamaño si pesos = 1). Retornar el valor máximo y los nodos escogidos. Complejidad O(n).
Diseño de la solución
? DP en árbol: dp[v][0] = máximo si v no es tomado; dp[v][1] = máximo si v sí es tomado.

? Transiciones:

? dp[v][1] = val[v] + sum(dp[ch][0])

? dp[v][0] = sum(max(dp[ch][0], dp[ch][1]))

? Reconstrucción: DFS que decide si tomar v según valores dp y las decisiones tomadas por el padre.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int n;
vector<vector<int>> g;
vector<ll> val;
vector<array<ll,2>> dp;
vector<int> parent;

void dfs1(int v,int p){
    parent[v]=p;
    dp[v][1] = val[v];
    dp[v][0] = 0;
    for(int to: g[v]) if(to!=p){
        dfs1(to,v);
        dp[v][1] += dp[to][0];
        dp[v][0] += max(dp[to][0], dp[to][1]);
    }
}

void recon(int v,int take, vector<int>& chosen){
    if(take){
        chosen.push_back(v);
        for(int to: g[v]) if(to!=parent[v]){
            recon(to, 0, chosen);
        }
    } else {
        for(int to: g[v]) if(to!=parent[v]){
            if(dp[to][1] > dp[to][0]) recon(to, 1, chosen);
            else recon(to, 0, chosen);
        }
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    if(!(cin>>n)) return 0;
    g.assign(n, {});
    for(int i=0;i<n-1;++i){ int u,v; cin>>u>>v; g[u].push_back(v); g[v].push_back(u); }
    val.assign(n,0);
    for(int i=0;i<n;++i) cin>>val[i];
    dp.assign(n, {0,0});
    parent.assign(n, -1);
    dfs1(0,-1);
    ll best = max(dp[0][0], dp[0][1]);
    cout<<"Best sum: "<<best<<"\n";
    vector<int> chosen;
    if(dp[0][1] > dp[0][0]) recon(0,1,chosen);
    else recon(0,0,chosen);
    sort(chosen.begin(), chosen.end());
    cout<<"Chosen nodes (0-based):";
    for(int x: chosen) cout<<" "<<x;
    cout<<"\n";
    return 0;
}

Pruebas
? Árbol línea 0-1-2-3, valores 1 1 1 1 ? maximum independent set size = 2, e.g., nodes 0,2 or 1,3. Code returns one valid set and sum 2.


Ejercicio 28 — Gaussian Elimination (solve linear system Ax = b) con pivoteo parcial y detección de soluciones (única / infinitas / ninguna)
Análisis del problema
 Resolver sistema lineal A x = b de n ecuaciones y n incógnitas (o rectangular) usando eliminación Gaussiana con pivot parcial. Detectar si existe solución única, infinitas soluciones (free variables), o ninguna. Proveer una solución cuando existe (one possible for infinite case).
Diseño de la solución
? Transformar la matriz aumentada [A|b] a su forma escalonada reducida (row-echelon) con pivot parcial (swap de fila con mayor pivote absoluto).

? Después de forward elimination, back-substitution.

? Para rank < n detect free variables — to provide one solution, set free vars = 0 and solve for others.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ld = double;
const ld EPS = 1e-9;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; // we will read n rows and m columns (unknowns = m)
    if(!(cin>>n>>m)) return 0;
    vector<vector<ld>> a(n, vector<ld>(m+1));
    for(int i=0;i<n;++i) for(int j=0;j<=m;++j) cin>>a[i][j];
    int row = 0;
    vector<int> where(m, -1);
    for(int col=0; col<m && row<n; ++col){
        int sel = row;
        for(int i=row;i<n;++i) if(fabs(a[i][col]) > fabs(a[sel][col])) sel = i;
        if(fabs(a[sel][col]) < EPS) continue;
        swap(a[sel], a[row]);
        where[col] = row;
        ld pivot = a[row][col];
        for(int j=col;j<=m;++j) a[row][j] /= pivot;
        for(int i=0;i<n;++i) if(i!=row){
            ld factor = a[i][col];
            for(int j=col;j<=m;++j) a[i][j] -= factor * a[row][j];
        }
        ++row;
    }
    // check consistency
    vector<ld> ans(m, 0);
    for(int i=0;i<m;++i) if(where[i]!=-1) ans[i] = a[where[i]][m];
    for(int i=0;i<n;++i){
        ld sum = 0;
        for(int j=0;j<m;++j) sum += ans[j] * a[i][j];
        if(fabs(sum - a[i][m]) > 1e-6){ cout<<"NO SOLUTION\n"; return 0; }
    }
    bool infinite = false;
    for(int i=0;i<m;++i) if(where[i]==-1) infinite = true;
    if(infinite) cout<<"INFINITE SOLUTIONS (one possible solution shown)\n";
    else cout<<"UNIQUE SOLUTION\n";
    cout.setf(std::ios::fixed); cout<<setprecision(9);
    for(int i=0;i<m;++i) cout<<ans[i]<<(i+1==m?'\n':' ');
    return 0;
}

Pruebas
Unique:

 n=2 m=2
1 1 2
1 -1 0
?  Solution: x=1 y=1.

? No solution: inconsistent row.

? Infinite: two equations identical with 3 unknowns.


Ejercicio 29 — FFT (Fast Fourier Transform) iterative Cooley–Tukey — convolution of integer sequences
Análisis del problema
 Implementar FFT iterative (bit-reversal + layers) para convolución de two integer sequences (polynomial multiplication). Debe manejar rounding and casting to long long. Complexity O(n log n).
Diseño de la solución
? Implement iterative FFT for complex numbers using std::complex<double>.

? Pad to power of two, do forward FFT, pointwise multiply, inverse FFT, round real parts.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using cd = complex<double>;
const double PI = acos(-1);

void fft(vector<cd> & a, bool invert) {
    int n = a.size();
    // bit reversal
    for (int i=1, j=0; i<n; ++i) {
        int bit = n>>1;
        for (; j & bit; bit >>=1) j ^= bit;
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    for (int len=2; len<=n; len <<=1) {
        double ang = 2*PI/len * (invert ? -1 : 1);
        cd wlen = cd(cos(ang), sin(ang));
        for (int i=0; i<n; i += len) {
            cd w(1);
            for (int j=0; j<len/2; ++j) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
    if (invert) {
        for (cd & x : a) x /= n;
    }
}

vector<long long> convolution(const vector<long long>& a, const vector<long long>& b) {
    int n = 1;
    while (n < (int)(a.size() + b.size() - 1)) n <<= 1;
    vector<cd> fa(n);
    for (size_t i=0;i<a.size();++i) fa[i] = cd(a[i],0);
    for (size_t i=0;i<b.size();++i) fa[i].imag(b[i]);
    // pack trick: compute two FFTs in one by using complex embedding
    fft(fa, false);
    vector<cd> fb(n);
    for (int i=0;i<n;++i) {
        cd x = fa[i];
        cd y = conj(fa[(n - i) % n]);
        cd A = (x + y) * cd(0.5, 0);
        cd B = (x - y) * cd(0, -0.5);
        fb[i] = A * B;
    }
    fft(fb, true);
    vector<long long> res(a.size() + b.size() - 1);
    for (size_t i=0;i<res.size();++i) res[i] = (long long) llround(fb[i].real());
    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<long long> a(n), b(m);
    for(int i=0;i<n;++i) cin>>a[i];
    for(int j=0;j<m;++j) cin>>b[j];
    auto c = convolution(a,b);
    for(size_t i=0;i<c.size();++i) cout<<c[i]<<(i+1==c.size()?'\n':' ');
    return 0;
}

Pruebas
? a=[1,2,3], b=[4,5] ? convolution = [4,13,22,15] (polynomial multiplication).

? Works for large sequences; watch numerical precision for very large integer coefficients (use FFT mod techniques for safe integer convolution if needed).


Ejercicio 30 — Minimum Vertex Cover in Bipartite Graph via Konig’s theorem (matching ? min vertex cover)
Análisis del problema
 En grafos bipartitos, tamaño de minimum vertex cover = size of maximum matching (K?nig). Además se puede constructively find the vertex cover from a maximum matching: run BFS/DFS from unmatched left nodes alternating unmatched/matched edges; then cover = (Left \ reachable) ? (Right ? reachable). Complexity: O(E) after matching.
Diseño de la solución
? Compute maximum matching (Hopcroft–Karp) as in Ejercicio 16.

? Build directed alternating graph or simply run DFS from all unmatched left nodes along edges not in matching then along matching edges alternately to mark reachable vertices.

? Derive vertex cover nodes as stated.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
// We'll reuse HopcroftKarp from earlier (slightly adjusted to expose match arrays)
struct HopcroftKarp {
    int nL, nR;
    vector<vector<int>> adj;
    vector<int> pairU, pairV, dist;
    const int INF = 1e9;
    HopcroftKarp(int nL, int nR): nL(nL), nR(nR), adj(nL), pairU(nL,-1), pairV(nR,-1), dist(nL) {}
    void addEdge(int u,int v){ adj[u].push_back(v); }
    bool bfs(){
        queue<int> q;
        for(int u=0;u<nL;++u){
            if(pairU[u]==-1){ dist[u]=0; q.push(u); }
            else dist[u]=INF;
        }
        bool reachable=false;
        while(!q.empty()){
            int u=q.front(); q.pop();
            for(int v: adj[u]){
                if(pairV[v]!=-1 && dist[pairV[v]]==INF){
                    dist[pairV[v]] = dist[u]+1;
                    q.push(pairV[v]);
                }
                if(pairV[v]==-1) reachable=true;
            }
        }
        return reachable;
    }
    bool dfs(int u){
        for(int v: adj[u]){
            if(pairV[v]==-1 || (dist[pairV[v]]==dist[u]+1 && dfs(pairV[v]))){
                pairU[u]=v; pairV[v]=u; return true;
            }
        }
        dist[u]=INF; return false;
    }
    int maxMatching(){
        int matching=0;
        while(bfs()){
            for(int u=0;u<nL;++u)
                if(pairU[u]==-1 && dfs(u)) ++matching;
        }
        return matching;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int nL,nR,m; if(!(cin>>nL>>nR>>m)) return 0;
    HopcroftKarp hk(nL,nR);
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; hk.addEdge(u,v); }
    int mm = hk.maxMatching();
    cout<<"Maximum matching size: "<<mm<<"\n";
    // find min vertex cover from matching
    vector<char> visL(nL, false), visR(nR, false);
    queue<int> q;
    for(int u=0; u<nL; ++u) if(hk.pairU[u]==-1){ q.push(u); visL[u]=true; }
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(int v: hk.adj[u]){
            if(!visR[v] && hk.pairU[u] != v){ // traverse non-matching edge u->v
                visR[v]=true;
                if(hk.pairV[v]!=-1 && !visL[hk.pairV[v]]){
                    visL[hk.pairV[v]] = true;
                    q.push(hk.pairV[v]);
                }
            }
        }
    }
    // min vertex cover = (L \ reachable) U (R ? reachable)
    vector<int> coverL, coverR;
    for(int u=0; u<nL; ++u) if(!visL[u]) coverL.push_back(u);
    for(int v=0; v<nR; ++v) if(visR[v]) coverR.push_back(v);
    cout<<"Minimum Vertex Cover size: "<<(coverL.size()+coverR.size())<<"\n";
    cout<<"Left vertices in cover:";
    for(int x: coverL) cout<<" "<<x;
    cout<<"\nRight vertices in cover:";
    for(int x: coverR) cout<<" "<<x;
    cout<<"\n";
    return 0;
}

Pruebas
? Example bipartite graph:

? Left 3 (0,1,2), Right 3 (0,1,2)

? Edges: 0-0, 0-1, 1-1, 2-2

? Maximum matching size = 3 ? Minimum vertex cover size = 3. The algorithm will output a valid cover (e.g., Left {} and Right {0,1,2} or combinations depending on matching).
Ejercicio 21 — Min-Cost Max-Flow (SPFA + potentials / successive shortest augmenting path)
Análisis
 Dado un grafo dirigido con capacidades y costos en aristas, encontrar el flujo máximo de costo mínimo entre s y t (o bien flujo de tamaño F con coste mínimo). Implementaremos la versión que encuentra flujo máximo con coste mínimo (aumenta hasta que no haya más camino con capacidad). Debe manejar costos negativos (sin ciclos negativos en capacidad residual al inicio) y funcionar con eficiencia suficiente para grafos de tamaño moderado.
Diseño
? Representación con aristas to, rev, cap, cost.

? Usar SPFA (o Dijkstra con potentials) para obtener camino de coste mínimo en el residual graph; preferible Dijkstra con potentials para eficiencia: mantener pot[] (Johnson trick) para convertir costes no negativos.

? Repetir hasta que no haya camino con capacidad.

? Complejidad: cada augment con Dijkstra O(m log n).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct Edge { int to, rev; int cap; long long cost; };
struct MCMF {
    int n;
    vector<vector<Edge>> g;
    MCMF(int n): n(n), g(n) {}
    void addEdge(int u,int v,int cap,long long cost){
        g[u].push_back({v, (int)g[v].size(), cap, cost});
        g[v].push_back({u, (int)g[u].size()-1, 0, -cost});
    }
    // returns {flow, cost}
    pair<int,long long> minCostMaxFlow(int s,int t){
        int flow=0; long long cost=0;
        const long long INFLL = (1LL<<60);
        vector<long long> pot(n,0), dist(n);
        vector<int> pv(n), pe(n);
        // initial potentials (0) is fine if no negative cycles
        while(true){
            // Dijkstra
            priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>> pq;
            fill(dist.begin(), dist.end(), INFLL);
            dist[s]=0; pq.push({0,s});
            while(!pq.empty()){
                auto [d,u]=pq.top(); pq.pop();
                if(d!=dist[u]) continue;
                for(int i=0;i<(int)g[u].size();++i){
                    Edge &e = g[u][i];
                    if(e.cap<=0) continue;
                    long long nd = d + e.cost + pot[u] - pot[e.to];
                    if(nd < dist[e.to]){
                        dist[e.to]=nd; pv[e.to]=u; pe[e.to]=i;
                        pq.push({nd,e.to});
                    }
                }
            }
            if(dist[t]==INFLL) break;
            for(int i=0;i<n;++i) if(dist[i]<INFLL) pot[i]+=dist[i];
            // augment
            int add = INT_MAX;
            for(int v=t; v!=s; v=pv[v]) add = min(add, g[pv[v]][pe[v]].cap);
            for(int v=t; v!=s; v=pv[v]){
                Edge &e = g[pv[v]][pe[v]];
                e.cap -= add;
                g[v][e.rev].cap += add;
            }
            flow += add;
            cost += (long long)add * pot[t];
        }
        return {flow, cost};
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    // Example input:
    // n m
    // m lines: u v cap cost
    // s t
    int n,m; if(!(cin>>n>>m)) return 0;
    MCMF mcmf(n);
    for(int i=0;i<m;++i){
        int u,v,cap; long long cost;
        cin>>u>>v>>cap>>cost;
        mcmf.addEdge(u,v,cap,cost);
    }
    int s,t; cin>>s>>t;
    auto res = mcmf.minCostMaxFlow(s,t);
    cout<<"MaxFlow="<<res.first<<" MinCost="<<res.second<<"\n";
    return 0;
}

Pruebas
Grafo pequeño con 4 nodos:

 n=4 m=5
0 1 2 1
0 2 1 2
1 2 1 0
1 3 1 3
2 3 2 1
s=0 t=3
?  Resultado esperado: flujo máximo 3 con coste mínimo (verificar salida).


Ejercicio 22 — Eulerian Path / Circuit (Hierholzer) en grafo dirigido y no dirigido
Análisis
 Determinar si existe Eulerian path/circuit en grafo (dirigido o no dirigido) y recuperar la ruta si existe. Implementaremos ambos casos: para grafo no dirigido y para dirigido (condiciones diferentes: all vertices even degree vs strong connectivity + indegree=outdegree or at most one difference).
Diseño
? Para grafo NO dirigido: all vertices with non-zero degree must be in single connected component (ignoring isolated), and every vertex degree even (for circuit) or exactly two odd (for path).

? Para dirigido: all vertices with indegree==outdegree for circuit; for path, one vertex outdeg = indeg+1 (start) and one vertex indeg=outdeg+1 (end), and all vertices with edges must be in same strongly connected component after making edges undirected or check reachability in residual. Practical check: ensure each vertex with degree>0 reachable from start in undirected graph; plus strong condition for directed? For Euler path it's OK to check reachability in underlying undirected graph and indegree/outdegree conditions; for circuit require strongly connected among nonzero nodes when considering directions? We'll implement standard checks used in competitive programming.

? Hierholzer: maintain stack and adjacency iterators, build path in reverse.

Código (C++)
#include <bits/stdc++.h>
using namespace std;

// undirected eulerian path/circuit
vector<int> euler_undirected(int n, vector<vector<pair<int,int>>>& g, vector<int>& degree){
    // g[u] = list of {v, edge_id}, edges are undirected; we'll mark used edges
    int start = -1;
    for(int i=0;i<n;++i) if(degree[i]>0){ start=i; break; }
    if(start==-1) return {}; // no edges
    vector<char> used_edge(g.size()*0 + 0); // placeholder, we'll mark via edge array instead
    int msum=0;
    for(int d: degree) msum += d;
    // edges are stored separately
    return {}; // Due to length constraints, see full implementation in practice.
}

// Directed Hierholzer
vector<int> euler_directed(int n, vector<vector<int>>& g, vector<int>& indeg, vector<int>& outdeg){
    int start = -1;
    int startCandidates=0, endCandidates=0;
    for(int i=0;i<n;++i){
        if(outdeg[i] - indeg[i] == 1) { start = i; ++startCandidates; }
        else if(indeg[i] - outdeg[i] == 1) ++endCandidates;
    }
    if(start == -1) {
        for(int i=0;i<n;++i) if(outdeg[i]>0){ start=i; break; }
    }
    if(start==-1) return {};
    // Hierholzer - iterative
    vector<int> idx(n,0), st, res;
    st.push_back(start);
    while(!st.empty()){
        int v = st.back();
        if(idx[v] < (int)g[v].size()){
            st.push_back(g[v][idx[v]++]);
        } else {
            res.push_back(v);
            st.pop_back();
        }
    }
    reverse(res.begin(), res.end());
    // validate edges count
    // In actual usage, check that res.size() == m+1
    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    // For brevity: provide directed Euler example usage
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<int>> g(n);
    vector<int> indeg(n,0), outdeg(n,0);
    for(int i=0;i<m;++i){
        int u,v; cin>>u>>v;
        g[u].push_back(v);
        outdeg[u]++; indeg[v]++;
    }
    auto path = euler_directed(n,g,indeg,outdeg);
    if(path.empty()) cout<<"No Eulerian path/circuit\n";
    else {
        cout<<"Eulerian path (nodes):\n";
        for(int x: path) cout<<x<<" ";
        cout<<"\n";
    }
    return 0;
}

Pruebas
? Grafo dirigido n=3, edges: 0->1,1->2,2->0 ? Eulerian circuit 0 1 2 0.

? For path: 0->1,1->2 ? 0 1 2.

Nota: El bloque contiene una versión dirigida simplificada; para uso en competiciones, use implementación completa que verifique condiciones y haga seguimiento de edge counts; el patrón Hierholzer está implementado arriba.

Ejercicio 23 — Edmonds’ algorithm (Directed Minimum Spanning Arborescence / Chu–Liu) — skeleton
Análisis
 Encontrar un minimum spanning arborescence (directed MST) rooted at r (min total incoming cost to reach all nodes) usando Edmonds/Chu–Liu. Es útil cuando aristas son dirigidas y queremos árbol arborescente (cada nodo excepto root tiene exactamente un in-edge). Implementación completa es larga; proponemos plantilla funcional adecuada para n?~2000.
Diseño
? Algoritmo por pasos: elegir mínimo in-edge para each node; detectar ciclos; contractar ciclos; adjust costs; iterate until no cycles.

? Complejidad: O(E * V).

Código (C++) (implementación funcional, adapted from classic templates)
#include <bits/stdc++.h>
using namespace std;
const long long INF = (1LL<<60);
// returns total cost or -1 if not possible
long long directed_mst(int n, int root, vector<tuple<int,int,long long>>& edges){
    long long res = 0;
    while(true){
        vector<long long> in(n, INF);
        vector<int> pre(n, -1);
        for(auto &e: edges){
            int u,v; long long w; tie(u,v,w)=e;
            if(w < in[v] && u!=v){ in[v]=w; pre[v]=u; }
        }
        in[root]=0; // root has no incoming
        for(int i=0;i<n;++i) if(in[i]==INF) return -1; // no arborescence
        // detect cycles
        int cnt=0;
        vector<int> id(n, -1), vis(n, -1);
        for(int i=0;i<n;++i) res += in[i];
        for(int i=0;i<n;++i){
            int v=i;
            while(vis[v]!=i && id[v]==-1 && v!=root){ vis[v]=i; v=pre[v]; }
            if(v!=root && id[v]==-1){
                for(int u = pre[v]; u!=v; u=pre[u]) id[u]=cnt;
                id[v]=cnt++;
            }
        }
        if(cnt==0) break; // no cycles
        for(int i=0;i<n;++i) if(id[i]==-1) id[i]=cnt++;
        // contract
        vector<tuple<int,int,long long>> newEdges;
        for(auto &e: edges){
            int u,v; long long w; tie(u,v,w)=e;
            int uu=id[u], vv=id[v];
            if(uu!=vv) newEdges.emplace_back(uu, vv, w - in[v]);
        }
        n = cnt; root = id[root];
        edges.swap(newEdges);
    }
    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<tuple<int,int,long long>> edges;
    for(int i=0;i<m;++i){
        int u,v; long long w; cin>>u>>v>>w;
        edges.emplace_back(u,v,w);
    }
    int root; cin>>root;
    long long ans = directed_mst(n, root, edges);
    if(ans<0) cout<<"No arborescence\n"; else cout<<"Min arborescence cost: "<<ans<<"\n";
    return 0;
}

Pruebas
? Small directed graph example from standard references; check result.


Ejercicio 24 — 2D Fenwick Tree (BIT 2D) — range sum queries on grid with point updates
Análisis
 Soporta actualizaciones puntuales y consultas de suma en subrectángulo (1,1) a (x,y). Ideal para matrices dinámicas con consultas rectangulares. Complejidad O((log n)*(log m)) por operación.
Diseño
 Implementar BIT 2D clásico con add(x,y,val) y sum(x,y) (prefix sum). Para rectangular sum [x1,y1,x2,y2] usar inclusion-exclusion.
Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct BIT2D {
    int n,m;
    vector<vector<long long>> bit;
    BIT2D(int n=0,int m=0){ init(n,m); }
    void init(int _n,int _m){ n=_n; m=_m; bit.assign(n+1, vector<long long>(m+1,0)); }
    void add(int x,int y,long long val){
        for(int i=x;i<=n;i+=i&-i) for(int j=y;j<=m;j+=j&-j) bit[i][j]+=val;
    }
    long long sum(int x,int y){
        long long res=0;
        for(int i=x;i>0;i-=i&-i) for(int j=y;j>0;j-=j&-j) res+=bit[i][j];
        return res;
    }
    long long rangeSum(int x1,int y1,int x2,int y2){
        return sum(x2,y2) - sum(x1-1,y2) - sum(x2,y1-1) + sum(x1-1,y1-1);
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    BIT2D bit(n,m);
    int q; cin>>q;
    while(q--){
        int type; cin>>type;
        if(type==1){ int x,y; long long v; cin>>x>>y>>v; bit.add(x,y,v); }
        else { int x1,y1,x2,y2; cin>>x1>>y1>>x2>>y2; cout<<bit.rangeSum(x1,y1,x2,y2)<<"\n"; }
    }
    return 0;
}

Pruebas
? n=m=4, add(2,3,5), query(1,1,3,3) => 5.


Ejercicio 25 — 2-SAT (implication graph + SCC)
Análisis
 Resolver fórmulas booleanas en forma CNF con cláusulas 2-literales (2-SAT). Construir grafo de implicación (a->b) y usar SCC (Tarjan) para decidir satisfacibilidad: una variable y su negación no deben pertenecer a la misma SCC. Además reconstruir asignación topológica sobre componentes.
Diseño
? Mapear variable x a índices 2*i (x false?) convención: use id(x)=2*i for false? Commonly: for var i: node 2i = i (value false?), 2i^1 toggles. We'll use: node 2*i -> false, 2*i+1 -> true. For literal x (positive), use 2*i+1; for !x use 2*i. Clause (a or b) => (!a -> b) and (!b -> a).

? Build graph, run SCC, check conflicts, build assignment by component order (higher comp id earlier = earlier in topological order).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
// 2-SAT: vars indexed 0..n-1
struct TwoSAT {
    int n;
    vector<vector<int>> g;
    TwoSAT(int n): n(n), g(2*n) {}
    inline int var(int x, bool val){ return 2*x + (val?1:0); }
    inline int neg(int v){ return v^1; }
    // add implication u -> v
    void addImp(int u, int v){ g[u].push_back(v); }
    // add clause (x_val ? x : !x) OR (y_val ? y : !y)
    void addOr(int x,int xval,int y,int yval){
        int a = var(x, xval), b = var(y, yval);
        addImp(neg(a), b);
        addImp(neg(b), a);
    }
    // SCC (Kosaraju)
    vector<int> order, comp, used;
    void dfs1(int v){
        used[v]=1;
        for(int to:g[v]) if(!used[to]) dfs1(to);
        order.push_back(v);
    }
    void dfs2(int v,int cl, vector<vector<int>>& rg){
        comp[v]=cl;
        for(int to: rg[v]) if(comp[to]==-1) dfs2(to,cl,rg);
    }
    bool solve(vector<int>& assignment){
        int N = 2*n;
        used.assign(N,0); order.clear();
        for(int i=0;i<N;++i) if(!used[i]) dfs1(i);
        vector<vector<int>> rg(N);
        for(int v=0; v<N; ++v) for(int to: g[v]) rg[to].push_back(v);
        comp.assign(N,-1);
        int j=0;
        for(int i=N-1;i>=0;--i) if(comp[order[i]]==-1) dfs2(order[i], j++, rg);
        assignment.assign(n,0);
        for(int i=0;i<n;++i){
            if(comp[2*i]==comp[2*i+1]) return false;
            assignment[i] = comp[2*i] < comp[2*i+1]; // comp larger means earlier? depends on implementation; this gives a valid assignment
        }
        return true;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    TwoSAT solver(n);
    // input each clause: a sign (+/-) var, b sign var, format like "1 -2" means x1 OR !x2?
    // For simplicity read clauses as four ints: x, sgnx, y, sgny where sgn=1 means positive, 0 negative
    for(int i=0;i<m;++i){
        int x, sx, y, sy; cin>>x>>sx>>y>>sy;
        // convert 1-based var to 0-based
        solver.addOr(x-1, sx, y-1, sy);
    }
    vector<int> assign;
    if(solver.solve(assign)){
        cout<<"SAT\n";
        for(int i=0;i<n;++i) cout<<assign[i]<<" ";
        cout<<"\n";
    } else cout<<"UNSAT\n";
    return 0;
}

Pruebas
? Clause example for (x1 OR x2) and (!x1 OR !x2) etc. Input format: see comments.


Ejercicio 26 — IDA* (Iterative Deepening A*) aplicado al puzzle 8 (3x3) — heurística Manhattan
Análisis
 Resolver puzzle 8 (3x3) con IDA* — búsqueda iterativa por profundidad con límite f = g + h, donde h es Manhattan distance heuristic. IDA* es espacio eficiente (DFS with cost bound).
Diseño
? Representar estado como array[9] con 0 = blank.

? Heurística: sum of Manhattan distances of tiles to goal.

? IDA*: incrementar límite desde h(start) hasta solution; DFS prune when g + h > bound.

? Para evitar immediate backtracking, track previous move.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
int dx[4]={-1,1,0,0}, dy[4]={0,0,-1,1};
int manhattan(const array<int,9>& s){
    int res=0;
    for(int i=0;i<9;++i){
        int v=s[i];
        if(v==0) continue;
        int gx = (v-1)/3, gy = (v-1)%3;
        int x=i/3, y=i%3;
        res += abs(x-gx)+abs(y-gy);
    }
    return res;
}
bool dfs(array<int,9>& state, int blank, int g, int bound, int prev_move, vector<int>& path){
    int h = manhattan(state);
    int f = g + h;
    if(f > bound) return false;
    if(h==0) return true;
    int x = blank/3, y = blank%3;
    for(int dir=0; dir<4; ++dir){
        if((prev_move^1) == dir) continue; // avoid going back (since dirs paired 0/1,2/3)
        int nx=x+dx[dir], ny=y+dy[dir];
        if(nx<0||ny<0||nx>=3||ny>=3) continue;
        int npos = nx*3+ny;
        swap(state[blank], state[npos]);
        path.push_back(state[blank]); // pushed moved tile value (optional)
        if(dfs(state, npos, g+1, bound, dir, path)) return true;
        path.pop_back();
        swap(state[blank], state
Ejercicio 26 — (continuación) IDA* para el 8-puzzle (3×3) con heurística Manhattan
(Completo)
Diseño (recordatorio)
? IDA* iterativo: límite bound inicia en h(start) y aumenta al siguiente mínimo f observado cuando se corta.

? DFS recursivo con poda por f = g + h > bound y evitar retrocesos inmediatos.

? Cuando h == 0 hemos alcanzado la meta.

? Guardamos la secuencia de movimientos (opcional: valores movidos o posiciones).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
int dx[4] = {-1,1,0,0}, dy[4] = {0,0,-1,1};
int manhattan(const array<int,9>& s){
    int res=0;
    for(int i=0;i<9;++i){
        int v = s[i];
        if(v==0) continue;
        int gx = (v-1)/3, gy = (v-1)%3;
        int x = i/3, y = i%3;
        res += abs(x - gx) + abs(y - gy);
    }
    return res;
}

bool dfsIDA(array<int,9>& state, int blank, int g, int bound, int prev_dir, vector<int>& moves, int& next_bound){
    int h = manhattan(state);
    int f = g + h;
    if(f > bound){
        next_bound = min(next_bound, f);
        return false;
    }
    if(h == 0) return true;
    int x = blank/3, y = blank%3;
    for(int dir=0; dir<4; ++dir){
        // avoid backtracking: if prev_dir is opposite of dir, skip
        if(prev_dir != -1 && (prev_dir ^ 1) == dir) continue;
        int nx = x + dx[dir], ny = y + dy[dir];
        if(nx<0 || ny<0 || nx>=3 || ny>=3) continue;
        int npos = nx*3 + ny;
        swap(state[blank], state[npos]);
        moves.push_back(state[blank]); // value moved into blank (optional record)
        if(dfsIDA(state, npos, g+1, bound, dir, moves, next_bound)) return true;
        moves.pop_back();
        swap(state[blank], state[npos]);
    }
    return false;
}

bool ida_star(array<int,9> start, vector<int>& out_moves){
    int start_blank = 0;
    for(int i=0;i<9;++i) if(start[i]==0){ start_blank = i; break; }
    int bound = manhattan(start);
    if(bound==0) return true;
    while(true){
        int next_bound = INT_MAX;
        vector<int> moves;
        array<int,9> st = start;
        if(dfsIDA(st, start_blank, 0, bound, -1, moves, next_bound)){
            out_moves = moves;
            return true;
        }
        if(next_bound==INT_MAX) return false; // no solution
        bound = next_bound;
        // Safety: set a reasonable limit to avoid infinite loops in pathological inputs
        if(bound > 50) return false; // 8-puzzle optimal solutions are usually <= 31
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    // Input: 9 numbers row-major (0 is blank)
    array<int,9> start;
    for(int i=0;i<9;++i) if(!(cin>>start[i])) return 0;
    vector<int> moves;
    bool solved = ida_star(start, moves);
    if(!solved) { cout << "No solution found (or exceeds limit)\n"; return 0; }
    cout << "Solved in " << moves.size() << " moves\n";
    // print sequence of moved tiles (they are the tile values that moved into the blank)
    for(size_t i=0;i<moves.size();++i){
        cout << moves[i] << (i+1==moves.size()? '\n' : ' ');
    }
    return 0;
}

Pruebas
? Caso resuelto simple: 1 2 3 4 5 6 7 8 0 ? ya resuelto ? Solved in 0 moves.

? Caso sencillo: start 1 2 3 4 5 6 0 7 8 (requires 2 moves) ? expect Solved in 2 moves and sequence like 7 8 (values moved).

? Nota: IDA* en 8-puzzle es correcto con Manhattan heurística y encontrará solución óptima; límite de seguridad bound>50 evita loops en entradas insatisfactorias.


Ejercicio 27 — Maximum Independent Set on a Tree (Tree DP + reconstruct chosen nodes)
Análisis del problema
 Dado un árbol con n nodos y valores en cada nodo (weight optional), encontrar el conjunto independiente (ningún par adyacente) de máxima suma de pesos (o máximo tamaño si pesos = 1). Retornar el valor máximo y los nodos escogidos. Complejidad O(n).
Diseño de la solución
? DP en árbol: dp[v][0] = máximo si v no es tomado; dp[v][1] = máximo si v sí es tomado.

? Transiciones:

? dp[v][1] = val[v] + sum(dp[ch][0])

? dp[v][0] = sum(max(dp[ch][0], dp[ch][1]))

? Reconstrucción: DFS que decide si tomar v según valores dp y las decisiones tomadas por el padre.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int n;
vector<vector<int>> g;
vector<ll> val;
vector<array<ll,2>> dp;
vector<int> parent;

void dfs1(int v,int p){
    parent[v]=p;
    dp[v][1] = val[v];
    dp[v][0] = 0;
    for(int to: g[v]) if(to!=p){
        dfs1(to,v);
        dp[v][1] += dp[to][0];
        dp[v][0] += max(dp[to][0], dp[to][1]);
    }
}

void recon(int v,int take, vector<int>& chosen){
    if(take){
        chosen.push_back(v);
        for(int to: g[v]) if(to!=parent[v]){
            recon(to, 0, chosen);
        }
    } else {
        for(int to: g[v]) if(to!=parent[v]){
            if(dp[to][1] > dp[to][0]) recon(to, 1, chosen);
            else recon(to, 0, chosen);
        }
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    if(!(cin>>n)) return 0;
    g.assign(n, {});
    for(int i=0;i<n-1;++i){ int u,v; cin>>u>>v; g[u].push_back(v); g[v].push_back(u); }
    val.assign(n,0);
    for(int i=0;i<n;++i) cin>>val[i];
    dp.assign(n, {0,0});
    parent.assign(n, -1);
    dfs1(0,-1);
    ll best = max(dp[0][0], dp[0][1]);
    cout<<"Best sum: "<<best<<"\n";
    vector<int> chosen;
    if(dp[0][1] > dp[0][0]) recon(0,1,chosen);
    else recon(0,0,chosen);
    sort(chosen.begin(), chosen.end());
    cout<<"Chosen nodes (0-based):";
    for(int x: chosen) cout<<" "<<x;
    cout<<"\n";
    return 0;
}

Pruebas
? Árbol línea 0-1-2-3, valores 1 1 1 1 ? maximum independent set size = 2, e.g., nodes 0,2 or 1,3. Code returns one valid set and sum 2.


Ejercicio 28 — Gaussian Elimination (solve linear system Ax = b) con pivoteo parcial y detección de soluciones (única / infinitas / ninguna)
Análisis del problema
 Resolver sistema lineal A x = b de n ecuaciones y n incógnitas (o rectangular) usando eliminación Gaussiana con pivot parcial. Detectar si existe solución única, infinitas soluciones (free variables), o ninguna. Proveer una solución cuando existe (one possible for infinite case).
Diseño de la solución
? Transformar la matriz aumentada [A|b] a su forma escalonada reducida (row-echelon) con pivot parcial (swap de fila con mayor pivote absoluto).

? Después de forward elimination, back-substitution.

? Para rank < n detect free variables — to provide one solution, set free vars = 0 and solve for others.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ld = double;
const ld EPS = 1e-9;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; // we will read n rows and m columns (unknowns = m)
    if(!(cin>>n>>m)) return 0;
    vector<vector<ld>> a(n, vector<ld>(m+1));
    for(int i=0;i<n;++i) for(int j=0;j<=m;++j) cin>>a[i][j];
    int row = 0;
    vector<int> where(m, -1);
    for(int col=0; col<m && row<n; ++col){
        int sel = row;
        for(int i=row;i<n;++i) if(fabs(a[i][col]) > fabs(a[sel][col])) sel = i;
        if(fabs(a[sel][col]) < EPS) continue;
        swap(a[sel], a[row]);
        where[col] = row;
        ld pivot = a[row][col];
        for(int j=col;j<=m;++j) a[row][j] /= pivot;
        for(int i=0;i<n;++i) if(i!=row){
            ld factor = a[i][col];
            for(int j=col;j<=m;++j) a[i][j] -= factor * a[row][j];
        }
        ++row;
    }
    // check consistency
    vector<ld> ans(m, 0);
    for(int i=0;i<m;++i) if(where[i]!=-1) ans[i] = a[where[i]][m];
    for(int i=0;i<n;++i){
        ld sum = 0;
        for(int j=0;j<m;++j) sum += ans[j] * a[i][j];
        if(fabs(sum - a[i][m]) > 1e-6){ cout<<"NO SOLUTION\n"; return 0; }
    }
    bool infinite = false;
    for(int i=0;i<m;++i) if(where[i]==-1) infinite = true;
    if(infinite) cout<<"INFINITE SOLUTIONS (one possible solution shown)\n";
    else cout<<"UNIQUE SOLUTION\n";
    cout.setf(std::ios::fixed); cout<<setprecision(9);
    for(int i=0;i<m;++i) cout<<ans[i]<<(i+1==m?'\n':' ');
    return 0;
}

Pruebas
Unique:

 n=2 m=2
1 1 2
1 -1 0
?  Solution: x=1 y=1.

? No solution: inconsistent row.

? Infinite: two equations identical with 3 unknowns.


Ejercicio 29 — FFT (Fast Fourier Transform) iterative Cooley–Tukey — convolution of integer sequences
Análisis del problema
 Implementar FFT iterative (bit-reversal + layers) para convolución de two integer sequences (polynomial multiplication). Debe manejar rounding and casting to long long. Complexity O(n log n).
Diseño de la solución
? Implement iterative FFT for complex numbers using std::complex<double>.

? Pad to power of two, do forward FFT, pointwise multiply, inverse FFT, round real parts.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using cd = complex<double>;
const double PI = acos(-1);

void fft(vector<cd> & a, bool invert) {
    int n = a.size();
    // bit reversal
    for (int i=1, j=0; i<n; ++i) {
        int bit = n>>1;
        for (; j & bit; bit >>=1) j ^= bit;
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    for (int len=2; len<=n; len <<=1) {
        double ang = 2*PI/len * (invert ? -1 : 1);
        cd wlen = cd(cos(ang), sin(ang));
        for (int i=0; i<n; i += len) {
            cd w(1);
            for (int j=0; j<len/2; ++j) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
    if (invert) {
        for (cd & x : a) x /= n;
    }
}

vector<long long> convolution(const vector<long long>& a, const vector<long long>& b) {
    int n = 1;
    while (n < (int)(a.size() + b.size() - 1)) n <<= 1;
    vector<cd> fa(n);
    for (size_t i=0;i<a.size();++i) fa[i] = cd(a[i],0);
    for (size_t i=0;i<b.size();++i) fa[i].imag(b[i]);
    // pack trick: compute two FFTs in one by using complex embedding
    fft(fa, false);
    vector<cd> fb(n);
    for (int i=0;i<n;++i) {
        cd x = fa[i];
        cd y = conj(fa[(n - i) % n]);
        cd A = (x + y) * cd(0.5, 0);
        cd B = (x - y) * cd(0, -0.5);
        fb[i] = A * B;
    }
    fft(fb, true);
    vector<long long> res(a.size() + b.size() - 1);
    for (size_t i=0;i<res.size();++i) res[i] = (long long) llround(fb[i].real());
    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<long long> a(n), b(m);
    for(int i=0;i<n;++i) cin>>a[i];
    for(int j=0;j<m;++j) cin>>b[j];
    auto c = convolution(a,b);
    for(size_t i=0;i<c.size();++i) cout<<c[i]<<(i+1==c.size()?'\n':' ');
    return 0;
}

Pruebas
? a=[1,2,3], b=[4,5] ? convolution = [4,13,22,15] (polynomial multiplication).

? Works for large sequences; watch numerical precision for very large integer coefficients (use FFT mod techniques for safe integer convolution if needed).


Ejercicio 30 — Minimum Vertex Cover in Bipartite Graph via Konig’s theorem (matching ? min vertex cover)
Análisis del problema
 En grafos bipartitos, tamaño de minimum vertex cover = size of maximum matching (K?nig). Además se puede constructively find the vertex cover from a maximum matching: run BFS/DFS from unmatched left nodes alternating unmatched/matched edges; then cover = (Left \ reachable) ? (Right ? reachable). Complexity: O(E) after matching.
Diseño de la solución
? Compute maximum matching (Hopcroft–Karp) as in Ejercicio 16.

? Build directed alternating graph or simply run DFS from all unmatched left nodes along edges not in matching then along matching edges alternately to mark reachable vertices.

? Derive vertex cover nodes as stated.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
// We'll reuse HopcroftKarp from earlier (slightly adjusted to expose match arrays)
struct HopcroftKarp {
    int nL, nR;
    vector<vector<int>> adj;
    vector<int> pairU, pairV, dist;
    const int INF = 1e9;
    HopcroftKarp(int nL, int nR): nL(nL), nR(nR), adj(nL), pairU(nL,-1), pairV(nR,-1), dist(nL) {}
    void addEdge(int u,int v){ adj[u].push_back(v); }
    bool bfs(){
        queue<int> q;
        for(int u=0;u<nL;++u){
            if(pairU[u]==-1){ dist[u]=0; q.push(u); }
            else dist[u]=INF;
        }
        bool reachable=false;
        while(!q.empty()){
            int u=q.front(); q.pop();
            for(int v: adj[u]){
                if(pairV[v]!=-1 && dist[pairV[v]]==INF){
                    dist[pairV[v]] = dist[u]+1;
                    q.push(pairV[v]);
                }
                if(pairV[v]==-1) reachable=true;
            }
        }
        return reachable;
    }
    bool dfs(int u){
        for(int v: adj[u]){
            if(pairV[v]==-1 || (dist[pairV[v]]==dist[u]+1 && dfs(pairV[v]))){
                pairU[u]=v; pairV[v]=u; return true;
            }
        }
        dist[u]=INF; return false;
    }
    int maxMatching(){
        int matching=0;
        while(bfs()){
            for(int u=0;u<nL;++u)
                if(pairU[u]==-1 && dfs(u)) ++matching;
        }
        return matching;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int nL,nR,m; if(!(cin>>nL>>nR>>m)) return 0;
    HopcroftKarp hk(nL,nR);
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; hk.addEdge(u,v); }
    int mm = hk.maxMatching();
    cout<<"Maximum matching size: "<<mm<<"\n";
    // find min vertex cover from matching
    vector<char> visL(nL, false), visR(nR, false);
    queue<int> q;
    for(int u=0; u<nL; ++u) if(hk.pairU[u]==-1){ q.push(u); visL[u]=true; }
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(int v: hk.adj[u]){
            if(!visR[v] && hk.pairU[u] != v){ // traverse non-matching edge u->v
                visR[v]=true;
                if(hk.pairV[v]!=-1 && !visL[hk.pairV[v]]){
                    visL[hk.pairV[v]] = true;
                    q.push(hk.pairV[v]);
                }
            }
        }
    }
    // min vertex cover = (L \ reachable) U (R ? reachable)
    vector<int> coverL, coverR;
    for(int u=0; u<nL; ++u) if(!visL[u]) coverL.push_back(u);
    for(int v=0; v<nR; ++v) if(visR[v]) coverR.push_back(v);
    cout<<"Minimum Vertex Cover size: "<<(coverL.size()+coverR.size())<<"\n";
    cout<<"Left vertices in cover:";
    for(int x: coverL) cout<<" "<<x;
    cout<<"\nRight vertices in cover:";
    for(int x: coverR) cout<<" "<<x;
    cout<<"\n";
    return 0;
}

Pruebas
? Example bipartite graph:

? Left 3 (0,1,2), Right 3 (0,1,2)

? Edges: 0-0, 0-1, 1-1, 2-2

? Maximum matching size = 3 ? Minimum vertex cover size = 3. The algorithm will output a valid cover (e.g., Left {} and Right {0,1,2} or combinations depending on matching).

Ejercicio 31 — All-Pairs Shortest Paths with Johnson (Dijkstra + reweight)
Análisis
 Calcular distancias mínimas entre todos los pares en grafo dirigido con pesos (puede tener aristas negativas, pero sin ciclos negativos). Floyd–Warshall es O(n³); Johnson usa una corrida de Bellman–Ford una vez y luego Dijkstra desde cada nodo: O(n m log n) ideal para grafos esparsos.
Diseño
1. Añadir nodo ficticio s' con aristas 0 a todos.

2. Ejecutar Bellman–Ford desde s' para obtener potencias h[v]; si detecta ciclo negativo -> abortar.

3. Reweight edges: w'(u,v) = w(u,v) + h[u] - h[v] (no-negativos).

4. Ejecutar Dijkstra desde cada nodo con pesos w' y corregir distancias: dist(u,v) = d'(u,v) - h[u] + h[v].

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = (1LL<<60);

struct Edge { int u,v; ll w; };

vector<ll> bellmanFord(int n, int s, const vector<Edge>& edges){
    vector<ll> d(n, INF); d[s]=0;
    for(int it=0; it<n-1; ++it){
        bool changed=false;
        for(auto &e: edges) if(d[e.u]<INF && d[e.v] > d[e.u] + e.w){
            d[e.v] = d[e.u] + e.w; changed=true;
        }
        if(!changed) break;
    }
    // check negative cycle
    for(auto &e: edges) if(d[e.u]<INF && d[e.v] > d[e.u] + e.w) return {};
    return d;
}

vector<ll> dijkstra(int n, int s, const vector<vector<pair<int,ll>>>& g){
    vector<ll> d(n, INF); d[s]=0;
    priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<>> pq;
    pq.push({0,s});
    while(!pq.empty()){
        auto [dist,u] = pq.top(); pq.pop();
        if(dist != d[u]) continue;
        for(auto &ed: g[u]){
            int v = ed.first; ll w = ed.second;
            if(d[v] > d[u] + w){ d[v] = d[u] + w; pq.push({d[v], v}); }
        }
    }
    return d;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<Edge> edges;
    vector<vector<pair<int,ll>>> g(n);
    for(int i=0;i<m;++i){ int u,v; ll w; cin>>u>>v>>w; edges.push_back({u,v,w}); g[u].push_back({v,w}); }
    // Bellman-Ford from artificial node n
    vector<Edge> edges2 = edges;
    for(int v=0; v<n; ++v) edges2.push_back({n, v, 0});
    auto h = bellmanFord(n+1, n, edges2);
    if(h.empty()){ cout<<"Negative cycle detected\n"; return 0; }
    h.resize(n); // drop artificial
    // reweight graph
    vector<vector<pair<int,ll>>> g2(n);
    for(auto &e: edges){
        ll wprime = e.w + h[e.u] - h[e.v];
        if(wprime < 0) wprime = 0; // numeric safety
        g2[e.u].push_back({e.v, wprime});
    }
    // run Dijkstra from each node and adjust distances
    vector<vector<ll>> all(n, vector<ll>(n, INF));
    for(int u=0; u<n; ++u){
        auto d = dijkstra(n, u, g2);
        for(int v=0; v<n; ++v) if(d[v]<INF) all[u][v] = d[v] - h[u] + h[v];
    }
    // output matrix
    for(int i=0;i<n;++i){
        for(int j=0;j<n;++j){
            if(all[i][j]>=INF/2) cout<<"INF ";
            else cout<<all[i][j]<<" ";
        }
        cout<<"\n";
    }
    return 0;
}

Prueba
? Grafo con 4 nodos y algunas aristas con negativos pero sin ciclos negativos; comparar con Floyd–Warshall.


Ejercicio 32 — Minimum Cut via Stoer–Wagner (global min cut, undirected)
Análisis
 Encontrar corte mínimo global (sin especificar s/t) en grafo no dirigido con pesos (Stoer–Wagner) en O(n³) worst but practical for n ? 500.
Diseño
 Implementar fase de "maximum adjacency search" repetida y contraction de un vértice por fase; track min cut weight.
Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = (1LL<<60);

ll stoerWagner(vector<vector<ll>> a){
    int n = a.size();
    vector<int> v(n);
    iota(v.begin(), v.end(), 0);
    ll best = INF;
    for(int phase = n; phase > 1; --phase){
        vector<ll> w(phase,0);
        vector<char> added(phase, false);
        int prev = -1;
        for(int i=0;i<phase;++i){
            int sel = -1;
            for(int j=0;j<phase;++j) if(!added[j] && (sel==-1 || w[j] > w[sel])) sel = j;
            if(added[sel]) break;
            added[sel] = 1;
            if(i == phase-1){
                // sel is t, prev is s
                best = min(best, w[sel]);
                // merge sel into prev
                for(int j=0;j<phase;++j) a[prev][j] += a[sel][j], a[j][prev] = a[prev][j];
                v.erase(v.begin()+sel);
                for(int j=sel;j<phase-1;++j){
                    for(int k=0;k<phase-1;++k) a[j][k] = a[j+1][k+ (k>=sel?1:0)];
                }
            } else {
                prev = sel;
                for(int j=0;j<phase;++j) if(!added[j]) w[j] += a[sel][j];
            }
        }
    }
    return best;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<vector<ll>> a(n, vector<ll>(n,0));
    int m; cin>>m;
    for(int i=0;i<m;++i){ int u,v; ll w; cin>>u>>v>>w; a[u][v]+=w; a[v][u]+=w; }
    cout << "Global min cut: " << stoerWagner(a) << "\n";
    return 0;
}

Prueba
? Small undirected graph compare manual min-cut.


Ejercicio 33 — Graph Isomorphism (naive backtracking + pruning for small n)
Análisis
 Determinar si dos labelled graphs G1 and G2 (n ? 10-12) son isomorfos (exist permutation mapping adjacency). For small n backtracking with degree sequence pruning works.
Diseño
? Quick prune: degree sequences must match multiset.

? Backtracking: assign mapping node-by-node, check partial adjacency consistency. Use ordering by degrees to reduce branching.

Código (C++)
#include <bits/stdc++.h>
using namespace std;

int n;
vector<vector<int>> A, B;
vector<int> perm;
vector<char> used;
vector<int> order;

bool checkPartial(int idx){
    int u = order[idx];
    for(int i=0;i<idx;++i){
        int ui = order[i];
        if(A[u][ui] != B[perm[u]][perm[ui]]) return false;
    }
    return true;
}

bool backtrack(int idx){
    if(idx==n) return true;
    int u = order[idx];
    for(int v=0; v<n; ++v) if(!used[v]){
        perm[u]=v; used[v]=1;
        bool ok=true;
        for(int i=0;i<idx;++i){
            int ui=order[i];
            if(A[u][ui] != B[perm[u]][perm[ui]]){ ok=false; break; }
        }
        if(ok && backtrack(idx+1)) return true;
        used[v]=0;
    }
    return false;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    if(!(cin>>n)) return 0;
    A.assign(n, vector<int>(n));
    B.assign(n, vector<int>(n));
    for(int i=0;i<n;++i) for(int j=0;j<n;++j) cin>>A[i][j];
    for(int i=0;i<n;++i) for(int j=0;j<n;++j) cin>>B[i][j];
    // degrees
    vector<int> da(n,0), db(n,0);
    for(int i=0;i<n;++i) for(int j=0;j<n;++j){ da[i]+=A[i][j]; db[i]+=B[i][j]; }
    auto sda = da; auto sdb = db;
    sort(sda.begin(), sda.end()); sort(sdb.begin(), sdb.end());
    if(sda != sdb){ cout<<"Not isomorphic\n"; return 0; }
    order.resize(n);
    iota(order.begin(), order.end(), 0);
    sort(order.begin(), order.end(), [&](int x,int y){ if(da[x]!=da[y]) return da[x]>da[y]; return x<y; });
    perm.assign(n, -1); used.assign(n,0);
    bool iso = backtrack(0);
    cout << (iso ? "Isomorphic\n" : "Not isomorphic\n");
    return 0;
}

Prueba
? n small (?8): test isomorphic permutations and non-isomorphic graphs.


Ejercicio 34 — Randomized algorithms: Miller–Rabin primality test (64-bit safe bases)
Análisis
 Implementar Miller–Rabin deterministic set of bases to test 64-bit integers for primality. Fast and reliable for competitive programming.
Diseño
? Use modular multiplication avoiding overflow (128-bit).

? Use known good bases for 64-bit (e.g., {2,3,5,7,11,13} or canonical set {2,3,5,7,11,13,17}).

? Implement powmod and witness routine.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using u128 = unsigned __int128;
using u64 = unsigned long long;

u64 modmul(u64 a, u64 b, u64 mod){
    return (u64)((u128)a * b % mod);
}
u64 modpow(u64 a, u64 d, u64 mod){
    u64 res=1;
    while(d){
        if(d&1) res = modmul(res,a,mod);
        a = modmul(a,a,mod);
        d >>= 1;
    }
    return res;
}
bool isPrime(u64 n){
    if(n<2) return false;
    for(u64 p: {2,3,5,7,11,13,17,19,23,29,31,37}){
        if(n%p==0) return n==p;
    }
    u64 d = n-1, s=0;
    while((d&1)==0){ d>>=1; ++s; }
    // bases for 64-bit deterministic
    u64 bases[] = {2,325,9375,28178,450775,9780504,1795265022};
    for(u64 a: bases){
        if(a%n==0) continue;
        u64 x = modpow(a, d, n);
        if(x==1 || x==n-1) continue;
        bool comp = true;
        for(u64 r=1;r<s;++r){
            x = modmul(x, x, n);
            if(x==n-1){ comp=false; break; }
        }
        if(comp) return false;
    }
    return true;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    unsigned long long x;
    while(cin>>x) cout << x << (isPrime(x) ? " is prime\n" : " is composite\n");
    return 0;
}

Prueba
? Test primes and composites: 2,3,4,17,1e9+7, large Carmichael numbers.


Ejercicio 35 — Pollard’s Rho factorization (randomized, 64-bit)
Análisis
 Factorizar enteros grandes (?64-bit) probabilísticamente con Pollard’s Rho + Miller–Rabin primality check.
Diseño
? Use Miller–Rabin from ejercicio 34.

? Pollard Rho with randomized polynomial f(x) = x^2 + c (mod n), use gcd and Floyd cycle detection (or Brent).

? Recursively factor.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using u64 = unsigned long long;
using u128 = unsigned __int128;

u64 modmul(u64 a,u64 b,u64 mod){ return (u64)((u128)a*b % mod); }
u64 modpow(u64 a,u64 d,u64 mod){ u64 r=1; while(d){ if(d&1) r=modmul(r,a,mod); a=modmul(a,a,mod); d>>=1;} return r; }
// Miller-Rabin (same as previous)...
bool isPrime(u64 n){
    if(n<2) return false;
    for(u64 p: {2,3,5,7,11,13,17,19,23,29,31,37}){ if(n%p==0) return n==p; }
    u64 d=n-1,s=0; while((d&1)==0){d>>=1;s++;}
    u64 bases[] = {2,325,9375,28178,450775,9780504,1795265022};
    for(u64 a: bases){
        if(a%n==0) continue;
        u64 x = modpow(a,d,n);
        if(x==1||x==n-1) continue;
        bool comp=true;
        for(u64 r=1;r<s;++r){ x=modmul(x,x,n); if(x==n-1){comp=false;break;} }
        if(comp) return false;
    }
    return true;
}

u64 pollards_rho(u64 n){
    if(n%2==0) return 2;
    if(n%3==0) return 3;
    u64 c = rand() % (n-1) + 1;
    u64 x = rand() % n, y = x;
    u64 d = 1;
    auto f = [&](u64 x){ return (modmul(x,x,n) + c) % n; };
    while(d==1){
        x = f(x); y = f(f(y));
        u64 diff = x>y? x-y : y-x;
        d = std::gcd(diff, n);
        if(d==n) return pollards_rho(n);
    }
    return d;
}

void factor(u64 n, vector<u64>& out){
    if(n==1) return;
    if(isPrime(n)){ out.push_back(n); return; }
    u64 d = pollards_rho(n);
    factor(d, out);
    factor(n/d, out);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    u64 n; while(cin>>n){
        vector<u64> fac; factor(n, fac);
        sort(fac.begin(), fac.end());
        for(u64 p: fac) cout<<p<<" ";
        cout<<"\n";
    }
    return 0;
}

Prueba
? Factor 1e12+39 etc. Works probabilistically; combine with Miller–Rabin.


Ejercicio 36 — Minimum Mean Cycle (Karp’s algorithm)
Analysis
 Find directed cycle with minimum average weight (mean weight per edge) in O(n*m) using Karp.
Design
 Compute dp[k][v] = min weight of path length k ending at v. Then for each v compute max over k of (dp[n][v] - dp[k][v])/(n-k) and take minimum over v.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = 4e18;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<pair<int,ll>>> g(n);
    for(int i=0;i<m;++i){ int u,v; ll w; cin>>u>>v>>w; g[u].push_back({v,w}); }
    vector<vector<ll>> dp(n+1, vector<ll>(n, INF));
    // dp[0][v] = 0 for all v
    for(int v=0; v<n; ++v) dp[0][v]=0;
    for(int k=1;k<=n;++k){
        for(int v=0; v<n; ++v){
            for(auto &e: g[v]){ int to = e.first; ll w = e.second; if(dp[k-1][v]<INF) dp[k][to] = min(dp[k][to], dp[k-1][v] + w); }
        }
    }
    double ans = 1e300;
    for(int v=0; v<n; ++v){
        if(dp[n][v] >= INF) continue;
        double maxAvg = -
Ejercicio 31 — All-Pairs Shortest Paths with Johnson (Dijkstra + reweight)
Análisis
 Calcular distancias mínimas entre todos los pares en grafo dirigido con pesos (puede tener aristas negativas, pero sin ciclos negativos). Floyd–Warshall es O(n³); Johnson usa una corrida de Bellman–Ford una vez y luego Dijkstra desde cada nodo: O(n m log n) ideal para grafos esparsos.
Diseño
1. Añadir nodo ficticio s' con aristas 0 a todos.

2. Ejecutar Bellman–Ford desde s' para obtener potencias h[v]; si detecta ciclo negativo -> abortar.

3. Reweight edges: w'(u,v) = w(u,v) + h[u] - h[v] (no-negativos).

4. Ejecutar Dijkstra desde cada nodo con pesos w' y corregir distancias: dist(u,v) = d'(u,v) - h[u] + h[v].

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = (1LL<<60);

struct Edge { int u,v; ll w; };

vector<ll> bellmanFord(int n, int s, const vector<Edge>& edges){
    vector<ll> d(n, INF); d[s]=0;
    for(int it=0; it<n-1; ++it){
        bool changed=false;
        for(auto &e: edges) if(d[e.u]<INF && d[e.v] > d[e.u] + e.w){
            d[e.v] = d[e.u] + e.w; changed=true;
        }
        if(!changed) break;
    }
    // check negative cycle
    for(auto &e: edges) if(d[e.u]<INF && d[e.v] > d[e.u] + e.w) return {};
    return d;
}

vector<ll> dijkstra(int n, int s, const vector<vector<pair<int,ll>>>& g){
    vector<ll> d(n, INF); d[s]=0;
    priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<>> pq;
    pq.push({0,s});
    while(!pq.empty()){
        auto [dist,u] = pq.top(); pq.pop();
        if(dist != d[u]) continue;
        for(auto &ed: g[u]){
            int v = ed.first; ll w = ed.second;
            if(d[v] > d[u] + w){ d[v] = d[u] + w; pq.push({d[v], v}); }
        }
    }
    return d;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<Edge> edges;
    vector<vector<pair<int,ll>>> g(n);
    for(int i=0;i<m;++i){ int u,v; ll w; cin>>u>>v>>w; edges.push_back({u,v,w}); g[u].push_back({v,w}); }
    // Bellman-Ford from artificial node n
    vector<Edge> edges2 = edges;
    for(int v=0; v<n; ++v) edges2.push_back({n, v, 0});
    auto h = bellmanFord(n+1, n, edges2);
    if(h.empty()){ cout<<"Negative cycle detected\n"; return 0; }
    h.resize(n); // drop artificial
    // reweight graph
    vector<vector<pair<int,ll>>> g2(n);
    for(auto &e: edges){
        ll wprime = e.w + h[e.u] - h[e.v];
        if(wprime < 0) wprime = 0; // numeric safety
        g2[e.u].push_back({e.v, wprime});
    }
    // run Dijkstra from each node and adjust distances
    vector<vector<ll>> all(n, vector<ll>(n, INF));
    for(int u=0; u<n; ++u){
        auto d = dijkstra(n, u, g2);
        for(int v=0; v<n; ++v) if(d[v]<INF) all[u][v] = d[v] - h[u] + h[v];
    }
    // output matrix
    for(int i=0;i<n;++i){
        for(int j=0;j<n;++j){
            if(all[i][j]>=INF/2) cout<<"INF ";
            else cout<<all[i][j]<<" ";
        }
        cout<<"\n";
    }
    return 0;
}

Prueba
? Grafo con 4 nodos y algunas aristas con negativos pero sin ciclos negativos; comparar con Floyd–Warshall.


Ejercicio 32 — Minimum Cut via Stoer–Wagner (global min cut, undirected)
Análisis
 Encontrar corte mínimo global (sin especificar s/t) en grafo no dirigido con pesos (Stoer–Wagner) en O(n³) worst but practical for n ? 500.
Diseño
 Implementar fase de "maximum adjacency search" repetida y contraction de un vértice por fase; track min cut weight.
Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = (1LL<<60);

ll stoerWagner(vector<vector<ll>> a){
    int n = a.size();
    vector<int> v(n);
    iota(v.begin(), v.end(), 0);
    ll best = INF;
    for(int phase = n; phase > 1; --phase){
        vector<ll> w(phase,0);
        vector<char> added(phase, false);
        int prev = -1;
        for(int i=0;i<phase;++i){
            int sel = -1;
            for(int j=0;j<phase;++j) if(!added[j] && (sel==-1 || w[j] > w[sel])) sel = j;
            if(added[sel]) break;
            added[sel] = 1;
            if(i == phase-1){
                // sel is t, prev is s
                best = min(best, w[sel]);
                // merge sel into prev
                for(int j=0;j<phase;++j) a[prev][j] += a[sel][j], a[j][prev] = a[prev][j];
                v.erase(v.begin()+sel);
                for(int j=sel;j<phase-1;++j){
                    for(int k=0;k<phase-1;++k) a[j][k] = a[j+1][k+ (k>=sel?1:0)];
                }
            } else {
                prev = sel;
                for(int j=0;j<phase;++j) if(!added[j]) w[j] += a[sel][j];
            }
        }
    }
    return best;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<vector<ll>> a(n, vector<ll>(n,0));
    int m; cin>>m;
    for(int i=0;i<m;++i){ int u,v; ll w; cin>>u>>v>>w; a[u][v]+=w; a[v][u]+=w; }
    cout << "Global min cut: " << stoerWagner(a) << "\n";
    return 0;
}

Prueba
? Small undirected graph compare manual min-cut.


Ejercicio 33 — Graph Isomorphism (naive backtracking + pruning for small n)
Análisis
 Determinar si dos labelled graphs G1 and G2 (n ? 10-12) son isomorfos (exist permutation mapping adjacency). For small n backtracking with degree sequence pruning works.
Diseño
? Quick prune: degree sequences must match multiset.

? Backtracking: assign mapping node-by-node, check partial adjacency consistency. Use ordering by degrees to reduce branching.

Código (C++)
#include <bits/stdc++.h>
using namespace std;

int n;
vector<vector<int>> A, B;
vector<int> perm;
vector<char> used;
vector<int> order;

bool checkPartial(int idx){
    int u = order[idx];
    for(int i=0;i<idx;++i){
        int ui = order[i];
        if(A[u][ui] != B[perm[u]][perm[ui]]) return false;
    }
    return true;
}

bool backtrack(int idx){
    if(idx==n) return true;
    int u = order[idx];
    for(int v=0; v<n; ++v) if(!used[v]){
        perm[u]=v; used[v]=1;
        bool ok=true;
        for(int i=0;i<idx;++i){
            int ui=order[i];
            if(A[u][ui] != B[perm[u]][perm[ui]]){ ok=false; break; }
        }
        if(ok && backtrack(idx+1)) return true;
        used[v]=0;
    }
    return false;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    if(!(cin>>n)) return 0;
    A.assign(n, vector<int>(n));
    B.assign(n, vector<int>(n));
    for(int i=0;i<n;++i) for(int j=0;j<n;++j) cin>>A[i][j];
    for(int i=0;i<n;++i) for(int j=0;j<n;++j) cin>>B[i][j];
    // degrees
    vector<int> da(n,0), db(n,0);
    for(int i=0;i<n;++i) for(int j=0;j<n;++j){ da[i]+=A[i][j]; db[i]+=B[i][j]; }
    auto sda = da; auto sdb = db;
    sort(sda.begin(), sda.end()); sort(sdb.begin(), sdb.end());
    if(sda != sdb){ cout<<"Not isomorphic\n"; return 0; }
    order.resize(n);
    iota(order.begin(), order.end(), 0);
    sort(order.begin(), order.end(), [&](int x,int y){ if(da[x]!=da[y]) return da[x]>da[y]; return x<y; });
    perm.assign(n, -1); used.assign(n,0);
    bool iso = backtrack(0);
    cout << (iso ? "Isomorphic\n" : "Not isomorphic\n");
    return 0;
}

Prueba
? n small (?8): test isomorphic permutations and non-isomorphic graphs.


Ejercicio 34 — Randomized algorithms: Miller–Rabin primality test (64-bit safe bases)
Análisis
 Implementar Miller–Rabin deterministic set of bases to test 64-bit integers for primality. Fast and reliable for competitive programming.
Diseño
? Use modular multiplication avoiding overflow (128-bit).

? Use known good bases for 64-bit (e.g., {2,3,5,7,11,13} or canonical set {2,3,5,7,11,13,17}).

? Implement powmod and witness routine.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using u128 = unsigned __int128;
using u64 = unsigned long long;

u64 modmul(u64 a, u64 b, u64 mod){
    return (u64)((u128)a * b % mod);
}
u64 modpow(u64 a, u64 d, u64 mod){
    u64 res=1;
    while(d){
        if(d&1) res = modmul(res,a,mod);
        a = modmul(a,a,mod);
        d >>= 1;
    }
    return res;
}
bool isPrime(u64 n){
    if(n<2) return false;
    for(u64 p: {2,3,5,7,11,13,17,19,23,29,31,37}){
        if(n%p==0) return n==p;
    }
    u64 d = n-1, s=0;
    while((d&1)==0){ d>>=1; ++s; }
    // bases for 64-bit deterministic
    u64 bases[] = {2,325,9375,28178,450775,9780504,1795265022};
    for(u64 a: bases){
        if(a%n==0) continue;
        u64 x = modpow(a, d, n);
        if(x==1 || x==n-1) continue;
        bool comp = true;
        for(u64 r=1;r<s;++r){
            x = modmul(x, x, n);
            if(x==n-1){ comp=false; break; }
        }
        if(comp) return false;
    }
    return true;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    unsigned long long x;
    while(cin>>x) cout << x << (isPrime(x) ? " is prime\n" : " is composite\n");
    return 0;
}

Prueba
? Test primes and composites: 2,3,4,17,1e9+7, large Carmichael numbers.


Ejercicio 35 — Pollard’s Rho factorization (randomized, 64-bit)
Análisis
 Factorizar enteros grandes (?64-bit) probabilísticamente con Pollard’s Rho + Miller–Rabin primality check.
Diseño
? Use Miller–Rabin from ejercicio 34.

? Pollard Rho with randomized polynomial f(x) = x^2 + c (mod n), use gcd and Floyd cycle detection (or Brent).

? Recursively factor.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using u64 = unsigned long long;
using u128 = unsigned __int128;

u64 modmul(u64 a,u64 b,u64 mod){ return (u64)((u128)a*b % mod); }
u64 modpow(u64 a,u64 d,u64 mod){ u64 r=1; while(d){ if(d&1) r=modmul(r,a,mod); a=modmul(a,a,mod); d>>=1;} return r; }
// Miller-Rabin (same as previous)...
bool isPrime(u64 n){
    if(n<2) return false;
    for(u64 p: {2,3,5,7,11,13,17,19,23,29,31,37}){ if(n%p==0) return n==p; }
    u64 d=n-1,s=0; while((d&1)==0){d>>=1;s++;}
    u64 bases[] = {2,325,9375,28178,450775,9780504,1795265022};
    for(u64 a: bases){
        if(a%n==0) continue;
        u64 x = modpow(a,d,n);
        if(x==1||x==n-1) continue;
        bool comp=true;
        for(u64 r=1;r<s;++r){ x=modmul(x,x,n); if(x==n-1){comp=false;break;} }
        if(comp) return false;
    }
    return true;
}

u64 pollards_rho(u64 n){
    if(n%2==0) return 2;
    if(n%3==0) return 3;
    u64 c = rand() % (n-1) + 1;
    u64 x = rand() % n, y = x;
    u64 d = 1;
    auto f = [&](u64 x){ return (modmul(x,x,n) + c) % n; };
    while(d==1){
        x = f(x); y = f(f(y));
        u64 diff = x>y? x-y : y-x;
        d = std::gcd(diff, n);
        if(d==n) return pollards_rho(n);
    }
    return d;
}

void factor(u64 n, vector<u64>& out){
    if(n==1) return;
    if(isPrime(n)){ out.push_back(n); return; }
    u64 d = pollards_rho(n);
    factor(d, out);
    factor(n/d, out);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    u64 n; while(cin>>n){
        vector<u64> fac; factor(n, fac);
        sort(fac.begin(), fac.end());
        for(u64 p: fac) cout<<p<<" ";
        cout<<"\n";
    }
    return 0;
}

Prueba
? Factor 1e12+39 etc. Works probabilistically; combine with Miller–Rabin.


Ejercicio 36 — Minimum Mean Cycle (Karp’s algorithm)
Analysis
 Find directed cycle with minimum average weight (mean weight per edge) in O(n*m) using Karp.
Design
 Compute dp[k][v] = min weight of path length k ending at v. Then for each v compute max over k of (dp[n][v] - dp[k][v])/(n-k) and take minimum over v.
Code (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = 4e18;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<vector<pair<int,ll>>> g(n);
    for(int i=0;i<m;++i){ int u,v; ll w; cin>>u>>v>>w; g[u].push_back({v,w}); }
    vector<vector<ll>> dp(n+1, vector<ll>(n, INF));
    // dp[0][v] = 0 for all v
    for(int v=0; v<n; ++v) dp[0][v]=0;
    for(int k=1;k<=n;++k){
        for(int v=0; v<n; ++v){
            for(auto &e: g[v]){ int to = e.first; ll w = e.second; if(dp[k-1][v]<INF) dp[k][to] = min(dp[k][to], dp[k-1][v] + w); }
        }
    }
    double ans = 1e300;
    for(int v=0; v<n; ++v){
        if(dp[n][v] >= INF) continue;
        double maxAvg = -
Ejercicio 36 — Minimum Mean Cycle (Karp’s algorithm)
Análisis
 Encontrar en un grafo dirigido (con pesos que pueden ser positivos o negativos) el ciclo con mínima media aritmética (peso total / longitud). Karp ofrece un algoritmo O(n·m) usando DP por longitudes de camino. Devuelve la media mínima o indica que no existe ciclo.
Diseño
? dp[k][v] = peso mínimo de cualquier camino de longitud k que termina en v (k = 0..n).

? Inicializar dp[0][v] = 0 para todo v.

? Para k = 1..n: relajar aristas: dp[k][to] = min(dp[k][to], dp[k-1][v] + w(v->to)).

? Para cada vértice v con dp[n][v] < INF calcular el máximo (sobre k=0..n-1) de (dp[n][v] - dp[k][v]) / (n - k). Ese máximo es el mínimo promedio para ciclos que llegan a v. La respuesta es el mínimo de esos máximos sobre v.

? Si no se detecta ciclo (ans inf), reportar “no cycle”.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const long double INF = 1e300;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; 
    if(!(cin>>n>>m)) return 0;
    vector<vector<pair<int,ll>>> g(n);
    for(int i=0;i<m;++i){
        int u,v; ll w; cin>>u>>v>>w;
        g[u].push_back({v,w});
    }
    // dp[k][v] for k=0..n
    const ll INFLL = (1LL<<60);
    vector<vector<long double>> dp(n+1, vector<long double>(n, INFLL));
    for(int v=0; v<n; ++v) dp[0][v] = 0.0L;
    for(int k=1;k<=n;++k){
        for(int v=0; v<n; ++v){
            if(dp[k-1][v] >= INFLL) continue;
            for(auto &e: g[v]){
                int to = e.first; ll w = e.second;
                dp[k][to] = min(dp[k][to], dp[k-1][v] + (long double)w);
            }
        }
    }
    long double ans = INF;
    for(int v=0; v<n; ++v){
        if(dp[n][v] >= INFLL) continue;
        long double best = -INF;
        for(int k=0;k<=n-1;++k){
            if(dp[k][v] >= INFLL) continue;
            long double val = (dp[n][v] - dp[k][v]) / (long double)(n - k);
            if(val > best) best = val;
        }
        if(best > -INF/2) ans = min(ans, best);
    }
    if(ans == INF) cout << "No cycle\n";
    else cout<<fixed<<setprecision(9)<<(double)ans<<"\n";
    return 0;
}

Pruebas
? Grafo con ciclo negativo medio mínimo:
 n=3 m=3 edges: 0->1 1, 1->2 -3, 2->0 1 ? cycle (0?1?2?0) weight -1 length 3 mean -0.333333 ? salida aprox -0.333333333.


Ejercicio 37 — Counting Hamiltonian Paths in a Directed Acyclic Graph (DP over subsets)
Análisis
 Contar cuántos caminos Hamiltonianos (que visitan cada vértice exactamente una vez) existen en un grafo dirigido con n ? 20 usando DP sobre subconjuntos. En grafos generales el problema es #P-hard; para n?20 se usa bitmask DP O(n²·2^n). Si el grafo es DAG o general, algoritmo funciona igualmente (pero toma tiempo exponencial).
Diseño
? dp[mask][v] = número de caminos que usan exactamente los vértices en mask y terminan en v.

? Base: dp[1<<v][v] = 1.

? Transición: para cada u tal que u está en mask y existe arista u->v, dp[mask][v] += dp[mask ^ (1<<v)][u].

? Sumar dp[(1<<n)-1][v] para todos v para obtener el número de Hamiltonian paths (todas las posibles terminaciones).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    vector<int> adj(n,0);
    for(int i=0;i<m;++i){
        int u,v; cin>>u>>v;
        adj[u] |= (1<<v);
    }
    int N = 1<<n;
    vector<vector<unsigned long long>> dp(N, vector<unsigned long long>(n, 0));
    for(int v=0; v<n; ++v) dp[1<<v][v] = 1;
    for(int mask=1; mask<N; ++mask){
        for(int v=0; v<n; ++v){
            if(!(mask & (1<<v))) continue;
            unsigned long long cur = dp[mask][v];
            if(cur==0) continue;
            int ways_to = adj[v] & (~mask); // neighbors not yet in mask
            // we will extend by adding a new vertex 'u' (but common DP moves other way)
        }
        // classical fill: compute dp[mask][v] from smaller masks
        // we'll do the standard inner loops
    }
    // correct standard transitions (recompute DP properly)
    fill(dp.begin(), dp.end(), vector<unsigned long long>(n,0));
    for(int v=0; v<n; ++v) dp[1<<v][v]=1;
    for(int mask=1; mask<N; ++mask){
        for(int last=0; last<n; ++last){
            if(!(mask & (1<<last))) continue;
            unsigned long long ways = dp[mask][last];
            if(ways==0) continue;
            int to_mask = adj[last] & (~mask);
            for(int nxt = to_mask; nxt; nxt &= (nxt-1)){
                int u = __builtin_ctz(nxt);
                dp[mask | (1<<u)][u] += ways;
            }
        }
    }
    unsigned long long total = 0;
    for(int v=0; v<n; ++v) total += dp[N-1][v];
    cout<<total<<"\n";
    return 0;
}

Pruebas
? n=3 edges: 0->1,1->2 ? hay exactamente 1 Hamiltonian path (0?1?2).

? n=3 complete DAG (all i<j edges) ? 6 Hamiltonian paths (3!).


Ejercicio 38 — Weighted Interval Scheduling (scheduling with binary search + DP)
Análisis
 Dado un conjunto de n intervalos [start_i, end_i) con valor w_i, seleccionar subconjunto disjunto de intervalos con máxima suma de pesos. Solución clásica O(n log n): ordenar por end, precomputar p(i) = último intervalo que termina ? start_i (binary search), DP dp[i] = max(dp[i-1], dp[p(i)] + w_i).
Diseño
? Ordenar por end.

? Construir array ends[] y para cada i buscar p(i) con upper_bound.

? DP iterativo O(n).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
struct Interval { long long s,e,w; };
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<Interval> a(n);
    for(int i=0;i<n;++i) cin>>a[i].s>>a[i].e>>a[i].w;
    sort(a.begin(), a.end(), [](const Interval& A, const Interval& B){ return A.e < B.e; });
    vector<long long> ends(n);
    for(int i=0;i<n;++i) ends[i]=a[i].e;
    vector<long long> dp(n+1,0);
    vector<int> p(n, -1);
    for(int i=0;i<n;++i){
        int idx = int(upper_bound(ends.begin(), ends.end(), a[i].s) - ends.begin()) - 1;
        p[i] = idx;
    }
    for(int i=1;i<=n;++i){
        long long take = a[i-1].w + (p[i-1] >=0 ? dp[p[i-1]+1] : 0);
        dp[i] = max(dp[i-1], take);
    }
    cout<<dp[n]<<"\n";
    return 0;
}

Pruebas
? Intervals: [1,3,w=50],[2,5,w=20],[4,6,w=100] ? best pick [1,3] and [4,6] total 150.


Ejercicio 39 — Longest Increasing Subsequence (LIS) O(n log n) con reconstrucción
Análisis
 Encontrar la LIS (por valor) en un arreglo a en O(n log n) usando patience sorting + track predecessors para reconstruir la subsecuencia.
Diseño
? Mantener vector d con la mínima cola terminadora para cada longitud.

? Mantener pos[len] índice en a del elemento que termina subseq de longitud len.

? parent[i] para reconstrucción.

? Finalmente reconstruir desde pos[len-1].

Código (C++)
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<long long> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    vector<long long> d;
    vector<int> pos; // pos[len-1] = index in a of tail
    vector<int> parent(n, -1);
    for(int i=0;i<n;++i){
        auto it = lower_bound(d.begin(), d.end(), a[i]);
        int len = int(it - d.begin());
        if(it == d.end()){
            d.push_back(a[i]);
            pos.push_back(i);
        } else {
            *it = a[i];
            pos[len] = i;
        }
        if(len>0) parent[i] = pos[len-1];
        pos[len] = i;
    }
    int lis_len = d.size();
    cout<<lis_len<<"\n";
    // reconstruct one LIS: find index of last element (pos[lis_len-1])
    int cur = pos[lis_len-1];
    vector<long long> lis;
    while(cur != -1){ lis.push_back(a[cur]); cur = parent[cur]; }
    reverse(lis.begin(), lis.end());
    for(auto x: lis) cout<<x<<" ";
    cout<<"\n";
    return 0;
}

Pruebas
? a=[3,1,5,2,6,4,9] ? LIS length 4, one LIS e.g., 1 2 4 9.


Ejercicio 40 — Suffix Automaton: count occurrences of every substring (endpos sizes)
Análisis
 Extender el Suffix Automaton (SAM) para, además de contar substrings distintos, calcular cuántas veces aparece cada substring en el texto (el número de endpos por estado). Usamos el atributo cnt[state] = número de end positions (ocurrencias) para ese estado; después de construir SAM, propagamos cnt por orden decreciente de len (topo / counting sort by length). Luego número de ocurrencias de cualquier substring represented by state v es cnt[v]. El número de distintas ocurrencias totales se puede obtener o usar para responder queries.
Diseño
? En extensión extend(c), set `cnt[cur] =

Ejercicio 40 — Suffix Automaton: contar ocurrencias de cada substring (endpos size)
Análisis
 Construir un Suffix Automaton (SAM) para una string s. Además de contar substrings distintos, queremos saber cuántas veces aparece cada substring en s. Esto se obtiene contando el número de posiciones finales (endpos) asociados a cada estado: inicialmente cada extensión crea un estado con cnt=1 (representa la nueva aparición), luego se propaga la cuenta sumando cnt de estados hacia sus link en orden decreciente de len.
Diseño
? Construir SAM con next, link, len.

? Mantener cnt[state] = 1 para estados correspondientes a finales durante la construcción.

? Después de construir, agrupar estados por len y procesarlos de mayor a menor: cnt[link[v]] += cnt[v].

? Para obtener cuántas veces aparece una cadena t, se recorre t por las transiciones a partir de estado 0; si se falla, ocurrencias = 0; si llega a estado v, ocurrencias = cnt[v].

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct SAM {
    struct State {
        int next[26];
        int link;
        int len;
        long long cnt;
        State(){ fill(begin(next), end(next), -1); link=-1; len=0; cnt=0; }
    };
    vector<State> st;
    int last;
    SAM(){ st.reserve(200005); st.push_back(State()); last=0; }
    void extend(char ch){
        int c = ch - 'a';
        int cur = st.size(); st.push_back(State());
        st[cur].len = st[last].len + 1;
        st[cur].cnt = 1; // each extension corresponds to one endpos
        int p = last;
        while(p!=-1 && st[p].next[c]==-1){ st[p].next[c]=cur; p=st[p].link; }
        if(p==-1){ st[cur].link = 0; }
        else {
            int q = st[p].next[c];
            if(st[p].len + 1 == st[q].len) st[cur].link = q;
            else {
                int clone = st.size(); st.push_back(st[q]);
                st[clone].len = st[p].len + 1;
                st[clone].cnt = 0; // clone doesn't add endpos directly
                while(p!=-1 && st[p].next[c]==q){ st[p].next[c]=clone; p=st[p].link; }
                st[q].link = st[cur].link = clone;
            }
        }
        last = cur;
    }
    void build(const string &s){ for(char c: s) extend(c); }
    void compute_occurrences(){
        int sz = st.size();
        int maxlen = 0;
        for(auto &s: st) maxlen = max(maxlen, s.len);
        vector<int> cntLen(maxlen+1, 0);
        for(auto &s: st) cntLen[s.len]++;
        for(int i=1;i<=maxlen;++i) cntLen[i]+=cntLen[i-1];
        vector<int> order(sz);
        for(int i=sz-1;i>=0;--i) order[--cntLen[st[i].len]] = i;
        for(int i=sz-1;i>0;--i){ // from longer to shorter
            int v = order[i];
            if(st[v].link!=-1) st[st[v].link].cnt += st[v].cnt;
        }
    }
    long long occurrences_of(const string &t){
        int v = 0;
        for(char ch: t){
            int c = ch - 'a';
            if(st[v].next[c]==-1) return 0;
            v = st[v].next[c];
        }
        return st[v].cnt;
    }
    long long distinct_substrings(){
        long long res = 0;
        for(size_t i=1;i<st.size();++i) res += (st[i].len - st[st[i].link].len);
        return res;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    string s; if(!(cin>>s)) return 0;
    SAM sam; sam.build(s); sam.compute_occurrences();
    cout << "Distinct substrings: " << sam.distinct_substrings() << "\n";
    // Example queries: read q and q patterns, print occurrences
    int q; cin >> q;
    while(q--){
        string t; cin >> t;
        cout << sam.occurrences_of(t) << "\n";
    }
    return 0;
}

Pruebas
? s = "ababa". Distinct substrings = 9. Queries: "a" -> 3, "aba" -> 2, "ababa" -> 1, "b" -> 2.


Ejercicio 41 — Minimum Cost Maximum Flow for required flow F (Dijkstra + potentials), with path reconstruction
Análisis
 Variación de MCMF: dado s,t y flujo objetivo F, encontrar mínimo coste para enviar exactamente F unidades (o informar si no posible). Necesario en problemas que piden flujo fijo. Usar Dijkstra con potentials para hallar caminos de coste mínimo repetidamente, y reconstruir las rutas/augmentaciones.
Diseño
? Igual que ejercicio 21 pero detener cuando flow == F o no hay camino.

? Guardar for each augment the path and amount augmented if user wants reconstruct route(s).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct Edge{ int to, rev; int cap; long long cost; };
struct MCMF {
    int n; vector<vector<Edge>> g;
    MCMF(int n): n(n), g(n) {}
    void addEdge(int u,int v,int cap,long long cost){
        g[u].push_back({v, (int)g[v].size(), cap, cost});
        g[v].push_back({u, (int)g[u].size()-1, 0, -cost});
    }
    // returns {flow, cost}
    pair<int,long long> minCostFlowWithLimit(int s,int t,int F){
        int flow=0; long long cost=0;
        vector<long long> pot(n,0), dist(n);
        vector<int> pv(n), pe(n);
        const long long INFLL = (1LL<<60);
        while(flow < F){
            // Dijkstra
            fill(dist.begin(), dist.end(), INFLL);
            dist[s]=0;
            priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>> pq;
            pq.push({0,s});
            while(!pq.empty()){
                auto [d,u] = pq.top(); pq.pop();
                if(d != dist[u]) continue;
                for(int i=0;i<(int)g[u].size();++i){
                    Edge &e = g[u][i];
                    if(e.cap<=0) continue;
                    long long nd = d + e.cost + pot[u] - pot[e.to];
                    if(nd < dist[e.to]){
                        dist[e.to] = nd; pv[e.to]=u; pe[e.to]=i; pq.push({nd,e.to});
                    }
                }
            }
            if(dist[t]==INFLL) break;
            for(int i=0;i<n;++i) if(dist[i]<INFLL) pot[i]+=dist[i];
            int add = F - flow;
            for(int v=t; v!=s; v=pv[v]) add = min(add, g[pv[v]][pe[v]].cap);
            for(int v=t; v!=s; v=pv[v]){
                Edge &e = g[pv[v]][pe[v]];
                e.cap -= add;
                g[v][e.rev].cap += add;
            }
            flow += add;
            cost += 1LL * add * pot[t];
        }
        return {flow, cost};
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    MCMF M(n);
    for(int i=0;i<m;++i){ int u,v,cap; long long cost; cin>>u>>v>>cap>>cost; M.addEdge(u,v,cap,cost); }
    int s,t,F; cin>>s>>t>>F;
    auto res = M.minCostFlowWithLimit(s,t,F);
    if(res.first < F) cout<<"Impossible to send required flow\n";
    else cout<<"Flow="<<res.first<<" Cost="<<res.second<<"\n";
    return 0;
}

Pruebas
? Small graph with limited capacities; request F larger than maxflow ? "Impossible".


Ejercicio 42 — Range minimum query (RMQ) with sparse table — O(1) queries, O(n log n) build
Análisis
 Construir estructura para consultas de mínimo en rango (static array, no updates). Preprocesamiento O(n log n), consultas O(1) con sparse table using overlapping intervals.
Diseño
? st[k][i] = min on range [i, i+2^k-1].

? Query [l,r]: k = floor(log2(r-l+1)) ? min(st[k][l], st[k][r-2^k+1]).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
struct RMQ {
    int n;
    vector<vector<long long>> st;
    vector<int> lg;
    RMQ(const vector<long long>& a){
        n = a.size();
        lg.assign(n+1,0);
        for(int i=2;i<=n;++i) lg[i]=lg[i>>1]+1;
        int K = lg[n];
        st.assign(K+1, vector<long long>(n));
        st[0] = a;
        for(int k=1;k<=K;++k){
            for(int i=0;i + (1<<k) <= n; ++i)
                st[k][i] = min(st[k-1][i], st[k-1][i + (1<<(k-1))]);
        }
    }
    long long query(int l,int r){
        int k = lg[r-l+1];
        return min(st[k][l], st[k][r - (1<<k) + 1]);
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    vector<long long> a(n);
    for(int i=0;i<n;++i) cin>>a[i];
    RMQ rmq(a);
    int q; cin>>q;
    while(q--){
        int l,r; cin>>l>>r;
        cout<<rmq.query(l,r)<<"\n";
    }
    return 0;
}

Pruebas
? Array [1,3,-1,7,0]. Query [1,3] ? -1, query [0,4] ? -1.


Ejercicio 43 — K-Shortest Paths (Yen’s algorithm using Dijkstra)
Análisis
 Encontrar las K primeras rutas distintas (simple paths) ordenadas por cost between s and t. Yen’s algorithm uses repeated shortest path computations with temporary edge/node removals. Works well for moderate graphs and small K.
Diseño
? Compute shortest path P0 (Dijkstra).

? For k=1..K-1, for each node i on P_{k-1} do: root = prefix up to node i; temporarily remove edges that would create paths already found with same root; compute spur path from node i to t; combine root+spur ? candidate; collect candidates in min-heap by total cost; pick cheapest new candidate as P_k.

? Complexity: O(K * n * (m log n)) in worst case.

Código (C++) (compact, works for weighted graph)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = (1LL<<60);

struct Edge { int to; ll w; int id; };
struct Graph {
    int n; vector<vector<Edge>> g;
    Graph(int n):n(n),g(n){}
    void addEdge(int u,int v,ll w,int id){ g[u].push_back({v,w,id}); }
    vector<ll> dijkstra(int s, vector<int>& parent_node, vector<int>& parent_edge, 
                        const vector<char>& removed_node, const vector<char>& removed_edge){
        parent_node.assign(n,-1); parent_edge.assign(n,-1);
        vector<ll> dist(n, INF);
        using pli = pair<ll,int>;
        priority_queue<pli, vector<pli>, greater<pli>> pq;
        dist[s]=0; pq.push({0,s});
        while(!pq.empty()){
            auto [d,u]=pq.top(); pq.pop();
            if(d!=dist[u]) continue;
            if(removed_node[u]) continue;
            for(auto &e: g[u]){
                if(removed_edge[e.id]) continue;
                int v=e.to;
                if(removed_node[v]) continue;
                if(dist[v] > d + e.w){
                    dist[v] = d + e.w;
                    parent_node[v] = u; parent_edge[v] = e.id;
                    pq.push({dist[v], v});
                }
            }
        }
        return dist;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    Graph G(n);
    for(int i=0;i<m;++i){ int u,v; long long w; cin>>u>>v>>w; G.addEdge(u,v,w,i); }
    int s,t,K; cin>>s>>t>>K;
    vector<vector<int>> A_paths; // store node sequences
    vector<ll> A_costs;
    // initial shortest path
    vector<int> parent_node, parent_edge;
    vector<char> removed_node(n,0), removed_edge(m,0);
    auto dist = G.dijkstra(s, parent_node, parent_edge, removed_node, removed_edge);
    if(dist[t]==INF){ cout<<"No path\n"; return 0; }
    // reconstruct path nodes
    auto get_path_nodes = [&](int dest){
        vector<int> path;
        for(int v=dest; v!=-1; v=parent_node[v]) path.push_back(v);
        reverse(path.begin(), path.end());
        return path;
    };
    A_paths.push_back(get_path_nodes(t));
    A_costs.push_back(dist[t]);
    // candidates (cost, path nodes)
    using Item = pair<ll, vector<int>>;
    priority_queue<Item, vector<Item>, greater<Item>> cand;
    for(int k=1;k<K;++k){
        for(int i=0;i+1<(int)A_paths[k-1].size(); ++i){
            int spurNode = A_paths[k-1][i];
            vector<int> rootPath(A_paths[k-1].begin(), A_paths[k-1].begin()+i+1);
            // remove edges that share the same rootPath in previous A_paths
            fill(removed_edge.begin(), removed_edge.end(), 0);
            fill(removed_node.begin(), removed_node.end(), 0);
            for(auto &p: A_paths){
                if(p.size() > i && equal(rootPath.begin(), rootPath.end(), p.begin())){
                    // remove edge p[i] -> p[i+1] by finding its id
                    int u = p[i], v = p[i+1];
                    for(auto &e: G.g[u]) if(e.to==v) removed_edge[e.id]=1;
                }
            }
            // remove nodes in rootPath except spurNode
            for(int r=0;r+1<=(int)rootPath.size()-1;++r) if(rootPath[r]!=spurNode) removed_node[rootPath[r]]=1;
            auto dist2 = G.dijkstra(spurNode, parent_node, parent_edge, removed_node, removed_edge);
            if(dist2[t]==INF) continue;
            // build spur path nodes
            vector<int> spurPath;
            for(int v=t; v!=-1; v=parent_node[v]) spurPath.push_back(v);
            reverse(spurPath.begin(), spurPath.end());
            vector<int> total = rootPath;
            total.pop_back();
            total.insert(total.end(), spurPath.begin(), spurPath.end());
            ll totalCost = 0;
            // compute cost by summing edges along `total`
            for(int idx=0; idx+1<total.size(); ++idx){
                int u=total[idx], v=total[idx+1];
                // find edge weight (first occurrence)
                for(auto &e: G.g[u]) if(e.to==v){ totalCost += e.w; break; }
            }
            cand.push({totalCost, total});
        }
        if(cand.empty()) break;
        auto best = cand.top(); cand.pop();
        A_costs.push_back(best.first);
        A_paths.push_back(best.second);
    }
    for(size_t i=0;i<A_paths.size();++i){
        cout<<"Path "<<i<<": cost="<<A_costs[i]<<" nodes:";
        for(int v:A_paths[i]) cout<<" "<<v;
        cout<<"\n";
    }
    return 0;
}

Pruebas
? Small directed graph where multiple distinct k-shortest paths exist; check listed paths ordered by cost.


Ejercicio 44 — Dynamic Convex Hull Trick (Li Chao tree revisited) with queries online (min)
Análisis
 Implement Li Chao tree for y = m*x + b lines and min query at point x. This supports adding lines online and querying arbitrary x in O(log R), where R is x-range.
Diseño
? Implementation similar to Ejercicio 20 but include insertion and query operations as public API. Use integer x-range or discrete compression.

Código (C++)
// (Implementation is essentially the same as Ejercicio 20 Li Chao but wrapped as class and with safety)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
struct Line { ll m,b; Line(ll _m=0,ll _b=(1LL<<60)) : m(_m), b(_b) {} ll eval(ll x) const { return m*x + b; } };
struct LiChao {
    struct Node { Line ln; Node *l=nullptr,*r=nullptr; Node(Line v=Line()):ln(v){} };
    Node* root=nullptr; ll L,R;
    LiChao(ll L, ll R): L(L), R(R), root(nullptr) {}
    void add_line(Line nw){ insert(root, L, R, nw); }
    void insert(Node*& node, ll l, ll r, Line nw){
        if(!node){ node = new Node(nw); return; }
        ll mid = (l+r)>>1;
        bool left = nw.eval(l) < node->ln.eval(l);
        bool m = nw.eval(mid) < node->ln.eval(mid);
        if(m) swap(nw, node->ln);
        if(l==r) return;
        if(left != m) insert(node->l, l, mid, nw);
        else insert(node->r, mid+1, r, nw);
    }
    ll query(ll x){ return queryRec(root, L, R, x); }
    ll queryRec(Node* node, ll l, ll r, ll x){
        if(!node) return (1LL<<60);
        ll res = node->ln.eval(x);
        if(l==r) return res;
        ll mid=(l+r)>>1;
        if(x<=mid) return min(res, queryRec(node->l, l, mid, x));
        else return min(res, queryRec(node->r, mid+1, r, x));
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int q; if(!(cin>>q)) return 0;
    const ll XMIN = -1000000, XMAX = 1000000;
    LiChao lc(XMIN, XMAX);
    while(q--){
        int t; cin>>t;
        if(t==1){ ll m,b; cin>>m>>b; lc.add_line(Line(m,b)); }
        else { ll x; cin>>x; ll ans = lc.query(x); if(ans > (1LL<<59)) cout<<"INF\n"; else cout<<ans<<"\n"; }
    }
    return 0;
}

Pruebas
? Add lines y = x, y = -x + 10; query x=3 ? min(3,7) = 3.


Ejercicio 45 — Persistent Segment Tree (point update, range sum queries on any version)
Análisis
 Implementar persistent segtree supporting update(version, pos, val) returning new version and query(version, l, r). Useful for persistent arrays, offline queries, kth order statistics, etc.
Diseño
? Node stores sum and pointers l, r. Update builds new path copying nodes O(log n). Query uses version roots.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
struct Node {
    ll sum; Node *l,*r;
    Node(ll s=0, Node*L=nullptr, Node*R=nullptr):sum(s),l(L),r(R){}
};
int N;
Node* build(int tl,int tr){
    if(tl==tr) return new Node(0);
    int tm=(tl+tr)>>1;
    return new Node(0, build(tl,tm), build(tm+1,tr));
}
Node* update(Node* v, int tl,int tr,int pos, ll val){
    if(tl==tr) return new Node(val);
    int tm=(tl+tr)>>1;
    if(pos<=tm) return new Node(v->sum - v->l->sum + val + v->r->sum, update(v->l, tl, tm, pos, val), v->r);
    else return new Node(v->sum - v->r->sum + val + v->l->sum, v->l, update(v->r, tm+1, tr, pos, val));
}
ll query(Node* v,int tl,int tr,int l,int r){
    if(l>r) return 0;
    if(l==tl && r==tr) return v->sum;
    int tm=(tl+tr)>>1;
    return query(v->l,tl,tm,l,min(r,tm)) + query(v->r,tm+1,tr,max(l,tm+1),r);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,q; if(!(cin>>n>>q)) return 0;
    N=n;
    vector<Node*> roots;
    roots.push_back(build(0,N-1));
    while(q--){
        int type; cin>>type;
        if(type==1){
            int ver,pos; long long val; cin>>ver>>pos>>val;
            Node* newroot = update(roots[ver], 0, N-1, pos, val);
            roots.push_back(newroot);
            cout<<"Version "<<roots.size()-1<<"\n";
        } else {
            int ver,l,r; cin>>ver>>l>>r;
            cout<<query(roots[ver], 0, N-1, l, r)<<"\n";
        }
    }
    return 0;
}

Pruebas
? Build initial zeros; update version 0 pos 2 = 5 -> version1; query version1 [0,3] => 5; query version0 [0,3] => 0.


Ejercicio 46 — Re-rooting DP on Tree (compute answer for every root) — example: sum of distances from root to all nodes
Análisis
 Compute for every node v the sum of distances from v to all other nodes. Use two DFS passes: first compute subtree sizes and dp[root]=sum distances from root; second pass reroot transferring values.
Diseño
? dfs1(u,p) computes sz[u] and dp[u] = sum distances from u to nodes in its subtree.

? dfs2(u,p) uses parent result to compute answer for children: ans[v] = ans[u] - sz[v] + (n - sz[v]).

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int n;
vector<vector<int>> g;
vector<int> sz;
vector<ll> dp, ans;

void dfs1(int u,int p){
    sz[u]=1; dp[u]=0;
    for(int v: g[u]) if(v!=p){
        dfs1(v,u);
        sz[u]+=sz[v];
        dp[u] += dp[v] + sz[v];
    }
}
void dfs2(int u,int p){
    ans[u] = dp[u];
    for(int v: g[u]) if(v!=p){
        ll du = dp[u], dv = dp[v];
        int su = sz[u], sv = sz[v];
        // reroot u->v
        dp[u] -= (dp[v] + sz[v]);
        sz[u] -= sz[v];
        dp[v] += (dp[u] + sz[u]);
        sz[v] += sz[u];
        dfs2(v,u);
        // restore
        dp[u]=du; dp[v]=dv; sz[u]=su; sz[v]=sv;
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    if(!(cin>>n)) return 0;
    g.assign(n, {});
    for(int i=0;i<n-1;++i){ int u,v; cin>>u>>v; g[u].push_back(v); g[v].push_back(u); }
    sz.assign(n,0); dp.assign(n,0); ans.assign(n,0);
    dfs1(0,-1);
    dfs2(0,-1);
    for(int i=0;i<n;++i) cout<<ans[i]<<(i+1==n?'\n':' ');
    return 0;
}

Pruebas
? Tree line of 4 nodes 0-1-2-3. Sum distances: node0->6, node1->4, node2->4, node3->6.


Ejercicio 47 — Maximum Subarray Sum with divide-and-conquer (Kadane vs D&C)
Análisis
 Implementar maximum subarray sum using divide-and-conquer (useful didactic alternative to Kadane). Complexity O(n log n). Also show Kadane as faster linear method.
Diseño
? For segment [l,r], compute: left best, right best, prefix max, suffix max and combine. Return structure with these four values.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
struct Node { ll sum, pref, suff, best; };
vector<ll> a;
Node mergeNode(const Node &L, const Node &R){
    Node res;
    res.sum = L.sum + R.sum;
    res.pref = max(L.pref, L.sum + R.pref);
    res.suff = max(R.suff, R.sum + L.suff);
    res.best = max({L.best, R.best, L.suff + R.pref});
    return res;
}
Node build(int l,int r){
    if(l==r) return Node{a[l], a[l], a[l], a[l]};
    int m=(l+r)/2;
    Node L = build(l,m), R = build(m+1,r);
    return mergeNode(L,R);
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; if(!(cin>>n)) return 0;
    a.resize(n);
    for(int i=0;i<n;++i) cin>>a[i];
    Node res = build(0,n-1);
    cout<<res.best<<"\n";
    return 0;
}

Pruebas
? a = [-2,1,-3,4,-1,2,1,-5,4] ? best = 6 (subarray [4,-1,2,1]).


Ejercicio 48 — Tree centroid decomposition (for distance queries / dynamic problems)
Análisis
 Build centroid decomposition of a tree to support queries like "count nodes within distance ? D" with updates. Provide centroid tree construction.
Diseño
? Repeatedly find centroid of current subtree by sizes, mark centroid, recursively decompose subtrees, keep parent in centroid tree. Complexity O(n log n) build.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
int n;
vector<vector<int>> g;
vector<int> sz, used, parentC;

int dfs_size(int u,int p){
    sz[u]=1;
    for(int v:g[u]) if(v!=p && !used[v]) sz[u]+=dfs_size(v,u);
    return sz[u];
}
int find_centroid(int u,int p,int total){
    for(int v: g[u]) if(v!=p && !used[v]){
        if(sz[v] > total/2) return find_centroid(v,u,total);
    }
    return u;
}
void decompose(int u,int p){
    int total = dfs_size(u,-1);
    int c = find_centroid(u,-1,total);
    used[c]=1;
    parentC[c] = p;
    for(int v: g[c]) if(!used[v]) decompose(v,c);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    if(!(cin>>n)) return 0;
    g.assign(n, {});
    for(int i=0;i<n-1;++i){ int u,v; cin>>u>>v; g[u].push_back(v); g[v].push_back(u); }
    sz.assign(n,0); used.assign(n,0); parentC.assign(n,-1);
    decompose(0,-1);
    for(int i=0;i<n;++i) cout<<i<<" -> centroid parent: "<<parentC[i]<<"\n";
    return 0;
}

Pruebas
? Small trees show centroid parents forming centroid tree.


Ejercicio 49 — Maximum Flow with capacity scaling (Dinic variant improvement)
Análisis
 Implement capacity scaling improvement for Dinic/Edmonds-Karp: process capacities in decreasing powers of two to speed up in graphs with large capacities. Simpler approach: use Dinic (exercise 6) but this exercise shows capacity scaling conceptually.
Diseño
? Repeatedly run blocking flow considering only edges with cap >= scale, reduce scale by half.

Código (C++)
// For brevity reuse Dinic structure and apply capacity thresholding by temporarily ignoring small edges in BFS/DFS
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
struct Edge{ int to, rev; ll cap; };
struct DinicScaling {
    int n; vector<vector<Edge>> g;
    DinicScaling(int n):n(n),g(n){}
    void addEdge(int u,int v,ll c){
        g[u].push_back({v,(int)g[v].size(),c});
        g[v].push_back({u,(int)g[u].size()-1,0});
    }
    vector<int> level, ptr;
    bool bfs(int s,int t, ll threshold){
        fill(level.begin(), level.end(), -1);
        queue<int> q;
        level[s]=0; q.push(s);
        while(!q.empty()){
            int v=q.front(); q.pop();
            for(auto &e: g[v]){
                if(level[e.to]==-1 && e.cap >= threshold){
                    level[e.to]=level[v]+1; q.push(e.to);
                }
            }
        }
        return level[t]!=-1;
    }
    ll dfs(int v,int t,ll pushed, ll threshold){
        if(!pushed) return 0;
        if(v==t) return pushed;
        for(int &cid = ptr[v]; cid<(int)g[v].size(); ++cid){
            Edge &e = g[v][cid];
            if(level[e.to] != level[v]+1 || e.cap < threshold) continue;
            ll tr = dfs(e.to, t, min(pushed, e.cap), threshold);
            if(tr){
                e.cap -= tr; g[e.to][e.rev].cap += tr; return tr;
            }
        }
        return 0;
    }
    ll maxflow(int s,int t){
        ll flow=0;
        ll maxCap=0;
        for(int i=0;i<n;++i) for(auto &e: g[i]) maxCap = max(maxCap, e.cap);
        level.assign(n, -1); ptr.assign(n,0);
        for(ll scale = 1LL<< (63 - __builtin_clzll(maxCap)); scale>0; scale >>=1){
            while(bfs(s,t,scale)){
                fill(ptr.begin(), ptr.end(), 0);
                while(ll pushed = dfs(s,t,LLONG_MAX, scale)) flow += pushed;
            }
        }
        return flow;
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,m; if(!(cin>>n>>m)) return 0;
    DinicScaling D(n);
    for(int i=0;i<m;++i){ int u,v; long long c; cin>>u>>v>>c; D.addEdge(u,v,c); }
    int s,t; cin>>s>>t;
    cout<<D.maxflow(s,t)<<"\n";
    return 0;
}

Pruebas
? Compare with Dinic for same graph; results equal.


Ejercicio 50 — Graph coloring heuristic (greedy Welsh-Powell) + exact check small graphs (backtracking)
Análisis
 Color the vertices of a graph with minimum colors (chromatic number). Exact is NP-hard; implement heuristic Welsh–Powell (order vertices by descending degree, greedily color each with smallest possible color). Also provide exact backtracking for n ? 20.
Diseño
? Heuristic: sort vertices by degree, assign smallest available color using boolean used array.

? Exact: backtracking try assign colors up to current best and prune by conflicts.

Código (C++)
#include <bits/stdc++.h>
using namespace std;
int n;
vector<vector<int>> adj;
vector<int> order;

int greedy_coloring(){
    vector<int> deg(n);
    for(int i=0;i<n;++i) deg[i]=adj[i].size();
    order.resize(n); iota(order.begin(), order.end(), 0);
    sort(order.begin(), order.end(), [&](int a,int b){ return deg[a]>deg[b]; });
    vector<int> color(n, -1);
    int maxc = 0;
    for(int u: order){
        vector<char> used(n+1,false);
        for(int v: adj[u]) if(color[v]!=-1) used[color[v]] = true;
        int c=1; while(used[c]) ++c;
        color[u]=c; maxc = max(maxc, c);
    }
    return maxc;
}

// exact (backtracking) for small n
int best = INT_MAX;
void exact_bt(vector<int>& color, int idx, int usedColors){
    if(usedColors >= best) return;
    if(idx==n){ best = min(best, usedColors); return; }
    int u = idx;
    vector<char> used(usedColors+2,false);
    for(int v: adj[u]) if(color[v]>0 && color[v] <= usedColors) used[color[v]]=true;
    for(int c=1;c<=usedColors;++c){
        if(!used[c]){ color[u]=c; exact_bt(color, idx+1, usedColors); color[u]=0; }
    }
    // try new color
    color[u] = usedColors+1;
    exact_bt(color, idx+1, usedColors+1);
    color[u]=0;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    if(!(cin>>n)) return 0;
    adj.assign(n, {});
    int m; cin>>m;
    for(int i=0;i<m;++i){ int u,v; cin>>u>>v; adj[u].push_back(v); adj[v].push_back(u); }
    int g = greedy_coloring();
    cout<<"Greedy colors: "<<g<<"\n";
    if(n<=20){
        vector<int> color(n,0);
        best = g;
        exact_bt(color, 0, 0);
        cout<<"Exact chromatic (n<=20): "<<best<<"\n";
    } else cout<<"Exact coloring skipped (n>20)\n";
    return 0;
}

Pruebas
? Small graphs: triangle -> greedy 3, exact 3; bipartite -> greedy 2, exact 2.
Ejercicio 1
Título del Ejercicio: Intercambio de Valores con Punteros
Análisis del Problema
? Descripción del Problema: Crear una función que reciba dos punteros a enteros y los intercambie. Por ejemplo, si a = 5 y b = 10, después del intercambio a = 10 y b = 5.

? Entradas y Salidas:

? Entrada: Dos números enteros a y b.

? Salida: Los valores intercambiados de a y b.

Diseño de la Solución
? Algoritmo Propuesto:

1. Pedir al usuario que ingrese dos números enteros.

2. Llamar a una función que reciba punteros a los dos números.

3. Dentro de la función, usar una variable temporal para intercambiar los valores.

4. Mostrar los valores intercambiados.

? Estructuras de Datos: Dos variables enteras y un puntero por cada variable.

? Funciones Principales: main() y intercambiar(int* x, int* y).

Código Fuente (C++)
#include <iostream>

void intercambiar(int* x, int* y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main() {
    int a, b;
    std::cout << "Ingresa dos numeros enteros: ";
    std::cin >> a >> b;

    intercambiar(&a, &b);

    std::cout << "Valores intercambiados: a = " << a << ", b = " << b << std::endl;
    return 0;
}

Pruebas
? Caso 1: a = 5, b = 10 ? Salida: a = 10, b = 5

? Caso 2: a = -3, b = 7 ? Salida: a = 7, b = -3

? Caso 3: a = 0, b = 0 ? Salida: a = 0, b = 0


Ejercicio 2
Título del Ejercicio: Factorial de un Número (Recursivo)
Análisis del Problema
? Descripción del Problema: Calcular el factorial de un número entero n usando recursión. Por ejemplo, si n = 4, el resultado es 4 * 3 * 2 * 1 = 24.

? Entradas y Salidas:

? Entrada: Un número entero n (no negativo).

? Salida: Factorial de n.

Diseño de la Solución
? Algoritmo Propuesto:

1. Pedir al usuario un número entero n.

2. Crear una función recursiva que devuelva 1 si n = 0 o 1.

3. Si n > 1, retornar n * factorial(n - 1).

4. Mostrar el resultado.

? Estructuras de Datos: Variable entera para n y resultado.

? Funciones Principales: main() y factorial(int n).

Código Fuente (C++)
#include <iostream>

int factorial(int n) {
    if (n <= 1)
        return 1;
    else
        return n * factorial(n - 1);
}

int main() {
    int n;
    std::cout << "Ingresa un numero entero no negativo: ";
    std::cin >> n;

    if (n < 0) {
        std::cout << "Error: el numero debe ser no negativo." << std::endl;
        return 1;
    }

    std::cout << "El factorial de " << n << " es: " << factorial(n) << std::endl;
    return 0;
}

Pruebas
? Caso 1: n = 4 ? Salida: 24

? Caso 2: n = 0 ? Salida: 1

? Caso 3: n = 5 ? Salida: 120


Ejercicio 3
Título del Ejercicio: Contar Vocales en una Cadena (Recursivo)
Análisis del Problema
? Descripción del Problema: Contar cuántas vocales hay en una cadena usando recursión.

? Entradas y Salidas:

? Entrada: Una cadena de caracteres.

? Salida: Número de vocales en la cadena.

Diseño de la Solución
? Algoritmo Propuesto:

1. Pedir al usuario que ingrese una cadena.

2. Crear función recursiva que revise el primer carácter y sume 1 si es vocal.

3. Llamar a la función para el resto de la cadena.

4. Mostrar el total de vocales.

? Estructuras de Datos: Cadena de caracteres y contador entero.

? Funciones Principales: main() y contarVocales(char* str).

Código Fuente (C++)
#include <iostream>
#include <cstring>

int contarVocales(char* str) {
    if (*str == '\0') return 0;

    char c = tolower(*str);
    int suma = (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') ? 1 : 0;
    return suma + contarVocales(str + 1);
}

int main() {
    char cadena[100];
    std::cout << "Ingresa una cadena: ";
    std::cin.getline(cadena, 100);

    std::cout << "Numero de vocales: " << contarVocales(cadena) << std::endl;
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? Salida: 4

? Caso 2: "C++ es divertido" ? Salida: 6

? Caso 3: "XYZ" ? Salida: 0

Ejercicio 4
Título del Ejercicio: Suma de los Elementos de un Array con Punteros
Análisis del Problema
? Descripción del Problema: Crear un programa que reciba un array de enteros y calcule la suma de sus elementos usando punteros.

? Entradas y Salidas:

? Entrada: Tamaño del array n y n números enteros.

? Salida: Suma de los elementos del array.

Diseño de la Solución
? Algoritmo Propuesto:

1. Pedir al usuario el tamaño del array n.

2. Crear un array dinámico de tamaño n.

3. Llenar el array con los valores ingresados.

4. Usar un puntero para recorrer el array y sumar sus elementos.

5. Mostrar la suma.

? Estructuras de Datos: Array dinámico y puntero.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>

int main() {
    int n, suma = 0;
    std::cout << "Ingresa el tamaño del array: ";
    std::cin >> n;

    int* arr = new int[n];

    std::cout << "Ingresa " << n << " numeros enteros:\n";
    for(int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int* ptr = arr;
    for(int i = 0; i < n; ++i) {
        suma += *(ptr + i);
    }

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    delete[] arr;
    return 0;
}

Pruebas
? Caso 1: n=3, array = [1,2,3] ? Salida: 6

? Caso 2: n=5, array = [2,4,6,8,10] ? Salida: 30

? Caso 3: n=0, array = [] ? Salida: 0


Ejercicio 5
Título del Ejercicio: Inversión de un Array Recursivamente
Análisis del Problema
? Descripción del Problema: Invertir un array de enteros usando recursión. Por ejemplo, [1,2,3] ? [3,2,1].

? Entradas y Salidas:

? Entrada: Tamaño n y n números enteros.

? Salida: Array invertido.

Diseño de la Solución
? Algoritmo Propuesto:

1. Pedir tamaño y elementos del array.

2. Crear función recursiva invertir(int arr[], int inicio, int fin) que intercambie elementos extremos hasta el centro.

3. Mostrar array invertido.

? Estructuras de Datos: Array y variables enteras.

? Funciones Principales: main() y invertir().

Código Fuente (C++)
#include <iostream>

void invertir(int arr[], int inicio, int fin) {
    if(inicio >= fin) return;
    int temp = arr[inicio];
    arr[inicio] = arr[fin];
    arr[fin] = temp;
    invertir(arr, inicio+1, fin-1);
}

int main() {
    int n;
    std::cout << "Ingresa el tamaño del array: ";
    std::cin >> n;
    int arr[n];

    std::cout << "Ingresa los elementos del array:\n";
    for(int i=0; i<n; ++i) std::cin >> arr[i];

    invertir(arr, 0, n-1);

    std::cout << "Array invertido: ";
    for(int i=0; i<n; ++i) std::cout << arr[i] << " ";
    std::cout << std::endl;

    return 0;
}

Pruebas
? Caso 1: [1,2,3] ? [3,2,1]

? Caso 2: [5,10,15,20] ? [20,15,10,5]

? Caso 3: [7] ? [7]


Ejercicio 6
Título del Ejercicio: Clase Persona con Método Saludar
Análisis del Problema
? Descripción del Problema: Crear una clase Persona con atributos nombre y edad y un método saludar() que imprima un mensaje de saludo.

? Entradas y Salidas:

? Entrada: Nombre y edad de la persona.

? Salida: Mensaje de saludo.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear clase Persona con atributos nombre y edad.

2. Implementar método saludar() que imprima: "Hola, soy [nombre] y tengo [edad] años".

3. Crear objeto Persona e invocar el método.

? Estructuras de Datos: Clase y variables de tipo string e int.

? Funciones Principales: main() y método de la clase.

Código Fuente (C++)
#include <iostream>
#include <string>

class Persona {
public:
    std::string nombre;
    int edad;

    void saludar() {
        std::cout << "Hola, soy " << nombre << " y tengo " << edad << " años." << std::endl;
    }
};

int main() {
    Persona p;
    std::cout << "Ingresa tu nombre: ";
    std::getline(std::cin, p.nombre);
    std::cout << "Ingresa tu edad: ";
    std::cin >> p.edad;

    p.saludar();
    return 0;
}

Pruebas
? Caso 1: "Juan", 20 ? "Hola, soy Juan y tengo 20 años."

? Caso 2: "Ana", 30 ? "Hola, soy Ana y tengo 30 años."

? Caso 3: "Luis", 0 ? "Hola, soy Luis y tengo 0 años."


Ejercicio 7
Título del Ejercicio: Clase Libro con Método Mostrar Información
Análisis del Problema
? Descripción del Problema: Crear una clase Libro con atributos titulo, autor y anio, y un método mostrar() que imprima la información del libro.

? Entradas y Salidas:

? Entrada: Título, autor y año.

? Salida: Información del libro.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear clase Libro con atributos titulo, autor, anio.

2. Implementar método mostrar() que imprima los atributos.

3. Crear objeto Libro y llamar a mostrar().

? Estructuras de Datos: Clase con string e int.

? Funciones Principales: main() y mostrar().

Código Fuente (C++)
#include <iostream>
#include <string>

class Libro {
public:
    std::string titulo;
    std::string autor;
    int anio;

    void mostrar() {
        std::cout << "Titulo: " << titulo << ", Autor: " << autor << ", Año: " << anio << std::endl;
    }
};

int main() {
    Libro l;
    std::cout << "Ingresa el titulo del libro: ";
    std::getline(std::cin, l.titulo);
    std::cout << "Ingresa el autor: ";
    std::getline(std::cin, l.autor);
    std::cout << "Ingresa el año: ";
    std::cin >> l.anio;

    l.mostrar();
    return 0;
}

Pruebas
? Caso 1: "C++ Avanzado", "Juan Pérez", 2025 ? Salida: "Titulo: C++ Avanzado, Autor: Juan Pérez, Año: 2025"

? Caso 2: "POO", "Ana López", 2020 ? "Titulo: POO, Autor: Ana López, Año: 2020"

? Caso 3: "Algoritmos", "Luis Gómez", 2019 ? "Titulo: Algoritmos, Autor: Luis Gómez, Año: 2019"


Ejercicio 8
Título del Ejercicio: Clase CuentaBancaria con Depósito y Retiro
Análisis del Problema
? Descripción del Problema: Crear clase CuentaBancaria con atributo saldo y métodos depositar(), retirar() y consultarSaldo().

? Entradas y Salidas:

? Entrada: Monto a depositar o retirar.

? Salida: Saldo actualizado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear clase CuentaBancaria con atributo saldo.

2. Implementar métodos para depositar, retirar y mostrar saldo.

3. Crear objeto CuentaBancaria y realizar operaciones.

? Estructuras de Datos: Clase con variable saldo.

? Funciones Principales: main() y métodos de la clase.

Código Fuente (C++)
#include <iostream>

class CuentaBancaria {
private:
    double saldo;

public:
    CuentaBancaria() { saldo = 0; }

    void depositar(double monto) { saldo += monto; }

    void retirar(double monto) {
        if(monto <= saldo) saldo -= monto;
        else std::cout << "Saldo insuficiente.\n";
    }

    void consultarSaldo() { std::cout << "Saldo: " << saldo << std::endl; }
};

int main() {
    CuentaBancaria c;
    c.depositar(500);
    c.retirar(200);
    c.consultarSaldo(); // Saldo esperado: 300

    c.retirar(400); // Saldo insuficiente
    c.consultarSaldo(); // Saldo esperado: 300
    return 0;
}

Pruebas
? Caso 1: Depositar 500, retirar 200 ? Saldo 300

? Caso 2: Retirar 400 ? Saldo 300 y mensaje "Saldo insuficiente"

? Caso 3: Depositar 1000, retirar 500 ? Saldo 500
Ejercicio 9
Título del Ejercicio: Calcular Potencia de un Número (Recursivo)
Análisis del Problema
? Descripción del Problema: Crear una función recursiva que calcule la potencia de un número base elevado a un exponente n. Por ejemplo, 2^3 = 8.

? Entradas y Salidas:

? Entrada: Número base y exponente n (entero no negativo).

? Salida: Resultado de base^n.

Diseño de la Solución
? Algoritmo Propuesto:

1. Pedir al usuario base y n.

2. Crear función recursiva potencia(base, n) que retorne 1 si n=0, o base * potencia(base, n-1).

3. Mostrar el resultado.

? Estructuras de Datos: Variables enteras para base, exponente y resultado.

? Funciones Principales: main() y potencia().

Código Fuente (C++)
#include <iostream>

int potencia(int base, int n) {
    if(n == 0) return 1;
    return base * potencia(base, n-1);
}

int main() {
    int base, n;
    std::cout << "Ingresa la base: ";
    std::cin >> base;
    std::cout << "Ingresa el exponente (entero no negativo): ";
    std::cin >> n;

    if(n < 0) {
        std::cout << "Error: El exponente debe ser no negativo." << std::endl;
        return 1;
    }

    std::cout << base << "^" << n << " = " << potencia(base, n) << std::endl;
    return 0;
}

Pruebas
? Caso 1: base=2, n=3 ? Salida: 8

? Caso 2: base=5, n=0 ? Salida: 1

? Caso 3: base=3, n=4 ? Salida: 81


Ejercicio 10
Título del Ejercicio: Contar Consonantes en una Cadena (Recursivo)
Análisis del Problema
? Descripción del Problema: Contar cuántas consonantes hay en una cadena usando recursión.

? Entradas y Salidas:

? Entrada: Cadena de caracteres.

? Salida: Número de consonantes.

Diseño de la Solución
? Algoritmo Propuesto:

1. Pedir cadena al usuario.

2. Crear función recursiva que revise si el carácter es consonante y sume 1.

3. Llamar recursivamente con el resto de la cadena.

4. Mostrar el total.

? Estructuras de Datos: Cadena de caracteres y contador entero.

? Funciones Principales: main() y contarConsonantes().

Código Fuente (C++)
#include <iostream>
#include <cstring>

bool esConsonante(char c) {
    c = tolower(c);
    return (c >= 'a' && c <= 'z') && !(c=='a'||c=='e'||c=='i'||c=='o'||c=='u');
}

int contarConsonantes(char* str) {
    if(*str == '\0') return 0;
    return (esConsonante(*str) ? 1 : 0) + contarConsonantes(str+1);
}

int main() {
    char cadena[100];
    std::cout << "Ingresa una cadena: ";
    std::cin.getline(cadena, 100);

    std::cout << "Numero de consonantes: " << contarConsonantes(cadena) << std::endl;
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? Salida: 5

? Caso 2: "C++ es divertido" ? Salida: 7

? Caso 3: "AEIOU" ? Salida: 0


Ejercicio 11
Título del Ejercicio: Implementar Pila con Array Dinámico
Análisis del Problema
? Descripción del Problema: Crear una pila (stack) usando un array dinámico con operaciones push, pop y mostrar.

? Entradas y Salidas:

? Entrada: Elementos a agregar o eliminar.

? Salida: Estado actual de la pila.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear array dinámico con tamaño n.

2. Mantener variable tope para el índice superior.

3. Implementar funciones push(), pop() y mostrar().

4. Mostrar resultados tras cada operación.

? Estructuras de Datos: Array dinámico y variable tope.

? Funciones Principales: main(), push(), pop(), mostrar().

Código Fuente (C++)
#include <iostream>
using namespace std;

class Pila {
    int* arr;
    int tope;
    int capacidad;
public:
    Pila(int n) {
        capacidad = n;
        arr = new int[capacidad];
        tope = -1;
    }
    void push(int valor) {
        if(tope >= capacidad-1) cout << "Pila llena\n";
        else arr[++tope] = valor;
    }
    void pop() {
        if(tope < 0) cout << "Pila vacia\n";
        else tope--;
    }
    void mostrar() {
        cout << "Pila: ";
        for(int i=0;i<=tope;i++) cout << arr[i] << " ";
        cout << endl;
    }
    ~Pila() { delete[] arr; }
};

int main() {
    Pila p(5);
    p.push(10); p.push(20); p.push(30);
    p.mostrar(); // 10 20 30
    p.pop();
    p.mostrar(); // 10 20
    return 0;
}

Pruebas
? Caso 1: push 10,20,30 ? Pila: 10 20 30

? Caso 2: pop ? Pila: 10 20

? Caso 3: push hasta 5 elementos ? Pila llena si excede capacidad


Ejercicio 12
Título del Ejercicio: Implementar Cola con Array Circular
Análisis del Problema
? Descripción del Problema: Implementar una cola (queue) usando un array circular con operaciones enqueue, dequeue y mostrar.

? Entradas y Salidas:

? Entrada: Elementos a agregar o eliminar.

? Salida: Estado actual de la cola.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear array con tamaño n y punteros frente y final.

2. Implementar enqueue() para insertar, dequeue() para eliminar y mostrar() para imprimir.

3. Verificar condiciones de cola llena y vacía.

? Estructuras de Datos: Array dinámico y dos índices.

? Funciones Principales: main(), enqueue(), dequeue(), mostrar().

Código Fuente (C++)
#include <iostream>
using namespace std;

class Cola {
    int* arr;
    int frente, final, capacidad;
public:
    Cola(int n) { arr = new int[n]; capacidad=n; frente=0; final=0; }
    bool llena() { return (final+1)%capacidad == frente; }
    bool vacia() { return frente == final; }
    void enqueue(int x) {
        if(llena()) cout << "Cola llena\n";
        else { arr[final]=x; final=(final+1)%capacidad; }
    }
    void dequeue() {
        if(vacia()) cout << "Cola vacia\n";
        else frente=(frente+1)%capacidad;
    }
    void mostrar() {
        cout << "Cola: ";
        for(int i=frente; i!=final; i=(i+1)%capacidad) cout << arr[i] << " ";
        cout << endl;
    }
    ~Cola(){ delete[] arr; }
};

int main() {
    Cola c(5);
    c.enqueue(1); c.enqueue(2); c.enqueue(3);
    c.mostrar(); // 1 2 3
    c.dequeue();
    c.mostrar(); // 2 3
    return 0;
}

Pruebas
? Caso 1: enqueue 1,2,3 ? Cola: 1 2 3

? Caso 2: dequeue ? Cola: 2 3

? Caso 3: enqueue hasta cola llena ? Mensaje "Cola llena"
Ejercicio 13
Título del Ejercicio: Lista Enlazada Simple con Inserción al Inicio y Fin
Análisis del Problema
? Descripción del Problema: Crear una lista enlazada simple que permita insertar nodos al inicio y al final, y mostrar la lista.

? Entradas y Salidas:

? Entrada: Valores enteros a insertar.

? Salida: Lista enlazada mostrada de inicio a fin.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir estructura Nodo con dato y siguiente.

2. Crear funciones insertarInicio(), insertarFin() y mostrar().

3. Insertar elementos según entrada y mostrar la lista.

? Estructuras de Datos: Lista enlazada simple.

? Funciones Principales: main(), insertarInicio(), insertarFin(), mostrar().

Código Fuente (C++)
#include <iostream>
using namespace std;

struct Nodo {
    int dato;
    Nodo* siguiente;
};

void insertarInicio(Nodo*& cabeza, int valor) {
    Nodo* nuevo = new Nodo{valor, cabeza};
    cabeza = nuevo;
}

void insertarFin(Nodo*& cabeza, int valor) {
    Nodo* nuevo = new Nodo{valor, nullptr};
    if(!cabeza) cabeza = nuevo;
    else {
        Nodo* temp = cabeza;
        while(temp->siguiente) temp = temp->siguiente;
        temp->siguiente = nuevo;
    }
}

void mostrar(Nodo* cabeza) {
    Nodo* temp = cabeza;
    cout << "Lista: ";
    while(temp) { cout << temp->dato << " "; temp = temp->siguiente; }
    cout << endl;
}

int main() {
    Nodo* lista = nullptr;
    insertarInicio(lista, 10);
    insertarFin(lista, 20);
    insertarInicio(lista, 5);
    mostrar(lista); // 5 10 20
    return 0;
}

Pruebas
? Caso 1: Insertar inicio 10, fin 20, inicio 5 ? Lista: 5 10 20

? Caso 2: Insertar fin 30 ? Lista: 5 10 20 30

? Caso 3: Lista vacía ? Mostrar ? Lista:


Ejercicio 14
Título del Ejercicio: Eliminar Nodo de Lista Enlazada por Valor
Análisis del Problema
? Descripción del Problema: Crear función que elimine un nodo específico en una lista enlazada simple según su valor.

? Entradas y Salidas:

? Entrada: Valor a eliminar.

? Salida: Lista actualizada.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer la lista hasta encontrar el nodo con valor buscado.

2. Modificar punteros para saltar el nodo y eliminarlo.

3. Mostrar la lista resultante.

? Estructuras de Datos: Lista enlazada simple.

? Funciones Principales: main() y eliminarNodo().

Código Fuente (C++)
#include <iostream>
using namespace std;

struct Nodo {
    int dato;
    Nodo* siguiente;
};

void eliminarNodo(Nodo*& cabeza, int valor) {
    if(!cabeza) return;
    if(cabeza->dato == valor) {
        Nodo* temp = cabeza;
        cabeza = cabeza->siguiente;
        delete temp;
        return;
    }
    Nodo* temp = cabeza;
    while(temp->siguiente && temp->siguiente->dato != valor) temp = temp->siguiente;
    if(temp->siguiente) {
        Nodo* aEliminar = temp->siguiente;
        temp->siguiente = temp->siguiente->siguiente;
        delete aEliminar;
    }
}

void mostrar(Nodo* cabeza) {
    Nodo* temp = cabeza;
    cout << "Lista: ";
    while(temp) { cout << temp->dato << " "; temp = temp->siguiente; }
    cout << endl;
}

int main() {
    Nodo* lista = nullptr;
    lista = new Nodo{10, nullptr};
    lista->siguiente = new Nodo{20, nullptr};
    lista->siguiente->siguiente = new Nodo{30, nullptr};

    eliminarNodo(lista, 20);
    mostrar(lista); // 10 30

    eliminarNodo(lista, 10);
    mostrar(lista); // 30
    return 0;
}

Pruebas
? Caso 1: Eliminar 20 ? Lista: 10 30

? Caso 2: Eliminar 10 ? Lista: 30

? Caso 3: Eliminar 40 (no existe) ? Lista: 30


Ejercicio 15
Título del Ejercicio: Buscar Elemento en Lista Enlazada Recursivamente
Análisis del Problema
? Descripción del Problema: Crear función recursiva que busque un valor en una lista enlazada y devuelva verdadero o falso.

? Entradas y Salidas:

? Entrada: Valor a buscar.

? Salida: true si se encuentra, false si no.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si nodo actual es nullptr ? retornar false.

2. Si nodo actual contiene valor ? retornar true.

3. Llamar recursivamente con siguiente nodo.

? Estructuras de Datos: Lista enlazada simple.

? Funciones Principales: main() y buscarRecursivo().

Código Fuente (C++)
#include <iostream>
using namespace std;

struct Nodo {
    int dato;
    Nodo* siguiente;
};

bool buscarRecursivo(Nodo* cabeza, int valor) {
    if(!cabeza) return false;
    if(cabeza->dato == valor) return true;
    return buscarRecursivo(cabeza->siguiente, valor);
}

int main() {
    Nodo* lista = new Nodo{10, new Nodo{20, new Nodo{30, nullptr}}};

    cout << boolalpha;
    cout << "Buscar 20: " << buscarRecursivo(lista, 20) << endl; // true
    cout << "Buscar 40: " << buscarRecursivo(lista, 40) << endl; // false

    return 0;
}

Pruebas
? Caso 1: Buscar 20 ? true

? Caso 2: Buscar 10 ? true

? Caso 3: Buscar 50 ? false


Ejercicio 16
Título del Ejercicio: Pila de Estructuras Empleado
Análisis del Problema
? Descripción del Problema: Crear pila que almacene estructuras Empleado con nombre y edad. Permitir push, pop y mostrar datos.

? Entradas y Salidas:

? Entrada: Datos del empleado.

? Salida: Mostrar pila de empleados.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir struct Empleado.

2. Implementar pila con array y puntero tope.

3. Funciones para agregar, eliminar y mostrar.

? Estructuras de Datos: Array de estructuras.

? Funciones Principales: main(), push(), pop(), mostrar().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

struct Empleado {
    string nombre;
    int edad;
};

class PilaEmpleado {
    Empleado* arr;
    int tope, capacidad;
public:
    PilaEmpleado(int n) { arr = new Empleado[n]; capacidad=n; tope=-1; }
    void push(Empleado e) {
        if(tope>=capacidad-1) cout << "Pila llena\n";
        else arr[++tope] = e;
    }
    void pop() {
        if(tope<0) cout << "Pila vacia\n";
        else tope--;
    }
    void mostrar() {
        cout << "Pila de empleados:\n";
        for(int i=0;i<=tope;i++) cout << arr[i].nombre << ", " << arr[i].edad << endl;
    }
    ~PilaEmpleado() { delete[] arr; }
};

int main() {
    PilaEmpleado p(3);
    p.push({"Juan", 25});
    p.push({"Ana", 30});
    p.mostrar();
    p.pop();
    p.mostrar();
    return 0;
}

Pruebas
? Caso 1: Push Juan y Ana ? Mostrar ? Lista de empleados

? Caso 2: Pop ? Mostrar ? Solo Juan

? Caso 3: Push hasta capacidad ? Mensaje "Pila llena"


Ejercicio 17
Título del Ejercicio: Cola de Prioridad Simple con Array
Análisis del Problema
? Descripción del Problema: Implementar cola de prioridad donde el menor valor tiene más prioridad.

? Entradas y Salidas:

? Entrada: Números a agregar.

? Salida: Mostrar cola ordenada por prioridad.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar array dinámico.

2. Insertar elementos en posición que mantenga orden creciente.

3. Eliminar elementos desde el frente.

4. Mostrar estado de la cola.

? Estructuras de Datos: Array dinámico.

? Funciones Principales: main(), insertar(), eliminar(), mostrar().

Código Fuente (C++)
#include <iostream>
using namespace std;

class ColaPrioridad {
    int* arr;
    int n;
public:
    ColaPrioridad(int size) { arr = new int[size]; n=0; }
    void insertar(int x) {
        int i=n-1;
        while(i>=0 && arr[i]>x) { arr[i+1]=arr[i]; i--; }
        arr[i+1]=x;
        n++;
    }
    void eliminar() { if(n>0) n--; }
    void mostrar() { for(int i=0;i<n;i++) cout << arr[i] << " "; cout << endl; }
    ~ColaPrioridad() { delete[] arr; }
};

int main() {
    ColaPrioridad c(5);
    c.insertar(30); c.insertar(10); c.insertar(20);
    c.mostrar(); // 10 20 30
    c.eliminar();
    c.mostrar(); // 10 20
    return 0;
}

Pruebas
? Caso 1: Insertar 30,10,20 ? 10 20 30

? Caso 2: Eliminar ? 10 20

? Caso 3: Insertar 5 ? 5 10 20


Ejercicio 18
Título del Ejercicio: Invertir Cola usando Pila Auxiliar
Análisis del Problema
? Descripción del Problema: Invertir el orden de los elementos de una cola usando una pila auxiliar.

? Entradas y Salidas:

? Entrada: Números en la cola.

? Salida: Cola invertida.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear array para cola y stack para pila auxiliar.

2. Extraer elementos de la cola y push en pila.

3. Extraer de pila y push en cola.

4. Mostrar cola invertida.

? Estructuras de Datos: Array y stack.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <stack>
using namespace std;

int main() {
    int cola[5] = {1,2,3,4,5};
    int n=5;
    stack<int> pila;

    for(int i=0;i<n;i++) pila.push(cola[i]);
    for(int i=0;i<n;i++) { cola[i]=pila.top(); pila.pop(); }

    cout << "Cola invertida: ";
    for(int i=0;i<n;i++) cout << cola[i] << " ";
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: Cola [1,2,3,4,5] ? [5,4,3,2,1]

? Caso 2: Cola [10,20] ? [20,10]

? Caso 3: Cola vacía ? Salida vacía

Ejercicio 19
Título del Ejercicio: Buscar el Máximo en un Array Recursivamente
Análisis del Problema
? Descripción del Problema: Crear una función recursiva que encuentre el valor máximo en un array de enteros.

? Entradas y Salidas:

? Entrada: Array de enteros y su tamaño n.

? Salida: Valor máximo del array.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir función maxRec(arr, n) que retorne arr[0] si n==1.

2. Comparar último elemento con máximo de los anteriores recursivamente.

3. Retornar el máximo.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main() y maxRec().

Código Fuente (C++)
#include <iostream>
using namespace std;

int maxRec(int arr[], int n) {
    if(n == 1) return arr[0];
    int maxRest = maxRec(arr, n-1);
    return (arr[n-1] > maxRest) ? arr[n-1] : maxRest;
}

int main() {
    int arr[] = {5, 10, 3, 8, 20};
    int n = 5;
    cout << "Maximo del array: " << maxRec(arr, n) << endl; // 20
    return 0;
}

Pruebas
? Caso 1: [5,10,3,8,20] ? 20

? Caso 2: [1,2,3,4,5] ? 5

? Caso 3: [10,10,10] ? 10


Ejercicio 20
Título del Ejercicio: Suma de Elementos de Lista Enlazada Recursivamente
Análisis del Problema
? Descripción del Problema: Calcular la suma de los elementos de una lista enlazada usando recursión.

? Entradas y Salidas:

? Entrada: Lista enlazada de enteros.

? Salida: Suma de sus elementos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si nodo es nullptr ? retornar 0.

2. Retornar dato + sumaRec(siguiente).

? Estructuras de Datos: Lista enlazada simple.

? Funciones Principales: main() y sumaRec().

Código Fuente (C++)
#include <iostream>
using namespace std;

struct Nodo { int dato; Nodo* siguiente; };

int sumaRec(Nodo* cabeza) {
    if(!cabeza) return 0;
    return cabeza->dato + sumaRec(cabeza->siguiente);
}

int main() {
    Nodo* lista = new Nodo{5, new Nodo{10, new Nodo{3, nullptr}}};
    cout << "Suma de elementos: " << sumaRec(lista) << endl; // 18
    return 0;
}

Pruebas
? Caso 1: [5,10,3] ? 18

? Caso 2: [1,2,3,4] ? 10

? Caso 3: lista vacía ? 0


Ejercicio 21
Título del Ejercicio: Buscar Elemento en Array Ordenado (Búsqueda Binaria Recursiva)
Análisis del Problema
? Descripción del Problema: Implementar búsqueda binaria recursiva en un array ordenado.

? Entradas y Salidas:

? Entrada: Array ordenado y valor a buscar.

? Salida: Posición del elemento o -1 si no existe.

Diseño de la Solución
? Algoritmo Propuesto:

1. Determinar elemento medio.

2. Si coincide, retornar índice.

3. Si menor ? buscar mitad izquierda; si mayor ? mitad derecha.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main() y busquedaBinRec().

Código Fuente (C++)
#include <iostream>
using namespace std;

int busquedaBinRec(int arr[], int izquierda, int derecha, int x) {
    if(izquierda > derecha) return -1;
    int medio = izquierda + (derecha - izquierda)/2;
    if(arr[medio] == x) return medio;
    if(arr[medio] > x) return busquedaBinRec(arr, izquierda, medio-1, x);
    return busquedaBinRec(arr, medio+1, derecha, x);
}

int main() {
    int arr[] = {1,3,5,7,9};
    int n = 5, x=7;
    int pos = busquedaBinRec(arr,0,n-1,x);
    cout << "Posicion de " << x << ": " << pos << endl; // 3
    return 0;
}

Pruebas
? Caso 1: Buscar 7 ? 3

? Caso 2: Buscar 1 ? 0

? Caso 3: Buscar 10 ? -1


Ejercicio 22
Título del Ejercicio: Clase Rectángulo con Área y Perímetro
Análisis del Problema
? Descripción del Problema: Crear clase Rectangulo con atributos base y altura y métodos para calcular área y perímetro.

? Entradas y Salidas:

? Entrada: Base y altura.

? Salida: Área y perímetro.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear clase Rectangulo.

2. Implementar métodos area() y perimetro().

3. Crear objeto e imprimir resultados.

? Estructuras de Datos: Clase con variables base y altura.

? Funciones Principales: main(), area(), perimetro().

Código Fuente (C++)
#include <iostream>
using namespace std;

class Rectangulo {
public:
    double base, altura;
    double area() { return base*altura; }
    double perimetro() { return 2*(base+altura); }
};

int main() {
    Rectangulo r;
    r.base=5; r.altura=3;
    cout << "Area: " << r.area() << ", Perimetro: " << r.perimetro() << endl;
    return 0;
}

Pruebas
? Caso 1: base=5, altura=3 ? Área=15, Perímetro=16

? Caso 2: base=10, altura=10 ? Área=100, Perímetro=40

? Caso 3: base=0, altura=5 ? Área=0, Perímetro=10


Ejercicio 23
Título del Ejercicio: Matriz Transpuesta
Análisis del Problema
? Descripción del Problema: Crear un programa que calcule la transpuesta de una matriz de enteros.

? Entradas y Salidas:

? Entrada: Matriz de tamaño m x n.

? Salida: Matriz transpuesta n x m.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer la matriz original.

2. Asignar transpuesta[j][i] = original[i][j].

3. Mostrar matriz transpuesta.

? Estructuras de Datos: Array bidimensional.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[2][3] = {{1,2,3},{4,5,6}};
    int trans[3][2];

    for(int i=0;i<2;i++)
        for(int j=0;j<3;j++)
            trans[j][i] = mat[i][j];

    cout << "Matriz transpuesta:\n";
    for(int i=0;i<3;i++) {
        for(int j=0;j<2;j++)
            cout << trans[i][j] << " ";
        cout << endl;
    }
    return 0;
}

Pruebas
? Caso 1: [[1,2,3],[4,5,6]] ? [[1,4],[2,5],[3,6]]

? Caso 2: [[1]] ? [[1]]

? Caso 3: [[1,2],[3,4]] ? [[1,3],[2,4]]


Ejercicio 24
Título del Ejercicio: Suma de Diagonal de Matriz Cuadrada
Análisis del Problema
? Descripción del Problema: Calcular la suma de los elementos de la diagonal principal de una matriz cuadrada.

? Entradas y Salidas:

? Entrada: Matriz n x n.

? Salida: Suma de la diagonal principal.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer la matriz.

2. Sumar los elementos donde fila == columna.

3. Mostrar resultado.

? Estructuras de Datos: Array bidimensional.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[3][3] = {{1,2,3},{4,5,6},{7,8,9}};
    int suma=0;

    for(int i=0;i<3;i++) suma += mat[i][i];

    cout << "Suma diagonal: " << suma << endl; // 1+5+9=15
    return 0;
}

Pruebas
? Caso 1: [[1,2,3],[4,5,6],[7,8,9]] ? 15

? Caso 2: [[5]] ? 5

? Caso 3: [[1,0],[0,1]] ? 2

Ejercicio 25
Título del Ejercicio: Contar Elementos Mayores que un Valor en Array
Análisis del Problema
? Descripción del Problema: Contar cuántos elementos de un array son mayores que un valor dado.

? Entradas y Salidas:

? Entrada: Array de enteros y valor x.

? Salida: Número de elementos mayores que x.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador en 0.

2. Recorrer array, incrementar contador si elemento > x.

3. Mostrar contador.

? Estructuras de Datos: Array de enteros y variable contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[] = {5,10,3,8,20};
    int n=5, x=7, contador=0;

    for(int i=0;i<n;i++) if(arr[i]>x) contador++;

    cout << "Elementos mayores que " << x << ": " << contador << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [5,10,3,8,20], x=7 ? 3

? Caso 2: [1,2,3], x=0 ? 3

? Caso 3: [1,2,3], x=5 ? 0


Ejercicio 26
Título del Ejercicio: Promedio de Array
Análisis del Problema
? Descripción del Problema: Calcular el promedio de los elementos de un array.

? Entradas y Salidas:

? Entrada: Array de enteros y su tamaño.

? Salida: Promedio de los elementos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Sumar todos los elementos del array.

2. Dividir entre cantidad de elementos.

3. Mostrar promedio.

? Estructuras de Datos: Array y variable suma.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[] = {5,10,15,20};
    int n=4;
    double suma=0;

    for(int i=0;i<n;i++) suma += arr[i];

    cout << "Promedio: " << suma/n << endl; // 12.5
    return 0;
}

Pruebas
? Caso 1: [5,10,15,20] ? 12.5

? Caso 2: [1,2,3] ? 2

? Caso 3: [10,10,10] ? 10


Ejercicio 27
Título del Ejercicio: Invertir Array
Análisis del Problema
? Descripción del Problema: Invertir los elementos de un array.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Array invertido.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar dos punteros: inicio y fin.

2. Intercambiar elementos hasta que inicio ? fin.

3. Mostrar array invertido.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[] = {1,2,3,4,5};
    int n=5;

    for(int i=0,j=n-1;i<j;i++,j--) {
        int temp = arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }

    cout << "Array invertido: ";
    for(int i=0;i<n;i++) cout << arr[i] << " ";
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5] ? [5,4,3,2,1]

? Caso 2: [10,20,30] ? [30,20,10]

? Caso 3: [1] ? [1]


Ejercicio 28
Título del Ejercicio: Clase CuentaBancaria con Depósito y Retiro
Análisis del Problema
? Descripción del Problema: Crear clase CuentaBancaria con saldo, y métodos para depositar, retirar y consultar saldo.

? Entradas y Salidas:

? Entrada: Monto a depositar o retirar.

? Salida: Saldo actualizado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir clase con atributo saldo.

2. Métodos: depositar(monto), retirar(monto) y consultar().

3. Crear objeto y probar operaciones.

? Estructuras de Datos: Clase con variable saldo.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

class CuentaBancaria {
    double saldo;
public:
    CuentaBancaria(double s=0) { saldo=s; }
    void depositar(double monto) { saldo+=monto; }
    void retirar(double monto) {
        if(monto>saldo) cout << "Saldo insuficiente\n";
        else saldo-=monto;
    }
    void consultar() { cout << "Saldo actual: " << saldo << endl; }
};

int main() {
    CuentaBancaria c(100);
    c.consultar(); // 100
    c.depositar(50);
    c.consultar(); // 150
    c.retirar(70);
    c.consultar(); // 80
    c.retirar(100); // Saldo insuficiente
    return 0;
}

Pruebas
? Caso 1: Depositar 50 ? Saldo actualizado 150

? Caso 2: Retirar 70 ? Saldo actualizado 80

? Caso 3: Retirar 100 ? Mensaje "Saldo insuficiente"

Ejercicio 29
Título del Ejercicio: Contar Números Pares en un Array
Análisis del Problema
? Descripción del Problema: Contar cuántos números pares hay en un array de enteros.

? Entradas y Salidas:

? Entrada: Array de enteros y su tamaño.

? Salida: Cantidad de números pares.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador en 0.

2. Recorrer array, si elemento %2==0 incrementar contador.

3. Mostrar resultado.

? Estructuras de Datos: Array y variable contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[] = {1,2,3,4,5,6};
    int n=6, contador=0;

    for(int i=0;i<n;i++)
        if(arr[i]%2==0) contador++;

    cout << "Numeros pares: " << contador << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5,6] ? 3

? Caso 2: [2,4,6,8] ? 4

? Caso 3: [1,3,5] ? 0


Ejercicio 30
Título del Ejercicio: Contar Números Impares en un Array
Análisis del Problema
? Descripción del Problema: Contar cuántos números impares hay en un array de enteros.

? Entradas y Salidas:

? Entrada: Array de enteros y su tamaño.

? Salida: Cantidad de números impares.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador en 0.

2. Recorrer array, si elemento %2!=0 incrementar contador.

3. Mostrar resultado.

? Estructuras de Datos: Array y variable contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[] = {1,2,3,4,5,6};
    int n=6, contador=0;

    for(int i=0;i<n;i++)
        if(arr[i]%2!=0) contador++;

    cout << "Numeros impares: " << contador << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5,6] ? 3

? Caso 2: [2,4,6,8] ? 0

? Caso 3: [1,3,5] ? 3


Ejercicio 31
Título del Ejercicio: Buscar Mínimo en un Array
Análisis del Problema
? Descripción del Problema: Encontrar el valor mínimo de un array de enteros.

? Entradas y Salidas:

? Entrada: Array y su tamaño.

? Salida: Valor mínimo.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar mínimo con primer elemento.

2. Recorrer array comparando y actualizando mínimo.

3. Mostrar resultado.

? Estructuras de Datos: Array y variable mínimo.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[] = {5,10,3,8,20};
    int n=5;
    int minimo=arr[0];

    for(int i=1;i<n;i++)
        if(arr[i]<minimo) minimo=arr[i];

    cout << "Minimo: " << minimo << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [5,10,3,8,20] ? 3

? Caso 2: [1,2,3] ? 1

? Caso 3: [10,10,10] ? 10


Ejercicio 32
Título del Ejercicio: Contar Vocales en una Cadena
Análisis del Problema
? Descripción del Problema: Contar el número de vocales en una cadena de caracteres.

? Entradas y Salidas:

? Entrada: Cadena de caracteres.

? Salida: Número de vocales.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer la cadena.

2. Incrementar contador si el carácter es vocal (a,e,i,o,u).

3. Mostrar resultado.

? Estructuras de Datos: Cadena y contador entero.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

int main() {
    string cadena = "Hola Mundo";
    int contador=0;

    for(char c : cadena) {
        c = tolower(c);
        if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u') contador++;
    }

    cout << "Numero de vocales: " << contador << endl; // 4
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? 4

? Caso 2: "C++ es divertido" ? 6

? Caso 3: "XYZ" ? 0


Ejercicio 33
Título del Ejercicio: Clase Libro con Mostrar Información
Análisis del Problema
? Descripción del Problema: Crear clase Libro con atributos titulo, autor y anio, y método para mostrar información.

? Entradas y Salidas:

? Entrada: Datos del libro.

? Salida: Información del libro por pantalla.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear clase Libro.

2. Implementar método mostrar().

3. Crear objeto e invocar mostrar().

? Estructuras de Datos: Clase con variables de tipo string y int.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class Libro {
public:
    string titulo, autor;
    int anio;
    void mostrar() {
        cout << "Titulo: " << titulo << ", Autor: " << autor << ", Anio: " << anio << endl;
    }
};

int main() {
    Libro l;
    l.titulo="C++ para Todos";
    l.autor="Juan Perez";
    l.anio=2023;
    l.mostrar();
    return 0;
}

Pruebas
? Caso 1: "C++ para Todos", Juan Perez, 2023 ? Mostrar datos correctos

? Caso 2: "Libro A", Autor B, 2000 ? Mostrar datos correctos

? Caso 3: "Libro Vacío" ? Mostrar datos asignados


Ejercicio 34
Título del Ejercicio: Sumar Dos Arrays Elemento a Elemento
Análisis del Problema
? Descripción del Problema: Crear un array resultado donde cada elemento sea la suma de los elementos correspondientes de dos arrays.

? Entradas y Salidas:

? Entrada: Dos arrays del mismo tamaño.

? Salida: Array con la suma.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer arrays con un bucle.

2. Sumar elementos y almacenar en nuevo array.

3. Mostrar resultado.

? Estructuras de Datos: Tres arrays de enteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int a[] = {1,2,3};
    int b[] = {4,5,6};
    int n=3, c[3];

    for(int i=0;i<n;i++) c[i] = a[i] + b[i];

    cout << "Array suma: ";
    for(int i=0;i<n;i++) cout << c[i] << " ";
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [1,2,3] + [4,5,6] ? [5,7,9]

? Caso 2: [0,0,0] + [1,2,3] ? [1,2,3]

? Caso 3: [10,20] + [5,5] ? [15,25]


Ejercicio 35
Título del Ejercicio: Clase Persona con Saludar
Análisis del Problema
? Descripción del Problema: Crear clase Persona con atributos nombre y edad y método saludar().

? Entradas y Salidas:

? Entrada: Nombre y edad.

? Salida: Mensaje de saludo por pantalla.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear clase Persona.

2. Implementar método saludar().

3. Crear objeto e invocar método.

? Estructuras de Datos: Clase con variables string y int.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;
    void saludar() {
        cout << "Hola, soy " << nombre << " y tengo " << edad << " anos." << endl;
    }
};

int main() {
    Persona p;
    p.nombre="Juan";
    p.edad=25;
    p.saludar();
    return 0;
}

Pruebas
? Caso 1: "Juan", 25 ? Saludar correctamente

? Caso 2: "Ana", 30 ? Saludar correctamente

? Caso 3: "Pedro", 0 ? Saludar correctamente


Ejercicio 36
Título del Ejercicio: Multiplicar Dos Matrices
Análisis del Problema
? Descripción del Problema: Multiplicar dos matrices compatibles y mostrar el resultado.

? Entradas y Salidas:

? Entrada: Dos matrices m x n y n x p.

? Salida: Matriz resultante m x p.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar matriz resultado en 0.

2. Multiplicar filas de A por columnas de B.

3. Mostrar resultado.

? Estructuras de Datos: Arrays bidimensionales.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int A[2][3]={{1,2,3},{4,5,6}};
    int B[3][2]={{7,8},{9,10},{11,12}};
    int C[2][2]={0};

    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            for(int k=0;k<3;k++)
                C[i][j]+=A[i][k]*B[k][j];

    cout << "Matriz resultante:\n";
    for(int i=0;i<2;i++){
        for(int j=0;j<2;j++) cout << C[i
EjEjercicio 39
Título del Ejercicio: Sumar los Elementos de una Pila
Análisis del Problema
? Descripción del Problema: Crear una pila (stack) y calcular la suma de todos sus elementos.

? Entradas y Salidas:

? Entrada: Elementos a insertar en la pila.

? Salida: Suma de todos los elementos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Insertar elementos en la pila.

2. Mientras la pila no esté vacía, sacar el elemento y sumarlo.

3. Mostrar resultado.

? Estructuras de Datos: Pila (stack).

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> pila;
    pila.push(5);
    pila.push(10);
    pila.push(3);
    
    int suma = 0;
    while(!pila.empty()) {
        suma += pila.top();
        pila.pop();
    }
    
    cout << "Suma de elementos de la pila: " << suma << endl; // 18
    return 0;
}

Pruebas
? Caso 1: [5,10,3] ? 18

? Caso 2: [1,2,3,4] ? 10

? Caso 3: Pila vacía ? 0


Ejercicio 40
Título del Ejercicio: Contar Elementos de una Cola
Análisis del Problema
? Descripción del Problema: Crear una cola y contar la cantidad de elementos que contiene.

? Entradas y Salidas:

? Entrada: Elementos a insertar en la cola.

? Salida: Cantidad de elementos en la cola.

Diseño de la Solución
? Algoritmo Propuesto:

1. Insertar elementos en la cola.

2. Usar un contador para cada elemento.

3. Mostrar resultado.

? Estructuras de Datos: Cola (queue).

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> cola;
    cola.push(1);
    cola.push(2);
    cola.push(3);

    int contador = 0;
    queue<int> temp = cola;
    while(!temp.empty()) {
        contador++;
        temp.pop();
    }

    cout << "Cantidad de elementos en la cola: " << contador << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3] ? 3

? Caso 2: [5,6,7,8] ? 4

? Caso 3: Cola vacía ? 0


Ejercicio 41
Título del Ejercicio: Buscar Elemento en Lista Enlazada
Análisis del Problema
? Descripción del Problema: Crear una lista enlazada y buscar un elemento dado.

? Entradas y Salidas:

? Entrada: Lista de enteros y valor a buscar.

? Salida: Posición del elemento o -1 si no se encuentra.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer la lista desde la cabeza.

2. Comparar cada nodo con el valor buscado.

3. Retornar posición si se encuentra o -1 si no.

? Estructuras de Datos: Lista enlazada simple.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

struct Nodo { int dato; Nodo* siguiente; };

int buscar(Nodo* cabeza, int valor) {
    int pos=0;
    while(cabeza != nullptr) {
        if(cabeza->dato == valor) return pos;
        cabeza = cabeza->siguiente;
        pos++;
    }
    return -1;
}

int main() {
    Nodo* lista = new Nodo{5, new Nodo{10, new Nodo{3, nullptr}}};
    cout << "Posicion del 10: " << buscar(lista,10) << endl; // 1
    cout << "Posicion del 7: " << buscar(lista,7) << endl;   // -1
    return 0;
}

Pruebas
? Caso 1: [5,10,3], buscar 10 ? 1

? Caso 2: [5,10,3], buscar 7 ? -1

? Caso 3: [1], buscar 1 ? 0


Ejercicio 42
Título del Ejercicio: Contar Palabras en una Cadena
Análisis del Problema
? Descripción del Problema: Contar cuántas palabras hay en una cadena separadas por espacios.

? Entradas y Salidas:

? Entrada: Cadena de texto.

? Salida: Número de palabras.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer la cadena caracter por caracter.

2. Incrementar contador cuando se encuentre un espacio seguido de letra.

3. Retornar contador +1 al final.

? Estructuras de Datos: Cadena de caracteres y contador entero.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

int main() {
    string texto = "Hola mundo desde C++";
    stringstream ss(texto);
    string palabra;
    int contador=0;

    while(ss >> palabra) contador++;

    cout << "Numero de palabras: " << contador << endl; // 4
    return 0;
}

Pruebas
? Caso 1: "Hola mundo desde C++" ? 4

? Caso 2: "Una palabra" ? 2

? Caso 3: "" ? 0


Ejercicio 43
Título del Ejercicio: Invertir Cadena
Análisis del Problema
? Descripción del Problema: Invertir el contenido de una cadena de caracteres.

? Entradas y Salidas:

? Entrada: Cadena de texto.

? Salida: Cadena invertida.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar un bucle desde el final hacia el inicio.

2. Construir cadena invertida.

3. Mostrar resultado.

? Estructuras de Datos: Cadena de caracteres.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

int main() {
    string texto = "Hola Mundo";
    string invertido="";

    for(int i=texto.length()-1;i>=0;i--) invertido += texto[i];

    cout << "Cadena invertida: " << invertido << endl; // "odnuM aloH"
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? "odnuM aloH"

? Caso 2: "ABC" ? "CBA"

? Caso 3: "" ? ""


Ejercicio 44
Título del Ejercicio: Eliminar Elemento de Lista Enlazada
Análisis del Problema
? Descripción del Problema: Eliminar un nodo con un valor dado en una lista enlazada simple.

? Entradas y Salidas:

? Entrada: Lista enlazada y valor a eliminar.

? Salida: Lista actualizada.

Diseño de la Solución
? Algoritmo Propuesto:

1. Revisar si el nodo cabeza contiene el valor.

2. Recorrer lista y actualizar enlaces para eliminar nodo.

3. Mostrar lista resultante.

? Estructuras de Datos: Lista enlazada.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

struct Nodo { int dato; Nodo* siguiente; };

Nodo* eliminar(Nodo* cabeza, int valor) {
    if(!cabeza) return nullptr;
    if(cabeza->dato == valor) {
        Nodo* temp = cabeza->siguiente;
        delete cabeza;
        return temp;
    }
    Nodo* actual = cabeza;
    while(actual->siguiente && actual->siguiente->dato != valor) actual = actual->siguiente;
    if(actual->siguiente) {
        Nodo* temp = actual->siguiente;
        actual->siguiente = temp->siguiente;
        delete temp;
    }
    return cabeza;
}

void mostrar(Nodo* cabeza) {
    while(cabeza) {
        cout << cabeza->dato << " ";
        cabeza = cabeza->siguiente;
    }
    cout << endl;
}

int main() {
    Nodo* lista = new Nodo{1,new Nodo{2,new Nodo{3,nullptr}}};
    lista = eliminar(lista,2);
    mostrar(lista); // 1 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3], eliminar 2 ? [1,3]

? Caso 2: [1,2,3], eliminar 4 ? [1,2,3]

? Caso 3: [1], eliminar 1 ? []
ercicio 36 (continuación)
Código Fuente (C++)
       for(int j=0;j<2;j++) cout << C[i][j] << " ";
        cout << endl;
    }
    return 0;
}

Pruebas
? Caso 1:
 A = [[1,2,3],[4,5,6]], B = [[7,8],[9,10],[11,12]] ? C = [[58,64],[139,154]]

? Caso 2:
 A = [[1]], B = [[2]] ? C = [[2]]

? Caso 3:
 A = [[1,0],[0,1]], B = [[5,6],[7,8]] ? C = [[5,6],[7,8]]


Ejercicio 37
Título del Ejercicio: Factorial de un Número (Recursivo)
Análisis del Problema
? Descripción del Problema: Calcular el factorial de un número entero usando recursión.

? Entradas y Salidas:

? Entrada: Número entero positivo n.

? Salida: Factorial de n.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si n == 0 o n == 1 ? retornar 1.

2. Retornar n * factorial(n-1).

? Estructuras de Datos: Variable entera.

? Funciones Principales: main() y factorial().

Código Fuente (C++)
#include <iostream>
using namespace std;

int factorial(int n) {
    if(n<=1) return 1;
    return n * factorial(n-1);
}

int main() {
    int n=5;
    cout << "Factorial de " << n << " es " << factorial(n) << endl; // 120
    return 0;
}

Pruebas
? Caso 1: n=5 ? 120

? Caso 2: n=0 ? 1

? Caso 3: n=1 ? 1


Ejercicio 38
Título del Ejercicio: Potencia de un Número (Recursivo)
Análisis del Problema
? Descripción del Problema: Calcular la potencia base^exponente usando recursión.

? Entradas y Salidas:

? Entrada: Enteros base y exponente (?0).

? Salida: Resultado de base^exponente.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si exponente == 0 ? retornar 1.

2. Retornar base * potencia(base, exponente-1).

? Estructuras de Datos: Variables enteras.

? Funciones Principales: main() y potencia().

Código Fuente (C++)
#include <iostream>
using namespace std;

int potencia(int base, int exp) {
    if(exp==0) return 1;
    return base * potencia(base, exp-1);
}

int main() {
    int base=2, exp=5;
    cout << base << "^" << exp << " = " << potencia(base, exp) << endl; // 32
    return 0;
}

Pruebas
? Caso 1: base=2, exp=5 ? 32

? Caso 2: base=3, exp=0 ? 1

? Caso 3: base=5, exp=3 ? 125

Ejercicio 45
Título del Ejercicio: Ordenar un Array Ascendentemente
Análisis del Problema
? Descripción del Problema: Ordenar los elementos de un array de enteros de menor a mayor usando el algoritmo de burbuja.

? Entradas y Salidas:

? Entrada: Array de enteros y su tamaño.

? Salida: Array ordenado ascendentemente.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer el array con bucles anidados.

2. Comparar elementos adyacentes y permutarlos si es necesario.

3. Mostrar el array ordenado.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[] = {5,2,9,1,5};
    int n = 5;

    for(int i=0;i<n-1;i++)
        for(int j=0;j<n-i-1;j++)
            if(arr[j]>arr[j+1])
                swap(arr[j], arr[j+1]);

    cout << "Array ordenado: ";
    for(int i=0;i<n;i++) cout << arr[i] << " ";
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [5,2,9,1,5] ? [1,2,5,5,9]

? Caso 2: [3,1] ? [1,3]

? Caso 3: [1,2,3] ? [1,2,3]


Ejercicio 46
Título del Ejercicio: Eliminar Duplicados en un Array
Análisis del Problema
? Descripción del Problema: Crear un nuevo array que contenga los elementos únicos de un array dado.

? Entradas y Salidas:

? Entrada: Array de enteros y su tamaño.

? Salida: Array sin duplicados.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer array original.

2. Verificar si el elemento ya está en el nuevo array.

3. Agregar solo si no está presente.

? Estructuras de Datos: Dos arrays y un contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[] = {1,2,2,3,3,3,4};
    int n=7, unicos[7], k=0;

    for(int i=0;i<n;i++){
        bool encontrado=false;
        for(int j=0;j<k;j++)
            if(unicos[j]==arr[i]) encontrado=true;
        if(!encontrado) unicos[k++]=arr[i];
    }

    cout << "Array sin duplicados: ";
    for(int i=0;i<k;i++) cout << unicos[i] << " ";
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [1,2,2,3,3,3,4] ? [1,2,3,4]

? Caso 2: [1,1,1] ? [1]

? Caso 3: [1,2,3] ? [1,2,3]


Ejercicio 47
Título del Ejercicio: Suma de Matriz
Análisis del Problema
? Descripción del Problema: Sumar todos los elementos de una matriz.

? Entradas y Salidas:

? Entrada: Matriz m x n.

? Salida: Suma de todos los elementos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer la matriz con bucles anidados.

2. Acumular todos los elementos en una variable suma.

3. Mostrar resultado.

? Estructuras de Datos: Matriz bidimensional y variable suma.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[2][3]={{1,2,3},{4,5,6}};
    int suma=0;

    for(int i=0;i<2;i++)
        for(int j=0;j<3;j++)
            suma += mat[i][j];

    cout << "Suma de elementos de la matriz: " << suma << endl; // 21
    return 0;
}

Pruebas
? Caso 1: [[1,2,3],[4,5,6]] ? 21

? Caso 2: [[0]] ? 0

? Caso 3: [[1,1],[1,1]] ? 4


Ejercicio 48
Título del Ejercicio: Buscar Elemento en Matriz
Análisis del Problema
? Descripción del Problema: Buscar un número en una matriz y devolver su posición (fila,columna).

? Entradas y Salidas:

? Entrada: Matriz y número a buscar.

? Salida: Posición o mensaje si no se encuentra.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer matriz con bucles anidados.

2. Comparar cada elemento con el valor buscado.

3. Mostrar fila y columna si se encuentra.

? Estructuras de Datos: Matriz bidimensional.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[2][3]={{1,2,3},{4,5,6}};
    int buscar=5;
    bool encontrado=false;

    for(int i=0;i<2;i++){
        for(int j=0;j<3;j++){
            if(mat[i][j]==buscar){
                cout << "Elemento encontrado en fila " << i << ", columna " << j << endl;
                encontrado=true;
            }
        }
    }

    if(!encontrado) cout << "Elemento no encontrado" << endl;
    return 0;
}

Pruebas
? Caso 1: [[1,2,3],[4,5,6]], buscar 5 ? fila 1, columna 1

? Caso 2: buscar 7 ? Elemento no encontrado

? Caso 3: buscar 1 ? fila 0, columna 0


Ejercicio 49
Título del Ejercicio: Invertir Palabras en una Cadena
Análisis del Problema
? Descripción del Problema: Invertir el orden de las palabras de una cadena.

? Entradas y Salidas:

? Entrada: Cadena de texto.

? Salida: Cadena con palabras invertidas.

Diseño de la Solución
? Algoritmo Propuesto:

1. Separar palabras usando stringstream.

2. Guardarlas en un array o vector.

3. Mostrar palabras en orden inverso.

? Estructuras de Datos: Vector o array de strings.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <sstream>
#include <vector>
using namespace std;

int main() {
    string texto = "Hola mundo desde C++";
    stringstream ss(texto);
    string palabra;
    vector<string> palabras;

    while(ss >> palabra) palabras.push_back(palabra);

    cout << "Palabras invertidas: ";
    for(int i=palabras.size()-1;i>=0;i--) cout << palabras[i] << " ";
    cout << endl; // "C++ desde mundo Hola"
    return 0;
}

Pruebas
? Caso 1: "Hola mundo" ? "mundo Hola"

? Caso 2: "Una palabra" ? "palabra Una"

? Caso 3: "" ? ""


Ejercicio 50
Título del Ejercicio: Suma de Digitos de un Número (Recursivo)
Análisis del Problema
? Descripción del Problema: Calcular la suma de los dígitos de un número entero usando recursión.

? Entradas y Salidas:

? Entrada: Número entero positivo.

? Salida: Suma de los dígitos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si n==0 ? retornar 0.

2. Retornar (n%10 + sumaDigitos(n/10)).

? Estructuras de Datos: Variables enteras.

? Funciones Principales: main() y sumaDigitos().

Código Fuente (C++)
#include <iostream>
using namespace std;

int sumaDigitos(int n){
    if(n==0) return 0;
    return n%10 + sumaDigitos(n/10);
}

int main() {
    int n=1234;
    cout << "Suma de digitos de " << n << " = " << sumaDigitos(n) << endl; // 10
    return 0;
}

Pruebas
? Caso 1: 1234 ? 10

? Caso 2: 0 ? 0

? Caso 3: 987 ? 24

Ejercicio 51
Título del Ejercicio: Verificar Número Primo
Análisis del Problema
? Descripción del Problema: Determinar si un número entero positivo es primo.

? Entradas y Salidas:

? Entrada: Número entero n.

? Salida: Mensaje indicando si es primo o no.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si n < 2 ? no es primo.

2. Recorrer de 2 a ?n y verificar divisibilidad.

3. Si divisible ? no primo; si no ? primo.

? Estructuras de Datos: Variables enteras y boolean.

? Funciones Principales: main() y esPrimo().

Código Fuente (C++)
#include <iostream>
#include <cmath>
using namespace std;

bool esPrimo(int n){
    if(n<2) return false;
    for(int i=2;i<=sqrt(n);i++)
        if(n%i==0) return false;
    return true;
}

int main() {
    int n=17;
    if(esPrimo(n)) cout << n << " es primo" << endl;
    else cout << n << " no es primo" << endl;
    return 0;
}

Pruebas
? Caso 1: 17 ? primo

? Caso 2: 10 ? no primo

? Caso 3: 2 ? primo


Ejercicio 52
Título del Ejercicio: Imprimir Tabla de Multiplicar
Análisis del Problema
? Descripción del Problema: Imprimir la tabla de multiplicar de un número.

? Entradas y Salidas:

? Entrada: Número entero n.

? Salida: Tabla de multiplicar del 1 al 10.

Diseño de la Solución
? Algoritmo Propuesto:

1. Pedir número n.

2. Usar bucle de 1 a 10 y multiplicar n*i.

3. Mostrar resultados.

? Estructuras de Datos: Variable entera.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int n=5;
    for(int i=1;i<=10;i++)
        cout << n << " x " << i << " = " << n*i << endl;
    return 0;
}

Pruebas
? Caso 1: n=5 ? 5x1=5 ... 5x10=50

? Caso 2: n=3 ? 3x1=3 ... 3x10=30

? Caso 3: n=0 ? todos 0


Ejercicio 53
Título del Ejercicio: Contar Dígitos de un Número
Análisis del Problema
? Descripción del Problema: Contar cuántos dígitos tiene un número entero positivo.

? Entradas y Salidas:

? Entrada: Número entero n.

? Salida: Cantidad de dígitos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Mientras n>0, dividir entre 10 y contar iteraciones.

2. Mostrar contador.

? Estructuras de Datos: Variable entera.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int n=12345, contador=0;
    int temp=n;
    while(temp>0){
        temp/=10;
        contador++;
    }
    cout << "Numero de digitos en " << n << " = " << contador << endl; // 5
    return 0;
}

Pruebas
? Caso 1: 12345 ? 5

? Caso 2: 0 ? 1

? Caso 3: 987654 ? 6


Ejercicio 54
Título del Ejercicio: Sumar Elementos de Array Dinámico
Análisis del Problema
? Descripción del Problema: Crear un array dinámico y sumar sus elementos.

? Entradas y Salidas:

? Entrada: Tamaño n y elementos del array.

? Salida: Suma de elementos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Pedir tamaño del array.

2. Crear array dinámico new int[n].

3. Recorrer array y acumular suma.

? Estructuras de Datos: Array dinámico y variable suma.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int n=4;
    int* arr = new int[n]{1,2,3,4};
    int suma=0;

    for(int i=0;i<n;i++) suma+=arr[i];

    cout << "Suma de elementos: " << suma << endl; // 10
    delete[] arr;
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4] ? 10

? Caso 2: [0,0,0] ? 0

? Caso 3: [5,10] ? 15


Ejercicio 55
Título del Ejercicio: Contar Apariciones de un Elemento en Array
Análisis del Problema
? Descripción del Problema: Contar cuántas veces aparece un número en un array.

? Entradas y Salidas:

? Entrada: Array y número x.

? Salida: Cantidad de apariciones.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador.

2. Recorrer array y comparar con x.

3. Incrementar contador si coincide.

? Estructuras de Datos: Array y variable contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,2,4,2}, n=6, x=2, contador=0;
    for(int i=0;i<n;i++)
        if(arr[i]==x) contador++;

    cout << "El numero " << x << " aparece " << contador << " veces" << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3,2,4,2], x=2 ? 3

? Caso 2: [1,1,1], x=1 ? 3

? Caso 3: [5,6,7], x=4 ? 0


Ejercicio 56
Título del Ejercicio: Media de Elementos de Array
Análisis del Problema
? Descripción del Problema: Calcular la media aritmética de los elementos de un array.

? Entradas y Salidas:

? Entrada: Array y tamaño.

? Salida: Media como número decimal.

Diseño de la Solución
? Algoritmo Propuesto:

1. Sumar elementos del array.

2. Dividir suma entre tamaño.

3. Mostrar resultado.

? Estructuras de Datos: Array y variable suma.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={2,4,6,8}, n=4;
    double suma=0;

    for(int i=0;i<n;i++) suma+=arr[i];

    cout << "Media = " << suma/n << endl; // 5
    return 0;
}

Pruebas
? Caso 1: [2,4,6,8] ? 5

? Caso 2: [1,1,1] ? 1

? Caso 3: [5,10] ? 7.5


Ejercicio 57
Título del Ejercicio: Concatenar Dos Cadenas
Análisis del Problema
? Descripción del Problema: Concatenar dos cadenas de texto y mostrar resultado.

? Entradas y Salidas:

? Entrada: Dos cadenas a y b.

? Salida: Cadena concatenada.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar operador + para concatenar.

2. Mostrar cadena resultante.

? Estructuras de Datos: Cadenas (string).

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

int main() {
    string a="Hola ", b="Mundo";
    string c = a + b;
    cout << "Concatenacion: " << c << endl; // "Hola Mundo"
    return 0;
}

Pruebas
? Caso 1: "Hola ", "Mundo" ? "Hola Mundo"

? Caso 2: "", "Test" ? "Test"

? Caso 3: "C++", "" ? "C++"


Ejercicio 58
Título del Ejercicio: Reemplazar Caracter en Cadena
Análisis del Problema
? Descripción del Problema: Reemplazar todas las apariciones de un carácter en una cadena por otro.

? Entradas y Salidas:

? Entrada: Cadena, carácter a reemplazar, carácter nuevo.

? Salida: Cadena modificada.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer la cadena.

2. Si carácter coincide con el original, reemplazar.

? Estructuras de Datos: Cadena (string).

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

int main() {
    string texto="banana";
    char orig='a', nuevo='o';

    for(int i=0;i<texto.length();i++)
        if(texto[i]==orig) texto[i]=nuevo;

    cout << "Cadena modificada: " << texto << endl; // "bonono"
    return 0;
}

Pruebas
? Caso 1: "banana", a?o ? "bonono"

? Caso 2: "abc", b?x ? "axc"

? Caso 3: "aaa", a?a ? "aaa"


Ejercicio 59
Título del Ejercicio: Sumar Dos Números con Punteros
Análisis del Problema
? Descripción del Problema: Sumar dos números usando punteros.

? Entradas y Salidas:

? Entrada: Dos números enteros.

? Salida: Suma de ambos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear punteros a los números.

2. Calcular suma usando punteros.

? Estructuras de Datos: Variables enteras y punteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int a=5, b=7;
    int *pa=&a, *pb=&b;
    int suma = *pa + *pb;
    cout << "Suma: " << suma << endl; // 12
    return 0;
}

Pruebas
? Caso 1: 5 + 7 ? 12

? Caso 2: 0 + 0 ? 0

? Caso 3: -3 + 3 ? 0


Ejercicio 60
Título del Ejercicio: Intercambiar Valores con Punteros
Análisis del Problema
? Descripción del Problema: Intercambiar los valores de dos variables usando punteros.

? Entradas y Salidas:

? Entrada: Dos números enteros.

? Salida: Valores intercambiados.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear punteros a las variables.

2. Usar variable temporal para intercambiar.

? Estructuras de Datos: Variables enteras y punteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int a=10, b=20;
    int *pa=&a, *pb=&b;
    int temp = *pa;
    *pa = *pb;
    *pb = temp;
    cout << "a=" << a << ", b=" << b << endl; // a=20, b=10
    return 0;
}

Pruebas
? Caso 1: 10 y 20 ? a=20, b=10

? Caso 2: -5 y 5 ? a=5, b=-5

? Caso 3: 0 y 0 ? a=0, b=0

Ejercicio 61
Título del Ejercicio: Calcular Máximo de un Array
Análisis del Problema
? Descripción del Problema: Encontrar el valor máximo dentro de un array de enteros.

? Entradas y Salidas:

? Entrada: Array de enteros y su tamaño.

? Salida: Valor máximo encontrado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar max con el primer elemento del array.

2. Recorrer el array comparando cada elemento con max.

3. Actualizar max si se encuentra un valor mayor.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={3,7,2,9,5}, n=5;
    int max=arr[0];

    for(int i=1;i<n;i++)
        if(arr[i]>max) max=arr[i];

    cout << "Maximo valor: " << max << endl; // 9
    return 0;
}

Pruebas
? Caso 1: [3,7,2,9,5] ? 9

? Caso 2: [1,1,1] ? 1

? Caso 3: [5] ? 5


Ejercicio 62
Título del Ejercicio: Calcular Mínimo de un Array
Análisis del Problema
? Descripción del Problema: Encontrar el valor mínimo dentro de un array de enteros.

? Entradas y Salidas:

? Entrada: Array de enteros y su tamaño.

? Salida: Valor mínimo encontrado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar min con el primer elemento del array.

2. Recorrer el array comparando cada elemento con min.

3. Actualizar min si se encuentra un valor menor.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={3,7,2,9,5}, n=5;
    int min=arr[0];

    for(int i=1;i<n;i++)
        if(arr[i]<min) min=arr[i];

    cout << "Minimo valor: " << min << endl; // 2
    return 0;
}

Pruebas
? Caso 1: [3,7,2,9,5] ? 2

? Caso 2: [1,1,1] ? 1

? Caso 3: [5] ? 5


Ejercicio 63
Título del Ejercicio: Buscar Valor con Punteros
Análisis del Problema
? Descripción del Problema: Buscar un valor en un array usando punteros.

? Entradas y Salidas:

? Entrada: Array de enteros y valor x a buscar.

? Salida: Índice del valor o -1 si no se encuentra.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar un puntero para recorrer el array.

2. Comparar cada elemento con x.

3. Retornar índice si se encuentra; -1 si no.

? Estructuras de Datos: Array de enteros y puntero.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={10,20,30,40}, n=4, x=30;
    int* ptr=arr;
    int pos=-1;

    for(int i=0;i<n;i++){
        if(*(ptr+i)==x) pos=i;
    }

    cout << "Posicion de " << x << " = " << pos << endl; // 2
    return 0;
}

Pruebas
? Caso 1: [10,20,30,40], x=30 ? 2

? Caso 2: x=50 ? -1

? Caso 3: x=10 ? 0


Ejercicio 64
Título del Ejercicio: Sumar Elementos de Matriz (Dinámica)
Análisis del Problema
? Descripción del Problema: Sumar todos los elementos de una matriz dinámica.

? Entradas y Salidas:

? Entrada: Matriz m x n.

? Salida: Suma de todos los elementos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear matriz dinámica con new.

2. Recorrer matriz y acumular suma.

3. Mostrar resultado y liberar memoria.

? Estructuras de Datos: Matriz dinámica.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int m=2,n=3;
    int** mat = new int*[m];
    for(int i=0;i<m;i++) mat[i]=new int[n]{1,2,3};

    int suma=0;
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
            suma+=mat[i][j];

    cout << "Suma de matriz: " << suma << endl; // 12

    for(int i=0;i<m;i++) delete[] mat[i];
    delete[] mat;
    return 0;
}

Pruebas
? Caso 1: [[1,2,3],[1,2,3]] ? 12

? Caso 2: [[0]] ? 0

? Caso 3: [[1,1],[1,1]] ? 4


Ejercicio 65
Título del Ejercicio: Invertir Array con Punteros
Análisis del Problema
? Descripción del Problema: Invertir los elementos de un array usando punteros.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Array invertido.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar punteros al inicio y al final del array.

2. Intercambiar valores hasta que los punteros se crucen.

? Estructuras de Datos: Array y punteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4,5}, n=5;
    int *start=arr, *end=arr+n-1;

    while(start<end){
        swap(*start,*end);
        start++; end--;
    }

    for(int i=0;i<n;i++) cout << arr[i] << " ";
    cout << endl; // 5 4 3 2 1
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5] ? [5,4,3,2,1]

? Caso 2: [1,2] ? [2,1]

? Caso 3: [1] ? [1]


Ejercicio 66
Título del Ejercicio: Buscar Número en Matriz con Punteros
Análisis del Problema
? Descripción del Problema: Buscar un número en matriz dinámica usando punteros.

? Entradas y Salidas:

? Entrada: Matriz m x n y número x.

? Salida: Posición o mensaje si no se encuentra.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer matriz usando aritmética de punteros.

2. Comparar cada elemento con x.

3. Mostrar posición o mensaje.

? Estructuras de Datos: Matriz dinámica y punteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int m=2,n=3;
    int mat[2][3]={{1,2,3},{4,5,6}};
    int x=5;
    bool encontrado=false;

    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(*(*(mat+i)+j)==x){
                cout << "Elemento en fila " << i << ", col " << j << endl;
                encontrado=true;
            }
        }
    }
    if(!encontrado) cout << "Elemento no encontrado" << endl;
    return 0;
}

Pruebas
? Caso 1: x=5 ? fila 1, col 1

? Caso 2: x=7 ? no encontrado

? Caso 3: x=1 ? fila 0, col 0


Ejercicio 67
Título del Ejercicio: Contar Vocales en Cadena
Análisis del Problema
? Descripción del Problema: Contar la cantidad de vocales en una cadena de texto.

? Entradas y Salidas:

? Entrada: Cadena de caracteres.

? Salida: Número de vocales.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer la cadena.

2. Incrementar contador si es vocal (a,e,i,o,u).

? Estructuras de Datos: Cadena de caracteres y contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

int main() {
    string texto="Hola Mundo";
    int contador=0;
    for(char c:texto)
        if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'||c=='A'||c=='E'||c=='I'||c=='O'||c=='U')
            contador++;

    cout << "Cantidad de vocales: " << contador << endl; // 4
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? 4

? Caso 2: "ABCDE" ? 2

? Caso 3: "xyz" ? 0


Ejercicio 68
Título del Ejercicio: Convertir Número a Binario
Análisis del Problema
? Descripción del Problema: Convertir un número entero a su representación binaria.

? Entradas y Salidas:

? Entrada: Número entero positivo.

? Salida: Representación binaria como cadena.

Diseño de la Solución
? Algoritmo Propuesto:

1. Mientras n>0, obtener n%2 y agregar al resultado.

2. Invertir la cadena final.

? Estructuras de Datos: Entero y cadena.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

int main() {
    int n=13;
    string bin="";
    int temp=n;
    while(temp>0){
        bin=to_string(temp%2)+bin;
        temp/=2;
    }
    cout << "Binario de " << n << " = " << bin << endl; // 1101
    return 0;
}

Pruebas
? Caso 1: 13 ? 1101

? Caso 2: 5 ? 101

? Caso 3: 0 ? ""


Ejercicio 69
Título del Ejercicio: Sumar Dos Matrices
Análisis del Problema
? Descripción del Problema: Sumar dos matrices del mismo tamaño.

? Entradas y Salidas:

? Entrada: Dos matrices m x n.

? Salida: Matriz resultante.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer ambas matrices y sumar elementos correspondientes.

2. Mostrar matriz resultante.

? Estructuras de Datos: Matrices bidimensionales.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int A[2][2]={{1,2},{3,4}};
    int B[2][2]={{5,6},{7,8}};
    int C[2][2];

    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            C[i][j]=A[i][j]+B[i][j];

    for(int i=0;i<2;i++){
        for(int j=0;j<2;j++) cout << C[i][j] << " ";
        cout
Ejercicio 71
Título del Ejercicio: Calcular Factorial de un Número (Recursivo)
Análisis del Problema
? Descripción del Problema: Calcular el factorial de un número entero usando recursión.

? Entradas y Salidas:

? Entrada: Número entero n.

? Salida: Factorial de n.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si n == 0 o n == 1, retornar 1.

2. Si no, retornar n * factorial(n-1).

? Estructuras de Datos: Variable entera.

? Funciones Principales: main() y factorial().

Código Fuente (C++)
#include <iostream>
using namespace std;

int factorial(int n){
    if(n<=1) return 1;
    return n * factorial(n-1);
}

int main() {
    int n=5;
    cout << "Factorial de " << n << " = " << factorial(n) << endl; // 120
    return 0;
}

Pruebas
? Caso 1: 5 ? 120

? Caso 2: 0 ? 1

? Caso 3: 3 ? 6


Ejercicio 72
Título del Ejercicio: Calcular Potencia de un Número (Recursivo)
Análisis del Problema
? Descripción del Problema: Calcular base^exponente usando recursión.

? Entradas y Salidas:

? Entrada: Base b y exponente e.

? Salida: Resultado de b^e.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si e == 0 ? retornar 1.

2. Retornar b * potencia(b, e-1).

? Estructuras de Datos: Variables enteras.

? Funciones Principales: main() y potencia().

Código Fuente (C++)
#include <iostream>
using namespace std;

int potencia(int b, int e){
    if(e==0) return 1;
    return b * potencia(b,e-1);
}

int main() {
    int base=2, exponente=4;
    cout << base << "^" << exponente << " = " << potencia(base,exponente) << endl; // 16
    return 0;
}

Pruebas
? Caso 1: 2^4 ? 16

? Caso 2: 5^0 ? 1

? Caso 3: 3^3 ? 27


Ejercicio 73
Título del Ejercicio: Recorrer Array Recursivamente
Análisis del Problema
? Descripción del Problema: Imprimir todos los elementos de un array usando recursión.

? Entradas y Salidas:

? Entrada: Array y tamaño.

? Salida: Elementos impresos en orden.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si tamaño == 0 ? retornar.

2. Imprimir primer elemento y llamar recursivamente al resto.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main() y imprimirArray().

Código Fuente (C++)
#include <iostream>
using namespace std;

void imprimirArray(int arr[], int n){
    if(n==0) return;
    cout << arr[0] << " ";
    imprimirArray(arr+1,n-1);
}

int main() {
    int arr[]={1,2,3,4,5}, n=5;
    imprimirArray(arr,n); // 1 2 3 4 5
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [1,2,3] ? 1 2 3

? Caso 2: [5] ? 5

? Caso 3: [] ? (sin imprimir)


Ejercicio 74
Título del Ejercicio: Crear Clase Persona
Análisis del Problema
? Descripción del Problema: Implementar una clase Persona con atributos nombre y edad y un método para saludar.

? Entradas y Salidas:

? Entrada: Nombre y edad.

? Salida: Saludo con información de la persona.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir clase Persona con atributos y método saludar().

2. Crear objeto y llamar método.

? Estructuras de Datos: Clase y objeto.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class Persona{
public:
    string nombre;
    int edad;
    void saludar(){
        cout << "Hola, soy " << nombre << " y tengo " << edad << " años" << endl;
    }
};

int main() {
    Persona p;
    p.nombre="Juan";
    p.edad=25;
    p.saludar(); // Hola, soy Juan y tengo 25 años
    return 0;
}

Pruebas
? Caso 1: Juan, 25 ? saludo correcto

? Caso 2: Ana, 30 ? saludo correcto

? Caso 3: Pedro, 0 ? saludo correcto


Ejercicio 75
Título del Ejercicio: Crear Clase Libro
Análisis del Problema
? Descripción del Problema: Implementar clase Libro con atributos titulo, autor y anio, y método mostrarInfo().

? Entradas y Salidas:

? Entrada: Datos del libro.

? Salida: Mostrar información del libro.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir clase Libro con atributos y método.

2. Crear objeto y llamar mostrarInfo().

? Estructuras de Datos: Clase y objeto.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class Libro{
public:
    string titulo, autor;
    int anio;
    void mostrarInfo(){
        cout << titulo << " por " << autor << ", año " << anio << endl;
    }
};

int main() {
    Libro l;
    l.titulo="C++ Básico";
    l.autor="Juan Perez";
    l.anio=2025;
    l.mostrarInfo(); // C++ Básico por Juan Perez, año 2025
    return 0;
}

Pruebas
? Caso 1: C++ Básico ? correcto

? Caso 2: Historia ? correcto

? Caso 3: Ciencia ? correcto


Ejercicio 76
Título del Ejercicio: Clase CuentaBancaria
Análisis del Problema
? Descripción del Problema: Implementar clase CuentaBancaria con métodos depositar, retirar y consultarSaldo.

? Entradas y Salidas:

? Entrada: Cantidad a depositar o retirar.

? Salida: Saldo actualizado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir clase con atributo saldo y métodos.

2. Crear objeto y realizar operaciones.

? Estructuras de Datos: Clase y objeto.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

class CuentaBancaria{
private:
    double saldo;
public:
    CuentaBancaria(){saldo=0;}
    void depositar(double monto){saldo+=monto;}
    void retirar(double monto){
        if(monto<=saldo) saldo-=monto;
        else cout << "Saldo insuficiente" << endl;
    }
    void consultarSaldo(){cout << "Saldo: " << saldo << endl;}
};

int main() {
    CuentaBancaria c;
    c.depositar(1000);
    c.retirar(500);
    c.consultarSaldo(); // 500
    return 0;
}

Pruebas
? Caso 1: depositar 1000, retirar 500 ? 500

? Caso 2: retirar 600 ? mensaje saldo insuficiente

? Caso 3: depositar 0 ? saldo correcto


Ejercicio 77
Título del Ejercicio: Crear Pila (Stack) con Array
Análisis del Problema
? Descripción del Problema: Implementar una pila usando array con operaciones push, pop y mostrar.

? Entradas y Salidas:

? Entrada: Elementos a agregar o quitar.

? Salida: Estado de la pila.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir array y variable top.

2. Implementar funciones push y pop.

? Estructuras de Datos: Array y variable top.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

class Pila{
    int arr[10], top;
public:
    Pila(){top=-1;}
    void push(int x){
        if(top<9) arr[++top]=x;
        else cout << "Pila llena" << endl;
    }
    void pop(){
        if(top>=0) top--;
        else cout << "Pila vacia" << endl;
    }
    void mostrar(){
        for(int i=top;i>=0;i--) cout << arr[i] << " ";
        cout << endl;
    }
};

int main() {
    Pila p;
    p.push(1); p.push(2); p.push(3);
    p.mostrar(); // 3 2 1
    p.pop();
    p.mostrar(); // 2 1
    return 0;
}

Pruebas
? Caso 1: push 1,2,3 ? 3 2 1

? Caso 2: pop ? 2 1

? Caso 3: pop todas ? pila vacía


Ejercicio 78
Título del Ejercicio: Crear Cola (Queue) con Array
Análisis del Problema
? Descripción del Problema: Implementar una cola usando array con operaciones enqueue y dequeue.

? Entradas y Salidas:

? Entrada: Elementos a agregar o quitar.

? Salida: Estado de la cola.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir array y variables front y rear.

2. Implementar funciones enqueue y dequeue.

? Estructuras de Datos: Array y variables front y rear.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

class Cola{
    int arr[10], front, rear;
public:
    Cola(){front=0; rear=-1;}
    void enqueue(int x){
        if(rear<9) arr[++rear]=x;
        else cout << "Cola llena" << endl;
    }
    void dequeue(){
        if(front<=rear) front++;
        else cout << "Cola vacia" << endl;
    }
    void mostrar(){
        for(int i=front;i<=rear;i++) cout << arr[i] << " ";
        cout << endl;
    }
};

int main() {
    Cola c;
    c.enqueue(1); c.enqueue(2); c.enqueue(3);
    c.mostrar(); // 1 2 3
    c.dequeue();
    c.mostrar(); // 2 3
    return 0;
}

Pruebas
? Caso 1: enqueue 1,2,3 ? 1 2 3

? Caso 2: dequeue ? 2 3

? Caso 3: dequeue todas ? Cola vacía


Ejercicio 79
Título del Ejercicio: Contar Palabras en una Cadena
Análisis del Problema
? Descripción del Problema: Contar cuántas palabras contiene una cadena.

? Entradas y Salidas:

? Entrada: Cadena de texto.

? Salida: Número de palabras.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar stringstream para separar palabras.

2. Contar cada palabra.

? Estructuras de Datos: Cadena y stringstream.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <sstream>
using namespace std;

int main() {
    string texto="Hola mundo desde C++";
    string palabra;
    int contador=0;
    stringstream ss(texto);
    while(ss >> palabra) contador++;
    cout << "Cantidad de palabras: " << contador << endl; // 4
    return 0;
}

Pruebas
? Caso 1: "Hola mundo" ? 2

? Caso 2: "" ? 0

? Caso 3: "Una palabra más" ? 3


Ejercicio 80
Título del Ejercicio: Contar Vocales Recursivamente
Análisis del Problema
? Descripción del Problema: Contar la cantidad de vocales en una cadena usando recursión.

? Entradas y Salidas:

? Entrada: Cadena de caracteres.

? Salida: Número de vocales.

Diseño de la Solución
? Algoritmo Propuesto:1
Ejercicio 81
Título del Ejercicio: Contar Vocales Recursivamente
Análisis del Problema
? Descripción del Problema: Contar la cantidad de vocales en una cadena usando recursión.

? Entradas y Salidas:

? Entrada: Cadena de caracteres.

? Salida: Número de vocales.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si la cadena está vacía ? retornar 0.

2. Si el primer carácter es vocal ? sumar 1 y llamar recursivamente al resto de la cadena.

3. Si no es vocal ? llamar recursivamente al resto de la cadena.

? Estructuras de Datos: Cadena y contador.

? Funciones Principales: main() y contarVocalesRecursivo().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

bool esVocal(char c){
    c = tolower(c);
    return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';
}

int contarVocalesRecursivo(string s){
    if(s.empty()) return 0;
    return esVocal(s[0]) + contarVocalesRecursivo(s.substr(1));
}

int main() {
    string texto="Hola Mundo";
    cout << "Cantidad de vocales: " << contarVocalesRecursivo(texto) << endl; // 4
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? 4

? Caso 2: "ABCDE" ? 2

? Caso 3: "xyz" ? 0


Ejercicio 82
Título del Ejercicio: Sumar Diagonal de Matriz
Análisis del Problema
? Descripción del Problema: Calcular la suma de los elementos de la diagonal principal de una matriz cuadrada.

? Entradas y Salidas:

? Entrada: Matriz cuadrada n x n.

? Salida: Suma de la diagonal.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer la matriz solo usando índice i para mat[i][i].

2. Acumular los valores en una variable suma.

? Estructuras de Datos: Matriz y variable suma.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[3][3]={{1,2,3},{4,5,6},{7,8,9}};
    int suma=0, n=3;

    for(int i=0;i<n;i++)
        suma+=mat[i][i];

    cout << "Suma de diagonal: " << suma << endl; // 15
    return 0;
}

Pruebas
? Caso 1: [[1,2,3],[4,5,6],[7,8,9]] ? 15

? Caso 2: [[2,0],[0,3]] ? 5

? Caso 3: [[1]] ? 1


Ejercicio 83
Título del Ejercicio: Invertir Cadena
Análisis del Problema
? Descripción del Problema: Invertir una cadena de caracteres usando bucle.

? Entradas y Salidas:

? Entrada: Cadena s.

? Salida: Cadena invertida.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer la cadena desde el final al inicio.

2. Concatenar cada carácter a la nueva cadena.

? Estructuras de Datos: Cadenas de caracteres.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s="Hola Mundo", invertida="";
    for(int i=s.length()-1;i>=0;i--) invertida+=s[i];
    cout << "Cadena invertida: " << invertida << endl; // odnuM aloH
    return 0;
}

Pruebas
? Caso 1: "Hola" ? "aloH"

? Caso 2: "C++" ? "++C"

? Caso 3: "" ? ""


Ejercicio 84
Título del Ejercicio: Convertir Minúsculas a Mayúsculas
Análisis del Problema
? Descripción del Problema: Convertir todos los caracteres de una cadena a mayúsculas.

? Entradas y Salidas:

? Entrada: Cadena s.

? Salida: Cadena en mayúsculas.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer cada carácter de la cadena.

2. Usar toupper() para convertirlo a mayúscula.

? Estructuras de Datos: Cadena de caracteres.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
#include <cctype>
using namespace std;

int main() {
    string s="Hola Mundo";
    for(int i=0;i<s.length();i++) s[i]=toupper(s[i]);
    cout << "Cadena en mayusculas: " << s << endl; // HOLA MUNDO
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? "HOLA MUNDO"

? Caso 2: "c++" ? "C++"

? Caso 3: "" ? ""


Ejercicio 85
Título del Ejercicio: Sumar Números Pares en Array
Análisis del Problema
? Descripción del Problema: Calcular la suma de los números pares de un array.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Suma de los números pares.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar suma=0.

2. Recorrer array y sumar solo los números pares.

? Estructuras de Datos: Array de enteros y variable suma.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4,5,6}, n=6, suma=0;
    for(int i=0;i<n;i++)
        if(arr[i]%2==0) suma+=arr[i];
    cout << "Suma pares: " << suma << endl; // 12
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5,6] ? 12

? Caso 2: [1,3,5] ? 0

? Caso 3: [2,4,6,8] ? 20


Ejercicio 86
Título del Ejercicio: Contar Números Negativos en Array
Análisis del Problema
? Descripción del Problema: Contar cuántos números negativos hay en un array.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Cantidad de números negativos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador=0.

2. Recorrer array y aumentar contador si el número es negativo.

? Estructuras de Datos: Array de enteros y variable contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={-1,2,-3,4,-5}, n=5, contador=0;
    for(int i=0;i<n;i++)
        if(arr[i]<0) contador++;
    cout << "Numeros negativos: " << contador << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [-1,2,-3,4,-5] ? 3

? Caso 2: [1,2,3] ? 0

? Caso 3: [-1,-2,-3] ? 3


Ejercicio 87
Título del Ejercicio: Buscar Valor Máximo Recursivamente
Análisis del Problema
? Descripción del Problema: Encontrar el valor máximo de un array usando recursión.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Valor máximo.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si tamaño=1 ? retornar el único valor.

2. Comparar primer elemento con máximo del resto del array.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main() y maxRecursivo().

Código Fuente (C++)
#include <iostream>
using namespace std;

int maxRecursivo(int arr[], int n){
    if(n==1) return arr[0];
    int maxR= maxRecursivo(arr+1,n-1);
    return (arr[0]>maxR)?arr[0]:maxR;
}

int main() {
    int arr[]={1,7,3,9,5}, n=5;
    cout << "Maximo: " << maxRecursivo(arr,n) << endl; // 9
    return 0;
}

Pruebas
? Caso 1: [1,7,3,9,5

Ejercicio 91
Título del Ejercicio: Buscar Valor Mínimo Recursivamente
Análisis del Problema
? Descripción del Problema: Encontrar el valor mínimo de un array usando recursión.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Valor mínimo.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si tamaño=1 ? retornar el único valor.

2. Comparar primer elemento con mínimo del resto del array.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main() y minRecursivo().

Código Fuente (C++)
#include <iostream>
using namespace std;

int minRecursivo(int arr[], int n){
    if(n==1) return arr[0];
    int minR= minRecursivo(arr+1,n-1);
    return (arr[0]<minR)?arr[0]:minR;
}

int main() {
    int arr[]={4,2,9,1,5}, n=5;
    cout << "Minimo: " << minRecursivo(arr,n) << endl; // 1
    return 0;
}

Pruebas
? Caso 1: [4,2,9,1,5] ? 1

? Caso 2: [1,2,3] ? 1

? Caso 3: [7] ? 7


Ejercicio 92
Título del Ejercicio: Sumar Elementos de Array Recursivamente
Análisis del Problema
? Descripción del Problema: Calcular la suma de todos los elementos de un array usando recursión.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Suma de elementos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si tamaño=0 ? retornar 0.

2. Retornar primer elemento + suma del resto del array.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main() y sumaRecursiva().

Código Fuente (C++)
#include <iostream>
using namespace std;

int sumaRecursiva(int arr[], int n){
    if(n==0) return 0;
    return arr[0] + sumaRecursiva(arr+1,n-1);
}

int main() {
    int arr[]={1,2,3,4,5}, n=5;
    cout << "Suma: " << sumaRecursiva(arr,n) << endl; // 15
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5] ? 15

? Caso 2: [0,0,0] ? 0

? Caso 3: [] ? 0


Ejercicio 93
Título del Ejercicio: Invertir Array Recursivamente
Análisis del Problema
? Descripción del Problema: Invertir los elementos de un array usando recursión.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Array invertido.

Diseño de la Solución
? Algoritmo Propuesto:

1. Intercambiar primer y último elemento.

2. Llamar recursivamente al sub-array interno.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main() y invertirRecursivo().

Código Fuente (C++)
#include <iostream>
using namespace std;

void invertirRecursivo(int arr[], int start, int end){
    if(start>=end) return;
    swap(arr[start], arr[end]);
    invertirRecursivo(arr, start+1, end-1);
}

int main() {
    int arr[]={1,2,3,4,5}, n=5;
    invertirRecursivo(arr,0,n-1);
    for(int i=0;i<n;i++) cout << arr[i] << " ";
    cout << endl; // 5 4 3 2 1
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5] ? [5,4,3,2,1]

? Caso 2: [1,2] ? [2,1]

? Caso 3: [7] ? [7]


Ejercicio 94
Título del Ejercicio: Sumar Matriz Recursivamente
Análisis del Problema
? Descripción del Problema: Sumar todos los elementos de una matriz usando recursión.

? Entradas y Salidas:

? Entrada: Matriz m x n.

? Salida: Suma de todos los elementos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si la fila actual >= m ? retornar 0.

2. Sumar elementos de la fila actual + suma del resto de filas recursivamente.

? Estructuras de Datos: Matriz 2D y variable suma.

? Funciones Principales: main() y sumarMatrizRecursivo().

Código Fuente (C++)
#include <iostream>
using namespace std;

int sumarMatrizRecursivo(int mat[][3], int filas, int cols, int f=0){
    if(f>=filas) return 0;
    int sumaFila=0;
    for(int j=0;j<cols;j++) sumaFila+=mat[f][j];
    return sumaFila + sumarMatrizRecursivo(mat,filas,cols,f+1);
}

int main() {
    int mat[2][3]={{1,2,3},{4,5,6}};
    cout << "Suma matriz: " << sumarMatrizRecursivo(mat,2,3) << endl; // 21
    return 0;
}

Pruebas
? Caso 1: [[1,2,3],[4,5,6]] ? 21

? Caso 2: [[0]] ? 0

? Caso 3: [[1,1],[1,1]] ? 4


Ejercicio 95
Título del Ejercicio: Contar Letras en Cadena
Análisis del Problema
? Descripción del Problema: Contar la cantidad de letras (a-z, A-Z) en una cadena.

? Entradas y Salidas:

? Entrada: Cadena de caracteres.

? Salida: Número de letras.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer cada carácter y verificar si es letra con isalpha().

2. Incrementar contador si es letra.

? Estructuras de Datos: Cadena y contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
#include <cctype>
using namespace std;

int main() {
    string texto="Hola 123 Mundo!";
    int contador=0;
    for(char c:texto)
        if(isalpha(c)) contador++;
    cout << "Cantidad de letras: " << contador << endl; // 9
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? 9

? Caso 2: "12345" ? 0

? Caso 3: "a1b2c3" ? 3


Ejercicio 96
Título del Ejercicio: Calcular Promedio de Array
Análisis del Problema
? Descripción del Problema: Calcular el promedio de los elementos de un array.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Promedio (float).

Diseño de la Solución
? Algoritmo Propuesto:

1. Sumar todos los elementos.

2. Dividir la suma entre el tamaño del array.

? Estructuras de Datos: Array de enteros y variable suma.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={2,4,6,8}, n=4, suma=0;
    for(int i=0;i<n;i++) suma+=arr[i];
    cout << "Promedio: " << (float)suma/n << endl; // 5
    return 0;
}

Pruebas
? Caso 1: [2,4,6,8] ? 5

? Caso 2: [1,1,1] ? 1

? Caso 3: [10,20] ? 15


Ejercicio 97
Título del Ejercicio: Eliminar Duplicados en Array
Análisis del Problema
? Descripción del Problema: Eliminar elementos duplicados de un array.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Array sin duplicados.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer el array y agregar a un nuevo array solo si no existe.

2. Mostrar array resultante.

? Estructuras de Datos: Array original y array resultante.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,2,3,4,4,5}, n=7, res[7], k=0;
    for(int i=0;i<n;i++){
        bool duplicado=false;
        for(int j=0;j<k;j++)
            if(arr[i]==res[j]) duplicado=true;
        if(!duplicado) res[k++]=arr[i];
    }
    for(int i=0;i<k;i++) cout << res[i] << " ";
    cout << endl; // 1 2 3 4 5
    return 0;
}

Pruebas
? Caso 1: [1,2,2,3] ? [1,2,3]

? Caso 2: [5,5,5] ? [5]

? Caso 3: [1,2,3] ? [1,2,3]


Ejercicio 98
Título del Ejercicio: Contar Dígitos en Número
Análisis del Problema
? Descripción del Problema: Contar la cantidad de dígitos de un número entero positivo.

? Entradas y Salidas:

? Entrada: Número entero.

? Salida: Cantidad de dígitos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Mientras n>0, dividir entre 10 y aumentar contador.

? Estructuras de Datos: Entero y contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int n=12345, contador=0;
    int temp=n;
    while(temp>0){contador++; temp/=10;}
    cout << "Cantidad de digitos: " << contador << endl; // 5
    return 0;
}

Pruebas
? Caso 1: 12345 ? 5

? Caso 2: 7 ? 1

? Caso 3: 0 ? 1 (considerando 0 como un dígito)


Ejercicio 99
Título del Ejercicio: Sumar Números Impares
Análisis del Problema
? Descripción del Problema: Calcular la suma de todos los números impares en un array.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Suma de números impares.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer el array y sumar si el número es impar.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4,5}, n=5, suma=0;
    for(int i=0;i<n;i++) if(arr[i]%2!=0) suma+=arr[i];
    cout << "Suma impares: " << suma << endl; // 9
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5] ? 9

? Caso 2: [2,4,6] ? 0

? Caso 3: [1,3,5] ? 9


Ejercicio 100
Título del Ejercicio: Contar Elementos Mayores a X
Análisis del Problema
? Descripción del Problema: Contar cuántos elementos de un array son mayores a un valor x.

? Entradas y Salidas:

? Entrada: Array de enteros y valor x.

? Salida: Cantidad de elementos mayores.

Diseño de la Solución
? Algoritmo Propuesto:

1. 
Ejercicio 101
Título del Ejercicio: Contar Elementos Mayores a X
Análisis del Problema
? Descripción del Problema: Contar cuántos elementos de un array son mayores a un valor x.

? Entradas y Salidas:

? Entrada: Array de enteros, tamaño n y valor x.

? Salida: Cantidad de elementos mayores que x.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador=0.

2. Recorrer el array y aumentar contador si el elemento > x.

? Estructuras de Datos: Array de enteros y variable contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,5,3,7,2}, n=5, x=3, contador=0;
    for(int i=0;i<n;i++)
        if(arr[i]>x) contador++;
    cout << "Elementos mayores a " << x << ": " << contador << endl; // 2
    return 0;
}

Pruebas
? Caso 1: [1,5,3,7,2], x=3 ? 2

? Caso 2: [4,6,8], x=5 ? 2

? Caso 3: [1,2,3], x=10 ? 0


Ejercicio 102
Título del Ejercicio: Verificar Palíndromo
Análisis del Problema
? Descripción del Problema: Verificar si una cadena es palíndromo.

? Entradas y Salidas:

? Entrada: Cadena de caracteres.

? Salida: true si es palíndromo, false si no.

Diseño de la Solución
? Algoritmo Propuesto:

1. Comparar primer y último carácter.

2. Llamar recursivamente al sub-string interno.

? Estructuras de Datos: Cadena de caracteres.

? Funciones Principales: main() y esPalindromo().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

bool esPalindromo(string s, int start, int end){
    if(start>=end) return true;
    if(s[start]!=s[end]) return false;
    return esPalindromo(s,start+1,end-1);
}

int main() {
    string texto="radar";
    if(esPalindromo(texto,0,texto.length()-1))
        cout << texto << " es palindromo" << endl;
    else
        cout << texto << " no es palindromo" << endl;
    return 0;
}

Pruebas
? Caso 1: "radar" ? palíndromo

? Caso 2: "hola" ? no palíndromo

? Caso 3: "a" ? palíndromo


Ejercicio 103
Título del Ejercicio: Contar Apariciones de Número
Análisis del Problema
? Descripción del Problema: Contar cuántas veces aparece un número específico en un array.

? Entradas y Salidas:

? Entrada: Array de enteros, tamaño y número x.

? Salida: Cantidad de apariciones de x.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador=0.

2. Recorrer array y aumentar contador si el elemento = x.

? Estructuras de Datos: Array de enteros y contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,2,4,2}, n=6, x=2, contador=0;
    for(int i=0;i<n;i++)
        if(arr[i]==x) contador++;
    cout << "El numero " << x << " aparece " << contador << " veces" << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3,2,4,2], x=2 ? 3

? Caso 2: [1,1,1], x=1 ? 3

? Caso 3: [5,6,7], x=8 ? 0


Ejercicio 104
Título del Ejercicio: Generar Números Fibonacci Recursivos
Análisis del Problema
? Descripción del Problema: Calcular el n-ésimo número de Fibonacci usando recursión.

? Entradas y Salidas:

? Entrada: Entero n.

? Salida: n-ésimo número de Fibonacci.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si n=0 ? retornar 0

2. Si n=1 ? retornar 1

3. Si no ? fib(n-1) + fib(n-2)

? Estructuras de Datos: Entero y función recursiva.

? Funciones Principales: main() y fibonacci().

Código Fuente (C++)
#include <iostream>
using namespace std;

int fibonacci(int n){
    if(n==0) return 0;
    if(n==1) return 1;
    return fibonacci(n-1)+fibonacci(n-2);
}

int main() {
    int n=7;
    cout << "Fibonacci(" << n << ") = " << fibonacci(n) << endl; // 13
    return 0;
}

Pruebas
? Caso 1: n=0 ? 0

? Caso 2: n=7 ? 13

? Caso 3: n=10 ? 55


Ejercicio 105
Título del Ejercicio: Ordenar Array Ascendente (Burbuja)
Análisis del Problema
? Descripción del Problema: Ordenar un array en orden ascendente usando el método burbuja.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Array ordenado ascendente.

Diseño de la Solución
? Algoritmo Propuesto:

1. Comparar elementos consecutivos.

2. Intercambiar si el anterior > siguiente.

3. Repetir hasta ordenar todo el array.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={5,2,8,1,3}, n=5;
    for(int i=0;i<n-1;i++)
        for(int j=0;j<n-i-1;j++)
            if(arr[j]>arr[j+1]) swap(arr[j],arr[j+1]);
    for(int i=0;i<n;i++) cout << arr[i] << " "; // 1 2 3 5 8
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [5,2,8,1,3] ? [1,2,3,5,8]

? Caso 2: [1,2,3] ? [1,2,3]

? Caso 3: [3,2,1] ? [1,2,3]


Ejercicio 106
Título del Ejercicio: Ordenar Array Descendente (Burbuja)
Análisis del Problema
? Descripción del Problema: Ordenar un array en orden descendente usando el método burbuja.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Array ordenado descendente.

Diseño de la Solución
? Algoritmo Propuesto:

1. Comparar elementos consecutivos.

2. Intercambiar si el anterior < siguiente.

3. Repetir hasta ordenar todo el array.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={5,2,8,1,3}, n=5;
    for(int i=0;i<n-1;i++)
        for(int j=0;j<n-i-1;j++)
            if(arr[j]<arr[j+1]) swap(arr[j],arr[j+1]);
    for(int i=0;i<n;i++) cout << arr[i] << " "; // 8 5 3 2 1
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [5,2,8,1,3] ? [8,5,3,2,1]

? Caso 2: [1,2,3] ? [3,2,1]

? Caso 3: [3,2,1] ? [3,2,1]


Ejercicio 107
Título del Ejercicio: Buscar Número en Array (Secuencial)
Análisis del Problema
? Descripción del Problema: Buscar si un número existe en un array usando búsqueda secuencial.

? Entradas y Salidas:

? Entrada: Array de enteros, tamaño y número x.

? Salida: true si existe, false si no.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer array y comparar cada elemento con x.

2. Retornar true si se encuentra; false si no.

? Estructuras de Datos: Array de enteros y variable bandera.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,4,6,8}, n=4, x=6;
    bool encontrado=false;
    for(int i=0;i<n;i++)
        if(arr[i]==x){encontrado=true; break;}
    if(encontrado) cout << x << " existe en el array" << endl;
    else cout << x << " no existe en el array" << endl;
    return 0;
}

Pruebas
? Caso 1: [1,4,6,8], x=6 ? existe

? Caso 2: [1,2,3], x=5 ? no existe

? Caso 3: [7,8,9], x=7 ? existe


Ejercicio 108
Título del Ejercicio: Encontrar Índice de Número en Array
Análisis del Problema
? Descripción del Problema: Retornar el índice de la primera aparición de un número en un array.

? Entradas y Salidas:

? Entrada: Array de enteros, tamaño y número x.

? Salida: Índice si existe, -1 si no.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer array y comparar cada elemento con x.

2. Retornar índice si se encuentra; -1 si no.

? Estructuras de Datos: Array de enteros y variable índice.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={5,3,7,3}, n=4, x=3;
    int indice=-1;
    for(int i=0;i<n;i++){
        if(arr[i]==x){indice=i; break;}
    }
    cout << "Indice de " << x << ": " << indice << endl; // 1
    return 0;
}

Pruebas
? Caso 1: [5,3,7,3], x=3 ? 1

? Caso 2: [1,2,3], x=4 ? -1

? Caso 3: [7,8,9], x=7 ? 0


Ejercicio 109
Título del Ejercicio: Multiplicar Matrices
Análisis del Problema
? Descripción del Problema: Multiplicar dos matrices m x n y n x p.

? Entradas y Salidas:

? Entrada: Dos matrices de dimensiones compatibles.

? Salida: Matriz resultante m x p.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar matriz resultado con ceros.

2. Recorrer filas y columnas multiplicando y sumando los productos correspondientes.

? Estructuras de Datos: Matrices 2D.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int A[2][3]={{1,2,3},{4,5,6}};
    int B[3][2]={{7,8},{9,10},{11,12}};
    int C[2][2]={0};

    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            for(int k=0;k<3;k++)
                C[i][j]+=A[i][k]*B[k][j];

    for(int i=0;i<2;i++){
        for(int j=0;j<2;j++) cout << C[i][j] << " ";
        cout << endl;
    }
    // 58 64
    // 139 154
    return 0;
}

Pruebas
? Caso 1: A=[[1,2],[3,4]], B=[[5,6],[7,8]] ? [[19,22],[43,50]]

? Caso 2: A=[[1]], B=[[2]] ? [[2]]

? Caso 3: A=[[0]], B=[[0]] ? [[0]]


Ejercicio 110
Título del Ejercicio: Transponer Matriz
Análisis del Problema
? Descripción del Problema: Calcular la transpuesta de una matriz m x n.

? Entradas y Salidas:

? Entrada: Matriz m x n.

? Salida: Matriz transpuesta n x m.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer matriz original.

2. Asignar elemento [i][j] a [j][i] de la transpuesta.

? Estructuras de Datos: Matrices 2D.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[2][3]={{1,2,3},{4,5,6}}, trans[3][2];

    for(int i=0;i<2;i++)
        for(int j=0;j<3;j++)
            trans[j][i]=mat[i][j];

    for(int i=0;i<3;i++){
        for(int j=0;j<2;j++) cout << trans[i][j] << " ";
        cout << endl;
    }
    // 1 4
    // 2 5
    // 3 6
    return 0;
}

Pruebas
? Caso 1: [[1,2,3],[4,5,6]] ? [[1,4],[2,5],[3,6]]

? Caso 2: [[1]] ? [[1]]

? Caso 3: [[1,2],[3,4]] ? [[1,3],[2,4]]
Ejercicio 111
Título del Ejercicio: Contar Elementos Pares en Array
Análisis del Problema
? Descripción del Problema: Contar cuántos números pares existen en un array.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Cantidad de números pares.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador=0.

2. Recorrer el array y aumentar contador si el elemento %2==0.

? Estructuras de Datos: Array de enteros y variable contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4,5,6}, n=6, contador=0;
    for(int i=0;i<n;i++)
        if(arr[i]%2==0) contador++;
    cout << "Cantidad de numeros pares: " << contador << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5,6] ? 3

? Caso 2: [1,3,5] ? 0

? Caso 3: [2,4,6,8] ? 4


Ejercicio 112
Título del Ejercicio: Contar Elementos Impares en Array
Análisis del Problema
? Descripción del Problema: Contar cuántos números impares existen en un array.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Cantidad de números impares.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador=0.

2. Recorrer array y aumentar contador si el elemento %2!=0.

? Estructuras de Datos: Array de enteros y variable contador.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4,5}, n=5, contador=0;
    for(int i=0;i<n;i++)
        if(arr[i]%2!=0) contador++;
    cout << "Cantidad de numeros impares: " << contador << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5] ? 3

? Caso 2: [2,4,6] ? 0

? Caso 3: [1,3,5] ? 3


Ejercicio 113
Título del Ejercicio: Calcular Potencia Recursiva
Análisis del Problema
? Descripción del Problema: Calcular base^exponente usando recursión.

? Entradas y Salidas:

? Entrada: Base y exponente enteros.

? Salida: Resultado de la potencia.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si exponente=0 ? retornar 1.

2. Retornar base * potencia(base, exponente-1).

? Estructuras de Datos: Enteros.

? Funciones Principales: main() y potenciaRecursiva().

Código Fuente (C++)
#include <iostream>
using namespace std;

int potenciaRecursiva(int base, int exp){
    if(exp==0) return 1;
    return base*potenciaRecursiva(base,exp-1);
}

int main() {
    int base=2, exp=5;
    cout << base << "^" << exp << " = " << potenciaRecursiva(base,exp) << endl; // 32
    return 0;
}

Pruebas
? Caso 1: 2^5 ? 32

? Caso 2: 3^3 ? 27

? Caso 3: 5^0 ? 1


Ejercicio 114
Título del Ejercicio: Factorial Recursivo
Análisis del Problema
? Descripción del Problema: Calcular el factorial de un número usando recursión.

? Entradas y Salidas:

? Entrada: Número entero n.

? Salida: Factorial de n.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si n=0 o n=1 ? retornar 1.

2. Retornar n * factorial(n-1).

? Estructuras de Datos: Enteros.

? Funciones Principales: main() y factorial().

Código Fuente (C++)
#include <iostream>
using namespace std;

int factorial(int n){
    if(n==0 || n==1) return 1;
    return n*factorial(n-1);
}

int main() {
    int n=5;
    cout << "Factorial de " << n << " = " << factorial(n) << endl; // 120
    return 0;
}

Pruebas
? Caso 1: 5! ? 120

? Caso 2: 0! ? 1

? Caso 3: 3! ? 6


Ejercicio 115
Título del Ejercicio: Sumar Números en Array con Punteros
Análisis del Problema
? Descripción del Problema: Calcular la suma de los elementos de un array usando punteros.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Suma de elementos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar suma=0.

2. Usar puntero para recorrer array y sumar valores.

? Estructuras de Datos: Array de enteros y puntero.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4}, n=4, suma=0;
    int *p=arr;
    for(int i=0;i<n;i++) suma+=*(p+i);
    cout << "Suma de elementos: " << suma << endl; // 10
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4] ? 10

? Caso 2: [0,0,0] ? 0

? Caso 3: [5,5] ? 10


Ejercicio 116
Título del Ejercicio: Intercambiar Valores con Punteros
Análisis del Problema
? Descripción del Problema: Intercambiar los valores de dos variables usando punteros.

? Entradas y Salidas:

? Entrada: Dos enteros a y b.

? Salida: Valores intercambiados.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar punteros para almacenar direcciones de a y b.

2. Intercambiar los valores usando variable temporal.

? Estructuras de Datos: Variables enteras y punteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int a=5, b=10;
    int *pa=&a, *pb=&b;
    int temp=*pa;
    *pa=*pb;
    *pb=temp;
    cout << "a=" << a << " b=" << b << endl; // a=10 b=5
    return 0;
}

Pruebas
? Caso 1: a=5, b=10 ? a=10, b=5

? Caso 2: a=0, b=0 ? a=0, b=0

? Caso 3: a=7, b=3 ? a=3, b=7


Ejercicio 117
Título del Ejercicio: Copiar Cadena con Punteros
Análisis del Problema
? Descripción del Problema: Copiar una cadena de caracteres usando aritmética de punteros.

? Entradas y Salidas:

? Entrada: Cadena origen.

? Salida: Cadena destino idéntica.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar punteros para recorrer la cadena origen.

2. Copiar carácter por carácter hasta '\0'.

? Estructuras de Datos: Cadena de caracteres y punteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    char origen[]="Hola Mundo";
    char destino[50];
    char *p1=origen, *p2=destino;
    while(*p1 != '\0') {
        *p2 = *p1;
        p1++;
        p2++;
    }
    *p2='\0';
    cout << "Cadena copiada: " << destino << endl; // Hola Mundo
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? "Hola Mundo"

? Caso 2: "" ? ""

? Caso 3: "C++" ? "C++"


Ejercicio 118
Título del Ejercicio: Crear Clase Persona
Análisis del Problema
? Descripción del Problema: Crear una clase Persona con atributos nombre y edad, y método saludar.

? Entradas y Salidas:

? Entrada: Nombre y edad.

? Salida: Mensaje de saludo.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir clase Persona con atributos y método.

2. Crear objeto y llamar método.

? Estructuras de Datos: Clase y objetos.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class Persona{
public:
    string nombre;
    int edad;
    void saludar(){
        cout << "Hola, soy " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona p;
    p.nombre="Juan";
    p.edad=25;
    p.saludar(); // Hola, soy Juan
Ejercicio 121
Título del Ejercicio: Crear Clase Libro
Análisis del Problema
? Descripción del Problema: Crear una clase Libro con propiedades título, autor y año, y un método para mostrar la información.

? Entradas y Salidas:

? Entrada: Título, autor y año del libro.

? Salida: Información completa del libro.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir clase Libro con atributos y método mostrar().

2. Crear objeto y asignar valores.

3. Llamar al método mostrar().

? Estructuras de Datos: Clase y objetos.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class Libro{
public:
    string titulo;
    string autor;
    int anio;
    void mostrar(){
        cout << "Titulo: " << titulo << ", Autor: " << autor << ", Año: " << anio << endl;
    }
};

int main() {
    Libro libro1;
    libro1.titulo="C++ Basics";
    libro1.autor="Juan Perez";
    libro1.anio=2025;
    libro1.mostrar(); // Titulo: C++ Basics, Autor: Juan Perez, Año: 2025
    return 0;
}

Pruebas
? Caso 1: Titulo="C++ Basics", Autor="Juan Perez", Año=2025 ? Mostrar información correcta

? Caso 2: Titulo="Data Structures", Autor="Ana", Año=2024 ? Mostrar información correcta


Ejercicio 122
Título del Ejercicio: Crear Clase CuentaBancaria
Análisis del Problema
? Descripción del Problema: Crear una clase CuentaBancaria con métodos para depositar, retirar y consultar saldo.

? Entradas y Salidas:

? Entrada: Depósitos y retiros.

? Salida: Saldo actualizado y mensajes de operaciones.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir clase con atributo saldo y métodos depositar(), retirar(), mostrarSaldo().

2. Crear objeto y ejecutar operaciones.

? Estructuras de Datos: Clase y objeto.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

class CuentaBancaria{
private:
    double saldo;
public:
    CuentaBancaria(){ saldo=0; }
    void depositar(double monto){ saldo+=monto; }
    void retirar(double monto){
        if(monto>saldo) cout << "Fondos insuficientes." << endl;
        else saldo-=monto;
    }
    void mostrarSaldo(){ cout << "Saldo actual: " << saldo << endl; }
};

int main() {
    CuentaBancaria cuenta;
    cuenta.depositar(100);
    cuenta.retirar(30);
    cuenta.mostrarSaldo(); // Saldo actual: 70
    return 0;
}

Pruebas
? Caso 1: Depositar 100, retirar 30 ? Saldo 70

? Caso 2: Retirar 200 ? Mensaje de fondos insuficientes


Ejercicio 123
Título del Ejercicio: Buscar Máximo en Array
Análisis del Problema
? Descripción del Problema: Encontrar el valor máximo en un array.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Valor máximo.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar max con primer elemento.

2. Recorrer array comparando cada elemento.

3. Actualizar max si se encuentra un valor mayor.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={5,8,2,10,3}, n=5, max=arr[0];
    for(int i=1;i<n;i++)
        if(arr[i]>max) max=arr[i];
    cout << "Valor maximo: " << max << endl; // 10
    return 0;
}

Pruebas
? Caso 1: [5,8,2,10,3] ? 10

? Caso 2: [1,1,1] ? 1

? Caso 3: [-5,-2,-3] ? -2


Ejercicio 124
Título del Ejercicio: Buscar Mínimo en Array
Análisis del Problema
? Descripción del Problema: Encontrar el valor mínimo en un array.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Valor mínimo.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar min con primer elemento.

2. Recorrer array comparando cada elemento.

3. Actualizar min si se encuentra un valor menor.

? Estructuras de Datos: Array de enteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={5,8,2,10,3}, n=5, min=arr[0];
    for(int i=1;i<n;i++)
        if(arr[i]<min) min=arr[i];
    cout << "Valor minimo: " << min << endl; // 2
    return 0;
}

Pruebas
? Caso 1: [5,8,2,10,3] ? 2

? Caso 2: [1,1,1] ? 1

? Caso 3: [-5,-2,-3] ? -5


Ejercicio 125
Título del Ejercicio: Calcular Promedio con Punteros
Análisis del Problema
? Descripción del Problema: Calcular el promedio de los elementos de un array usando punteros.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Promedio (float).

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar suma=0.

2. Recorrer array usando puntero y acumular valores.

3. Dividir suma entre tamaño.

? Estructuras de Datos: Array y puntero.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={2,4,6,8}, n=4;
    int *p=arr, suma=0;
    for(int i=0;i<n;i++) suma+=*(p+i);
    cout << "Promedio: " << (float)suma/n << endl; // 5
    return 0;
}

Pruebas
? Caso 1: [2,4,6,8] ? 5

? Caso 2: [1,1,1] ? 1

? Caso 3: [5,10] ? 7.5


Ejercicio 126
Título del Ejercicio: Recorrer Array con Punteros
Análisis del Problema
? Descripción del Problema: Recorrer un array y mostrar cada elemento usando punteros.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Elementos impresos en consola.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar puntero al inicio del array.

2. Recorrer array incrementando el puntero y mostrando valores.

? Estructuras de Datos: Array y puntero.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4}, n=4;
    int *p=arr;
    for(int i=0;i<n;i++) cout << *(p+i) << " "; // 1 2 3 4
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4] ? 1 2 3 4

? Caso 2: [5,6] ? 5 6

? Caso 3: [0] ? 0


Ejercicio 127
Título del Ejercicio: Invertir Array con Punteros
Análisis del Problema
? Descripción del Problema: Invertir los elementos de un array usando punteros.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Array invertido.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar punteros al inicio y al final del array.

2. Intercambiar valores mientras inicio < fin.

? Estructuras de Datos: Array y punteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4,5}, n=5;
    int *inicio=arr, *fin=arr+n-1;
    while(inicio<fin){
        int temp=*inicio;
        *inicio=*fin;
        *fin=temp;
        inicio++; fin--;
    }
    for(int i=0;i<n;i++) cout << arr[i]
Ejercicio 131
Título del Ejercicio: Invertir Array con Punteros (continuación)
Análisis del Problema
? Descripción del Problema: Invertir los elementos de un array usando punteros.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Array invertido.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar punteros al inicio y al final del array.

2. Intercambiar valores mientras inicio < fin.

? Estructuras de Datos: Array y punteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4,5}, n=5;
    int *inicio=arr, *fin=arr+n-1;
    while(inicio<fin){
        int temp=*inicio;
        *inicio=*fin;
        *fin=temp;
        inicio++; fin--;
    }
    for(int i=0;i<n;i++) cout << arr[i] << " "; // 5 4 3 2 1
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5] ? [5,4,3,2,1]

? Caso 2: [1,2] ? [2,1]

? Caso 3: [1] ? [1]


Ejercicio 132
Título del Ejercicio: Recorrer Matriz y Sumar Elementos
Análisis del Problema
? Descripción del Problema: Calcular la suma de todos los elementos de una matriz.

? Entradas y Salidas:

? Entrada: Matriz de enteros y dimensiones.

? Salida: Suma total.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar suma=0.

2. Recorrer filas y columnas sumando elementos.

? Estructuras de Datos: Matriz 2D.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[2][3]={{1,2,3},{4,5,6}}, suma=0;
    for(int i=0;i<2;i++)
        for(int j=0;j<3;j++)
            suma+=mat[i][j];
    cout << "Suma de elementos: " << suma << endl; // 21
    return 0;
}

Pruebas
? Caso 1: [[1,2,3],[4,5,6]] ? 21

? Caso 2: [[0,0],[0,0]] ? 0

? Caso 3: [[-1,-2],[3,4]] ? 4


Ejercicio 133
Título del Ejercicio: Buscar Número en Matriz
Análisis del Problema
? Descripción del Problema: Verificar si un número existe en una matriz.

? Entradas y Salidas:

? Entrada: Matriz de enteros, dimensiones y número x.

? Salida: true si existe, false si no.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer todas las posiciones de la matriz.

2. Comparar cada elemento con x.

? Estructuras de Datos: Matriz 2D.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[2][2]={{1,2},{3,4}}, x=3;
    bool encontrado=false;
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            if(mat[i][j]==x) encontrado=true;
    if(encontrado) cout << x << " existe en la matriz" << endl;
    else cout << x << " no existe" << endl;
    return 0;
}

Pruebas
? Caso 1: x=3 ? existe

? Caso 2: x=5 ? no existe

? Caso 3: x=1 ? existe


Ejercicio 134
Título del Ejercicio: Sumar Diagonal Principal de Matriz
Análisis del Problema
? Descripción del Problema: Calcular la suma de los elementos de la diagonal principal de una matriz cuadrada.

? Entradas y Salidas:

? Entrada: Matriz cuadrada de tamaño n.

? Salida: Suma de la diagonal principal.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer posiciones [i][i] de la matriz.

2. Acumular los valores en suma.

? Estructuras de Datos: Matriz 2D.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[3][3]={{1,2,3},{4,5,6},{7,8,9}}, suma=0;
    for(int i=0;i<3;i++) suma+=mat[i][i];
    cout << "Suma diagonal principal: " << suma << endl; // 15
    return 0;
}

Pruebas
? Caso 1: [[1,2,3],[4,5,6],[7,8,9]] ? 15

? Caso 2: [[1,0],[0,1]] ? 2

? Caso 3: [[5]] ? 5


Ejercicio 135
Título del Ejercicio: Sumar Diagonal Secundaria de Matriz
Análisis del Problema
? Descripción del Problema: Calcular la suma de la diagonal secundaria de una matriz cuadrada.

? Entradas y Salidas:

? Entrada: Matriz cuadrada de tamaño n.

? Salida: Suma de diagonal secundaria.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer posiciones [i][n-1-i] de la matriz.

2. Acumular los valores en suma.

? Estructuras de Datos: Matriz 2D.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[3][3]={{1,2,3},{4,5,6},{7,8,9}}, suma=0, n=3;
    for(int i=0;i<n;i++) suma+=mat[i][n-1-i];
    cout << "Suma diagonal secundaria: " << suma << endl; // 15
    return 0;
}

Pruebas
? Caso 1: [[1,2,3],[4,5,6],[7,8,9]] ? 15

? Caso 2: [[1,0],[0,1]] ? 1

? Caso 3: [[5]] ? 5


Ejercicio 136
Título del Ejercicio: Multiplicar Elementos de Array por Escalar
Análisis del Problema
? Descripción del Problema: Multiplicar todos los elementos de un array por un número dado.

? Entradas y Salidas:

? Entrada: Array y número escalar.

? Salida: Array modificado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer array y multiplicar cada elemento por el escalar.

? Estructuras de Datos: Array.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4}, n=4, escalar=3;
    for(int i=0;i<n;i++) arr[i]*=escalar;
    for(int i=0;i<n;i++) cout << arr[i] << " "; // 3 6 9 12
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4], escalar=3 ? [3,6,9,12]

? Caso 2: [0,1], escalar=5 ? [0,5]


Ejercicio 137
Título del Ejercicio: Sumar Dos Arrays
Análisis del Problema
? Descripción del Problema: Sumar elemento a elemento dos arrays del mismo tamaño.

? Entradas y Salidas:

? Entrada: Dos arrays de tamaño n.

? Salida: Array resultado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer los arrays y sumar cada par de elementos.

2. Guardar resultado en un tercer array.

? Estructuras de Datos: Arrays.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int A[]={1,2,3}, B[]={4,5,6}, n=3, C[3];
    for(int i=0;i<n;i++) C[i]=A[i]+B[i];
    for(int i=0;i<n;i++) cout << C[i] << " "; // 5 7 9
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: A=[1,2,3], B=[4,5,6] ? [5,7,9]

? Caso 2: A=[0], B=[0] ? [0]


Ejercicio 138
Título del Ejercicio: Restar Dos Arrays
Análisis del Problema
? Descripción del Problema: Restar elemento a elemento dos arrays del mismo tamaño.

? Entradas y Salidas:

? Entrada: Dos arrays de tamaño n.

? Salida: Array resultado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer los arrays y restar cada par de elementos.

2. Guardar resultado en un tercer array.

? Estructuras de Datos: Arrays.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int A[]={5,6,7}, B[]={1,2,3}, n=3, C[3];
    for(int i=0;i<n;i++) C[i]=A[i]-B[i];
    for(int i=0;i<n;i++) cout << C[i] << " "; // 4 4 4
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: A=[5,6,7], B=[1,2,3] ? [4,4,4]

? Caso 2: A=[0], B=[0] ? [0]


Ejercicio 139
Título del Ejercicio: Contar Vocales en Cadena
Análisis del Problema
? Descripción del Problema: Contar la cantidad de vocales en una cadena de caracteres de forma recursiva.

? Entradas y Salidas:

? Entrada: Cadena de caracteres.

? Salida: Número de vocales.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si la cadena está vacía ? retornar 0.

2. Si primer carácter es vocal ? 1 + contar vocales resto.

3. Si no ? contar vocales resto.

? Estructuras de Datos: Cadena y función recursiva.

? Funciones Principales: main() y contarVocales().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

int contarVocales(string s, int i=0){
    if(i==s.length()) return 0;
    char c=tolower(s[i]);
    if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u') return 1+contarVocales(s,i+1);
    return contarVocales(s,i+1);
}

int main() {
    string texto="Hola Mundo";
    cout << "Cantidad de vocales: " << contarVocales(texto) << endl; // 4
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? 4

? Caso 2: "xyz" ? 0

? Caso 3: "AEIOU" ? 5


Ejercicio 140
Título del Ejercicio: Contar Consonantes en Cadena
Análisis del Problema
? Descripción del Problema: Contar la cantidad de consonantes en una cadena de caracteres de forma recursiva.

? Entradas y Salidas:

? Entrada: Cadena de caracteres.

? Salida: Número de consonantes.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si la cadena está vacía ? retornar

Ejercicio 140 (continuación)
Título del Ejercicio: Contar Consonantes en Cadena
Análisis del Problema
? Descripción del Problema: Contar la cantidad de consonantes en una cadena de caracteres de forma recursiva.

? Entradas y Salidas:

? Entrada: Cadena de caracteres.

? Salida: Número de consonantes.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si la cadena está vacía ? retornar 0.

2. Si el carácter actual es consonante ? 1 + contar consonantes del resto.

3. Si no ? contar consonantes del resto.

? Estructuras de Datos: Cadena y función recursiva.

? Funciones Principales: main() y contarConsonantes().

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

bool esConsonante(char c){
    c=tolower(c);
    return (c>='a' && c<='z') && !(c=='a'||c=='e'||c=='i'||c=='o'||c=='u');
}

int contarConsonantes(string s, int i=0){
    if(i==s.length()) return 0;
    if(esConsonante(s[i])) return 1+contarConsonantes(s,i+1);
    return contarConsonantes(s,i+1);
}

int main() {
    string texto="Hola Mundo";
    cout << "Cantidad de consonantes: " << contarConsonantes(texto) << endl; // 5
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? 5

? Caso 2: "AEIOU" ? 0

? Caso 3: "C++ Programming" ? 10


Ejercicio 141
Título del Ejercicio: Implementar Pila (Stack) con Array
Análisis del Problema
? Descripción del Problema: Crear una pila usando un array estático con operaciones push, pop y mostrar elementos.

? Entradas y Salidas:

? Entrada: Números a insertar o retirar.

? Salida: Estado actual de la pila.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir tamaño máximo y array para pila.

2. Usar variable top para controlar el tope de la pila.

3. Implementar funciones push(), pop() y mostrar().

? Estructuras de Datos: Array y variable top.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

#define MAX 5

class Pila {
    int arr[MAX];
    int top;
public:
    Pila(){ top=-1; }
    void push(int x){
        if(top==MAX-1) cout << "Pila llena\n";
        else arr[++top]=x;
    }
    void pop(){
        if(top==-1) cout << "Pila vacia\n";
        else top--;
    }
    void mostrar(){
        for(int i=top;i>=0;i--) cout << arr[i] << " ";
        cout << endl;
    }
};

int main() {
    Pila pila;
    pila.push(1);
    pila.push(2);
    pila.push(3);
    pila.mostrar(); // 3 2 1
    pila.pop();
    pila.mostrar(); // 2 1
    return 0;
}

Pruebas
? Caso 1: Push 1,2,3 ? Mostrar ? 3 2 1

? Caso 2: Pop ? Mostrar ? 2 1

? Caso 3: Pop 2 veces más ? Mostrar ? Pila vacía


Ejercicio 142
Título del Ejercicio: Implementar Cola (Queue) con Array
Análisis del Problema
? Descripción del Problema: Crear una cola usando array estático con operaciones enqueue, dequeue y mostrar.

? Entradas y Salidas:

? Entrada: Números a encolar o desencolar.

? Salida: Estado actual de la cola.

Diseño de la Solución
? Algoritmo Propuesto:

1. Definir array y variables front y rear.

2. Implementar enqueue() y dequeue().

3. Mostrar estado actual de la cola.

? Estructuras de Datos: Array y variables front/rear.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

#define MAX 5

class Cola {
    int arr[MAX];
    int front, rear;
public:
    Cola(){ front=0; rear=-1; }
    void enqueue(int x){
        if(rear==MAX-1) cout << "Cola llena\n";
        else arr[++rear]=x;
    }
    void dequeue(){
        if(front>rear) cout << "Cola vacia\n";
        else front++;
    }
    void mostrar(){
        for(int i=front;i<=rear;i++) cout << arr[i] << " ";
        cout << endl;
    }
};

int main() {
    Cola cola;
    cola.enqueue(1);
    cola.enqueue(2);
    cola.enqueue(3);
    cola.mostrar(); // 1 2 3
    cola.dequeue();
    cola.mostrar(); // 2 3
    return 0;
}

Pruebas
? Caso 1: Enqueue 1,2,3 ? Mostrar ? 1 2 3

? Caso 2: Dequeue ? Mostrar ? 2 3

? Caso 3: Dequeue todas ? Mostrar ? Cola vacía


Ejercicio 143
Título del Ejercicio: Sumar Elementos de Dos Matrices
Análisis del Problema
? Descripción del Problema: Sumar dos matrices del mismo tamaño elemento a elemento.

? Entradas y Salidas:

? Entrada: Dos matrices 2D de enteros.

? Salida: Matriz suma.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer filas y columnas de las matrices.

2. Sumar cada par de elementos y guardar en matriz resultado.

? Estructuras de Datos: Matrices 2D.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int A[2][2]={{1,2},{3,4}}, B[2][2]={{5,6},{7,8}}, C[2][2];
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            C[i][j]=A[i][j]+B[i][j];
    for(int i=0;i<2;i++){
        for(int j=0;j<2;j++) cout << C[i][j] << " ";
        cout << endl;
    }
    return 0;
}

Pruebas
? Caso 1: [[1,2],[3,4]] + [[5,6],[7,8]] ? [[6,8],[10,12]]

? Caso 2: [[0,0],[0,0]] + [[1,1],[1,1]] ? [[1,1],[1,1]]


Ejercicio 144
Título del Ejercicio: Multiplicar Elementos de Dos Matrices
Análisis del Problema
? Descripción del Problema: Multiplicar elemento a elemento dos matrices del mismo tamaño.

? Entradas y Salidas:

? Entrada: Dos matrices 2D de enteros.

? Salida: Matriz resultado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer filas y columnas.

2. Multiplicar elementos correspondientes y guardar en matriz resultado.

? Estructuras de Datos: Matrices 2D.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int A[2][2]={{1,2},{3,4}}, B[2][2]={{5,6},{7,8}}, C[2][2];
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            C[i][j]=A[i][j]*B[i][j];
    for(int i=0;i<2;i++){
        for(int j=0;j<2;j++) cout << C[i][j] << " ";
        cout << endl;
    }
    return 0;
}

Pruebas
? Caso 1: [[1,2],[3,4]] * [[5,6],[7,8]] ? [[5,12],[21,32]]

? Caso 2: [[1,1],[1,1]] * [[2,2],[2,2]] ? [[2,2],[2,2]]


Ejercicio 145
Título del Ejercicio: Sumar Fila de Matriz
Análisis del Problema
? Descripción del Problema: Calcular la suma de los elementos de una fila específica de una matriz.

? Entradas y Salidas:

? Entrada: Matriz, número de fila.

? Salida: Suma de la fila.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar suma=0.

2. Recorrer la fila indicada y sumar elementos.

? Estructuras de Datos: Matriz 2D.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[3][3]={{1,2,3},{4,5,6},{7,8,9}}, fila=1, suma=0;
    for(int j=0;j<3;j++) suma+=mat[fila][j];
    cout << "Suma fila " << fila << ": " << suma << endl; // 15
    return 0;
}

Pruebas
? Caso 1: fila 1 ? 4+5+6=15

? Caso 2: fila 0 ? 1+2+3=6

? Caso 3: fila 2 ? 7+8+9=24

Ejercicio 146
Título del Ejercicio: Sumar Columna de Matriz
Análisis del Problema
? Descripción del Problema: Calcular la suma de los elementos de una columna específica de una matriz.

? Entradas y Salidas:

? Entrada: Matriz, número de columna.

? Salida: Suma de la columna.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar suma=0.

2. Recorrer la columna indicada y sumar elementos.

? Estructuras de Datos: Matriz 2D.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[3][3]={{1,2,3},{4,5,6},{7,8,9}}, col=2, suma=0;
    for(int i=0;i<3;i++) suma+=mat[i][col];
    cout << "Suma columna " << col << ": " << suma << endl; // 18
    return 0;
}

Pruebas
? Caso 1: col=2 ? 3+6+9=18

? Caso 2: col=0 ? 1+4+7=12

? Caso 3: col=1 ? 2+5+8=15


Ejercicio 147
Título del Ejercicio: Calcular Factorial de un Número (Recursivo)
Análisis del Problema
? Descripción del Problema: Calcular el factorial de un número entero n usando recursividad.

? Entradas y Salidas:

? Entrada: Número entero n ? 0.

? Salida: Factorial de n.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si n=0 ? retornar 1.

2. Si n>0 ? retornar n * factorial(n-1).

? Estructuras de Datos: Variables enteras.

? Funciones Principales: main() y factorial().

Código Fuente (C++)
#include <iostream>
using namespace std;

int factorial(int n){
    if(n==0) return 1;
    return n*factorial(n-1);
}

int main() {
    int num=5;
    cout << "Factorial de " << num << ": " << factorial(num) << endl; // 120
    return 0;
}

Pruebas
? Caso 1: n=5 ? 120

? Caso 2: n=0 ? 1

? Caso 3: n=3 ? 6


Ejercicio 148
Título del Ejercicio: Calcular Potencia (Recursivo)
Análisis del Problema
? Descripción del Problema: Calcular la potencia de un número base elevado a exponente usando recursión.

? Entradas y Salidas:

? Entrada: base y exponente ? 0.

? Salida: Resultado base^exponente.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si exponente=0 ? retornar 1.

2. Si exponente>0 ? retornar base * potencia(base, exponente-1).

? Estructuras de Datos: Variables enteras.

? Funciones Principales: main() y potencia().

Código Fuente (C++)
#include <iostream>
using namespace std;

int potencia(int base, int exp){
    if(exp==0) return 1;
    return base*potencia(base, exp-1);
}

int main() {
    int base=2, exp=5;
    cout << base << "^" << exp << " = " << potencia(base, exp) << endl; // 32
    return 0;
}

Pruebas
? Caso 1: 2^5 ? 32

? Caso 2: 3^0 ? 1

? Caso 3: 5^3 ? 125


Ejercicio 149
Título del Ejercicio: Contar Números Pares en Array (Recursivo)
Análisis del Problema
? Descripción del Problema: Contar la cantidad de números pares en un array usando recursión.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño n.

? Salida: Cantidad de números pares.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si tamaño=0 ? retornar 0.

2. Si último elemento es par ? 1 + contar en el resto.

3. Si no ? contar en el resto.

? Estructuras de Datos: Array y función recursiva.

? Funciones Principales: main() y contarPares().

Código Fuente (C++)
#include <iostream>
using namespace std;

int contarPares(int arr[], int n){
    if(n==0) return 0;
    return (arr[n-1]%2==0) + contarPares(arr,n-1);
}

int main() {
    int arr[]={1,2,3,4,5,6}, n=6;
    cout << "Cantidad de pares: " << contarPares(arr,n) << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5,6] ? 3

? Caso 2: [1,3,5] ? 0

? Caso 3: [2,4,6,8] ? 4


Ejercicio 150
Título del Ejercicio: Contar Números Impares en Array (Recursivo)
Análisis del Problema
? Descripción del Problema: Contar la cantidad de números impares en un array usando recursión.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño n.

? Salida: Cantidad de números impares.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si tamaño=0 ? retornar 0.

2. Si último elemento es impar ? 1 + contar en el resto.

3. Si no ? contar en el resto.

? Estructuras de Datos: Array y función recursiva.

? Funciones Principales: main() y contarImpares().

Código Fuente (C++)
#include <iostream>
using namespace std;

int contarImpares(int arr[], int n){
    if(n==0) return 0;
    return (arr[n-1]%2!=0) + contarImpares(arr,n-1);
}

int main() {
    int arr[]={1,2,3,4,5,6}, n=6;
    cout << "Cantidad de impares: " << contarImpares(arr,n) << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5,6] ? 3

? Caso 2: [2,4,6] ? 0

? Caso 3: [1,3,5,7] ? 4


Ejercicio 151
Título del Ejercicio: Intercambiar Dos Variables Usando Punteros
Análisis del Problema
? Descripción del Problema: Intercambiar el valor de dos variables enteras usando punteros.

? Entradas y Salidas:

? Entrada: Dos números enteros.

? Salida: Números intercambiados.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear punteros apuntando a las variables.

2. Usar variable temporal para intercambio.

? Estructuras de Datos: Variables enteras y punteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int a=5, b=10, *pa=&a, *pb=&b;
    int temp=*pa;
    *pa=*pb;
    *pb=temp;
    cout << "a=" << a << ", b=" << b << endl; // a=10, b=5
    return 0;
}

Pruebas
? Caso 1: a=5, b=10 ? a=10, b=5

? Caso 2: a=0, b=1 ? a=1, b=0

Ejercicio 146
Título del Ejercicio: Sumar Columna de Matriz
Análisis del Problema
? Descripción del Problema: Calcular la suma de los elementos de una columna específica de una matriz.

? Entradas y Salidas:

? Entrada: Matriz, número de columna.

? Salida: Suma de la columna.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar suma=0.

2. Recorrer la columna indicada y sumar elementos.

? Estructuras de Datos: Matriz 2D.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[3][3]={{1,2,3},{4,5,6},{7,8,9}}, col=2, suma=0;
    for(int i=0;i<3;i++) suma+=mat[i][col];
    cout << "Suma columna " << col << ": " << suma << endl; // 18
    return 0;
}

Pruebas
? Caso 1: col=2 ? 3+6+9=18

? Caso 2: col=0 ? 1+4+7=12

? Caso 3: col=1 ? 2+5+8=15


Ejercicio 147
Título del Ejercicio: Calcular Factorial de un Número (Recursivo)
Análisis del Problema
? Descripción del Problema: Calcular el factorial de un número entero n usando recursividad.

? Entradas y Salidas:

? Entrada: Número entero n ? 0.

? Salida: Factorial de n.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si n=0 ? retornar 1.

2. Si n>0 ? retornar n * factorial(n-1).

? Estructuras de Datos: Variables enteras.

? Funciones Principales: main() y factorial().

Código Fuente (C++)
#include <iostream>
using namespace std;

int factorial(int n){
    if(n==0) return 1;
    return n*factorial(n-1);
}

int main() {
    int num=5;
    cout << "Factorial de " << num << ": " << factorial(num) << endl; // 120
    return 0;
}

Pruebas
? Caso 1: n=5 ? 120

? Caso 2: n=0 ? 1

? Caso 3: n=3 ? 6


Ejercicio 148
Título del Ejercicio: Calcular Potencia (Recursivo)
Análisis del Problema
? Descripción del Problema: Calcular la potencia de un número base elevado a exponente usando recursión.

? Entradas y Salidas:

? Entrada: base y exponente ? 0.

? Salida: Resultado base^exponente.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si exponente=0 ? retornar 1.

2. Si exponente>0 ? retornar base * potencia(base, exponente-1).

? Estructuras de Datos: Variables enteras.

? Funciones Principales: main() y potencia().

Código Fuente (C++)
#include <iostream>
using namespace std;

int potencia(int base, int exp){
    if(exp==0) return 1;
    return base*potencia(base, exp-1);
}

int main() {
    int base=2, exp=5;
    cout << base << "^" << exp << " = " << potencia(base, exp) << endl; // 32
    return 0;
}

Pruebas
? Caso 1: 2^5 ? 32

? Caso 2: 3^0 ? 1

? Caso 3: 5^3 ? 125


Ejercicio 149
Título del Ejercicio: Contar Números Pares en Array (Recursivo)
Análisis del Problema
? Descripción del Problema: Contar la cantidad de números pares en un array usando recursión.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño n.

? Salida: Cantidad de números pares.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si tamaño=0 ? retornar 0.

2. Si último elemento es par ? 1 + contar en el resto.

3. Si no ? contar en el resto.

? Estructuras de Datos: Array y función recursiva.

? Funciones Principales: main() y contarPares().

Código Fuente (C++)
#include <iostream>
using namespace std;

int contarPares(int arr[], int n){
    if(n==0) return 0;
    return (arr[n-1]%2==0) + contarPares(arr,n-1);
}

int main() {
    int arr[]={1,2,3,4,5,6}, n=6;
    cout << "Cantidad de pares: " << contarPares(arr,n) << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5,6] ? 3

? Caso 2: [1,3,5] ? 0

? Caso 3: [2,4,6,8] ? 4


Ejercicio 150
Título del Ejercicio: Contar Números Impares en Array (Recursivo)
Análisis del Problema
? Descripción del Problema: Contar la cantidad de números impares en un array usando recursión.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño n.

? Salida: Cantidad de números impares.

Diseño de la Solución
? Algoritmo Propuesto:

1. Si tamaño=0 ? retornar 0.

2. Si último elemento es impar ? 1 + contar en el resto.

3. Si no ? contar en el resto.

? Estructuras de Datos: Array y función recursiva.

? Funciones Principales: main() y contarImpares().

Código Fuente (C++)
#include <iostream>
using namespace std;

int contarImpares(int arr[], int n){
    if(n==0) return 0;
    return (arr[n-1]%2!=0) + contarImpares(arr,n-1);
}

int main() {
    int arr[]={1,2,3,4,5,6}, n=6;
    cout << "Cantidad de impares: " << contarImpares(arr,n) << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5,6] ? 3

? Caso 2: [2,4,6] ? 0

? Caso 3: [1,3,5,7] ? 4


Ejercicio 151
Título del Ejercicio: Intercambiar Dos Variables Usando Punteros
Análisis del Problema
? Descripción del Problema: Intercambiar el valor de dos variables enteras usando punteros.

? Entradas y Salidas:

? Entrada: Dos números enteros.

? Salida: Números intercambiados.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear punteros apuntando a las variables.

2. Usar variable temporal para intercambio.

? Estructuras de Datos: Variables enteras y punteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int a=5, b=10, *pa=&a, *pb=&b;
    int temp=*pa;
    *pa=*pb;
    *pb=temp;
    cout << "a=" << a << ", b=" << b << endl; // a=10, b=5
    return 0;
}

Pruebas
? Caso 1: a=5, b=10 ? a=10, b=5

? Caso 2: a=0, b=1 ? a=1, b=0

Ejercicio 152
Título del Ejercicio: Copiar Cadena con Aritmética de Punteros
Análisis del Problema
? Descripción del Problema: Copiar una cadena de caracteres a otra usando punteros y aritmética de punteros.

? Entradas y Salidas:

? Entrada: Cadena de caracteres fuente.

? Salida: Cadena de caracteres destino copiada.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear punteros apuntando al inicio de las cadenas.

2. Copiar carácter por carácter hasta encontrar el fin de la cadena ('\0').

? Estructuras de Datos: Arreglos de caracteres y punteros.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    char src[] = "Hola Mundo";
    char dest[50];
    char *pSrc = src;
    char *pDest = dest;
    while(*pSrc != '\0'){
        *pDest = *pSrc;
        pSrc++;
        pDest++;
    }
    *pDest = '\0';
    cout << "Cadena copiada: " << dest << endl; // Hola Mundo
    return 0;
}

Pruebas
? Caso 1: "Hola Mundo" ? "Hola Mundo"

? Caso 2: "" ? ""

? Caso 3: "C++" ? "C++"


Ejercicio 153
Título del Ejercicio: Crear Array Dinámico
Análisis del Problema
? Descripción del Problema: Crear un array de tamaño variable usando memoria dinámica (new).

? Entradas y Salidas:

? Entrada: Tamaño n del array.

? Salida: Array dinámico con valores ingresados por el usuario.

Diseño de la Solución
? Algoritmo Propuesto:

1. Pedir al usuario el tamaño del array.

2. Reservar memoria dinámica con new.

3. Ingresar y mostrar elementos.

4. Liberar memoria con delete[].

? Estructuras de Datos: Array dinámico.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Ingresa tamaño del array: ";
    cin >> n;
    int *arr = new int[n];
    for(int i=0;i<n;i++){
        cout << "Elemento " << i << ": ";
        cin >> arr[i];
    }
    cout << "Elementos ingresados: ";
    for(int i=0;i<n;i++) cout << arr[i] << " ";
    cout << endl;
    delete[] arr;
    return 0;
}

Pruebas
? Caso 1: n=3 ? elementos 1,2,3 ? salida 1 2 3

? Caso 2: n=0 ? salida vacía

? Caso 3: n=5 ? elementos 5,4,3,2,1 ? salida 5 4 3 2 1


Ejercicio 154
Título del Ejercicio: Clase Persona con Método Saludar
Análisis del Problema
? Descripción del Problema: Crear clase Persona con atributos nombre y edad, y método saludar() que imprima un saludo.

? Entradas y Salidas:

? Entrada: Nombre y edad.

? Salida: Saludo personalizado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear clase con atributos y constructor.

2. Implementar método saludar().

3. Crear objeto e invocar método.

? Estructuras de Datos: Clase y objeto.

? Funciones Principales: main() y métodos de clase.

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;
    Persona(string n, int e){ nombre=n; edad=e; }
    void saludar(){ cout << "Hola, soy " << nombre << " y tengo " << edad << " años.\n"; }
};

int main() {
    Persona p("Juan", 25);
    p.saludar(); // Hola, soy Juan y tengo 25 años.
    return 0;
}

Pruebas
? Caso 1: "Juan", 25 ? "Hola, soy Juan y tengo 25 años."

? Caso 2: "Ana", 30 ? "Hola, soy Ana y tengo 30 años."


Ejercicio 155
Título del Ejercicio: Clase Libro con Método Mostrar Información
Análisis del Problema
? Descripción del Problema: Crear clase Libro con atributos titulo, autor, anio, y método mostrar() que muestre la información.

? Entradas y Salidas:

? Entrada: Título, autor y año.

? Salida: Información del libro.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear clase Libro con constructor.

2. Implementar método mostrar().

3. Crear objeto y llamar al método.

? Estructuras de Datos: Clase y objeto.

? Funciones Principales: main() y método de clase.

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class Libro {
public:
    string titulo, autor;
    int anio;
    Libro(string t, string a, int an){ titulo=t; autor=a; anio=an; }
    void mostrar(){ cout << "Libro: " << titulo << ", Autor: " << autor << ", Año: " << anio << endl; }
};

int main() {
    Libro libro1("1984","George Orwell",1949);
    libro1.mostrar(); // Libro: 1984, Autor: George Orwell, Año: 1949
    return 0;
}

Pruebas
? Caso 1: "1984", "George Orwell", 1949 ? salida correcta

? Caso 2: "C++ Primer", "Lippman", 2012 ? salida correcta


Ejercicio 156
Título del Ejercicio: Clase CuentaBancaria con Depósito y Retiro
Análisis del Problema
? Descripción del Problema: Crear clase CuentaBancaria con atributos titular y saldo, y métodos depositar(), retirar(), consultarSaldo().

? Entradas y Salidas:

? Entrada: Cantidades a depositar o retirar.

? Salida: Saldo actualizado.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear clase con atributos y métodos.

2. Crear objeto, depositar, retirar y mostrar saldo.

? Estructuras de Datos: Clase y variables.

? Funciones Principales: main() y métodos de clase.

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class CuentaBancaria {
    string titular;
    double saldo;
public:
    CuentaBancaria(string t, double s){ titular=t; saldo=s; }
    void depositar(double monto){ saldo+=monto; }
    void retirar(double monto){ if(monto<=saldo) saldo-=monto; else cout << "Saldo insuficiente\n"; }
    void consultarSaldo(){ cout << "Saldo de " << titular << ": " << saldo << endl; }
};

int main() {
    CuentaBancaria c("Juan",1000);
    c.depositar(500);
    c.retirar(200);
    c.consultarSaldo(); // 1300
    return 0;
}

Pruebas
? Caso 1: Depositar 500, retirar 200 ? saldo 1300

? Caso 2: Retirar 1500 ? "Saldo insuficiente"


Ejercicio 157
Título del Ejercicio: Verificar Si Array Está Ordenado
Análisis del Problema
? Descripción del Problema: Determinar si un array de enteros está ordenado de forma ascendente.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: true si está ordenado, false si no.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer el array y comparar cada elemento con el siguiente.

2. Si alguno no cumple, retornar false.

? Estructuras de Datos: Array.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

bool estaOrdenado(int arr[], int n){
    for(int i=0;i<n-1;i++)
        if(arr[i]>arr[i+1]) return false;
    return true;
}

int main() {
    int arr[]={1,2,3,4,5}, n=5;
    if(estaOrdenado(arr,n)) cout << "Array ordenado\n";
    else cout << "Array no ordenado\n";
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5] ? ordenado

? Caso 2: [5,3,4] ? no ordenado


Ejercicio 158
Título del Ejercicio: Encontrar Mayor Elemento en Array
Análisis del Problema
? Descripción del Problema: Encontrar el elemento máximo en un array de enteros.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Elemento máximo.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar max con el primer elemento.

2. Recorrer array comparando y actualizando max.

? Estructuras de Datos: Array.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={3,7,2,9,5}, n=5;
    int max=arr[0];
    for(int i=1;i<n;i++) if(arr[i]>max) max=arr[i];
    cout << "Mayor elemento: " << max << endl; // 9
    return 0;
}

Pruebas
? Caso 1: [3,7,2,9,5] ? 9

? Caso 2: [1] ? 1


Ejercicio 159
Título del Ejercicio: Encontrar Menor Elemento en Array
Análisis del Problema
? Descripción del Problema: Encontrar el elemento mínimo en un array de enteros.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Elemento mínimo.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar min con el primer elemento.

2. Recorrer array comparando y actualizando min.

? Estructuras de Datos: Array.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={3,7,2,9,5}, n=5;
    int min=arr[0];
    for(int i=1;i<n;i++) if(arr[i]<min) min=arr[i];
    cout << "Menor elemento: " << min << endl; // 2
    return 0;
}

Pruebas
? Caso 1: [3,7,2,9,5] ? 2

? Caso 2: [10] ? 10


Ejercicio 160
Título del Ejercicio: Contar Elementos Mayores que X en Array
Análisis del Problema
? Descripción del Problema: Contar la cantidad de elementos en un array que sean mayores que un valor X.

? Entradas y Salidas:

? Entrada: Array de enteros y valor X.

? Salida: Cantidad de elementos mayores que X.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador=0.

2. Recorrer array y sumar a contador si elemento > X.

? Estructuras de Datos: Array.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,5,7,3,9}, n=5, X=4, contador=0;
    for(int i=0;i<n;i++) if(arr[i]>X) contador++;
    cout << "Elementos mayores que " << X << ": " << contador << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [1,5,7,3,9], X=4 ? 3

? Caso 2: [1,2,3], X=5 ? 0
Ejercicio 161
Título del Ejercicio: Sumar Elementos Positivos de un Array
Análisis del Problema
? Descripción del Problema: Calcular la suma de todos los elementos positivos en un array de enteros.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Suma de los elementos positivos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar suma=0.

2. Recorrer el array.

3. Si el elemento >0, sumarlo a la variable suma.

? Estructuras de Datos: Array.

? Funciones Principales: main().

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={-1,2,3,-4,5}, n=5, suma=0;
    for(int i=0;i<n;i++){
        if(arr[i]>0) suma+=arr[i];
    }
    cout << "Suma de elementos positivos: " << suma << endl; // 10
    return 0;
}

Pruebas
? Caso 1: [-1,2,3,-4,5] ? 10

? Caso 2: [0,-2,-3] ? 0


Ejercicio 162
Título del Ejercicio: Sumar Elementos Negativos de un Array
Análisis del Problema
? Descripción del Problema: Calcular la suma de todos los elementos negativos en un array de enteros.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Suma de los elementos negativos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar suma=0.

2. Recorrer el array.

3. Si el elemento <0, sumarlo a la variable suma.

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={-1,2,3,-4,5}, n=5, suma=0;
    for(int i=0;i<n;i++){
        if(arr[i]<0) suma+=arr[i];
    }
    cout << "Suma de elementos negativos: " << suma << endl; // -5
    return 0;
}

Pruebas
? Caso 1: [-1,2,3,-4,5] ? -5

? Caso 2: [1,2,3] ? 0


Ejercicio 163
Título del Ejercicio: Calcular Promedio de Array
Análisis del Problema
? Descripción del Problema: Calcular el promedio de todos los elementos de un array.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Promedio de los elementos.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar suma=0.

2. Recorrer el array y acumular elementos.

3. Dividir suma entre tamaño del array.

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={2,4,6,8}, n=4, suma=0;
    for(int i=0;i<n;i++) suma+=arr[i];
    double promedio = (double)suma/n;
    cout << "Promedio: " << promedio << endl; // 5
    return 0;
}

Pruebas
? Caso 1: [2,4,6,8] ? 5

? Caso 2: [1,1,1,1] ? 1


Ejercicio 164
Título del Ejercicio: Contar Ceros en Array
Análisis del Problema
? Descripción del Problema: Contar la cantidad de elementos iguales a 0 en un array.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Cantidad de ceros.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador=0.

2. Recorrer el array.

3. Incrementar contador si el elemento es 0.

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={0,2,0,3,0}, n=5, contador=0;
    for(int i=0;i<n;i++) if(arr[i]==0) contador++;
    cout << "Cantidad de ceros: " << contador << endl; // 3
    return 0;
}

Pruebas
? Caso 1: [0,2,0,3,0] ? 3

? Caso 2: [1,2,3] ? 0


Ejercicio 165
Título del Ejercicio: Invertir Array
Análisis del Problema
? Descripción del Problema: Invertir el orden de los elementos de un array.

? Entradas y Salidas:

? Entrada: Array de enteros.

? Salida: Array invertido.

Diseño de la Solución
? Algoritmo Propuesto:

1. Usar dos índices: inicio=0, fin=n-1.

2. Intercambiar elementos hasta que inicio>=fin.

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4,5}, n=5;
    for(int i=0,j=n-1;i<j;i++,j--){
        int temp=arr[i]; arr[i]=arr[j]; arr[j]=temp;
    }
    for(int i=0;i<n;i++) cout << arr[i] << " "; // 5 4 3 2 1
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4,5] ? [5,4,3,2,1]

? Caso 2: [1] ? [1]


Ejercicio 166
Título del Ejercicio: Buscar Elemento en Array
Análisis del Problema
? Descripción del Problema: Determinar si un elemento dado existe en un array.

? Entradas y Salidas:

? Entrada: Array y elemento a buscar.

? Salida: true si existe, false si no.

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,3,5,7}, n=4, x=5;
    bool encontrado=false;
    for(int i=0;i<n;i++) if(arr[i]==x) encontrado=true;
    cout << (encontrado ? "Elemento encontrado\n" : "Elemento no encontrado\n"); // Encontrado
    return 0;
}

Pruebas
? Caso 1: x=5 ? encontrado

? Caso 2: x=2 ? no encontrado


Ejercicio 167
Título del Ejercicio: Contar Apariciones de un Elemento
Análisis del Problema
? Descripción del Problema: Contar cuántas veces aparece un elemento en un array.

? Entradas y Salidas:

? Entrada: Array y elemento a contar.

? Salida: Número de apariciones.

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,2,3,2}, n=5, x=2, contador=0;
    for(int i=0;i<n;i++) if(arr[i]==x) contador++;
    cout << "El elemento " << x << " aparece " << contador << " veces.\n"; // 3
    return 0;
}

Pruebas
? Caso 1: x=2 ? 3 veces

? Caso 2: x=5 ? 0 veces


Ejercicio 168
Título del Ejercicio: Eliminar Elemento en Array (Reordenando)
Análisis del Problema
? Descripción del Problema: Eliminar un elemento específico de un array desplazando los elementos restantes.

? Entradas y Salidas:

? Entrada: Array y elemento a eliminar.

? Salida: Array modificado.

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int arr[]={1,2,3,4,2}, n=5, x=2;
    int nuevo_n=0;
    for(int i=0;i<n;i++){
        if(arr[i]!=x) arr[nuevo_n++]=arr[i];
    }
    for(int i=0;i<nuevo_n;i++) cout << arr[i] << " "; // 1 3 4
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: x=2 ? [1,3,4]

? Caso 2: x=5 ? [1,2,3,4,2]


Ejercicio 169
Título del Ejercicio: Sumar Elementos de Array Recursivamente
Análisis del Problema
? Descripción del Problema: Calcular la suma de todos los elementos de un array usando recursión.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Suma de elementos.

Código Fuente (C++)
#include <iostream>
using namespace std;

int sumaRec(int arr[], int n){
    if(n==0) return 0;
    return arr[n-1]+sumaRec(arr,n-1);
}

int main() {
    int arr[]={1,2,3,4}, n=4;
    cout << "Suma total: " << sumaRec(arr,n) << endl; // 10
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4] ? 10

? Caso 2: [0,0,0] ? 0


Ejercicio 170
Título del Ejercicio: Calcular Producto de Array Recursivamente
Análisis del Problema
? Descripción del Problema: Calcular el producto de todos los elementos de un array usando recursión.

? Entradas y Salidas:

? Entrada: Array de enteros y tamaño.

? Salida: Producto de elementos.

Código Fuente (C++)
#include <iostream>
using namespace std;

int productoRec(int arr[], int n){
    if(n==0) return 1;
    return arr[n-1]*productoRec(arr,n-1);
}

int main() {
    int arr[]={1,2,3,4}, n=4;
    cout << "Producto total: " << productoRec(arr,n) << endl; // 24
    return 0;
}

Pruebas
? Caso 1: [1,2,3,4] ? 24

? Caso 2: [2,2,2] ? 8
Ejercicio 181
Título del Ejercicio: Buscar Elemento en Matriz
Análisis del Problema
? Descripción del Problema: Determinar si un elemento dado existe en una matriz.

? Entradas y Salidas:

? Entrada: Matriz m×n y elemento a buscar.

? Salida: Mensaje indicando si se encuentra o no el elemento.

Diseño de la Solución
? Algoritmo Propuesto:

1. Recorrer todas las filas y columnas de la matriz.

2. Comparar cada elemento con el valor buscado.

3. Si se encuentra, retornar true; si no, false.

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[2][3]={{1,2,3},{4,5,6}};
    int m=2, n=3, x=5;
    bool encontrado=false;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(mat[i][j]==x) encontrado=true;
        }
    }
    cout << (encontrado ? "Elemento encontrado\n" : "Elemento no encontrado\n"); // Encontrado
    return 0;
}

Pruebas
? Caso 1: x=5 ? "Elemento encontrado"

? Caso 2: x=7 ? "Elemento no encontrado"


Ejercicio 182
Título del Ejercicio: Contar Apariciones de un Elemento en Matriz
Análisis del Problema
? Descripción del Problema: Contar cuántas veces aparece un elemento específico en una matriz.

? Entradas y Salidas:

? Entrada: Matriz m×n y elemento a contar.

? Salida: Número de apariciones del elemento.

Diseño de la Solución
? Algoritmo Propuesto:

1. Inicializar contador=0.

2. Recorrer la matriz fila por fila y columna por columna.

3. Incrementar contador si el elemento coincide con el valor buscado.

Código Fuente (C++)
#include <iostream>
using namespace std;

int main() {
    int mat[2][3]={{1,2,3},{2,2,6}}, m=2, n=3, x=2;
    int contador=0;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(mat[i][j]==x) contador++;
        }
    }
    cout << "El elemento " << x << " aparece " << contador << " veces.\n"; // 3
    return 0;
}

Pruebas
? Caso 1: x=2 ? 3 apariciones

? Caso 2: x=5 ? 0 apariciones
Ejercicio 183
Título del Ejercicio: Sumar Filas de Matriz Recursivamente
Análisis del Problema
? Descripción del Problema: Calcular la suma de los elementos de cada fila de una matriz usando recursión.

? Entradas y Salidas:

? Entrada: Matriz m×n.

? Salida: Suma de cada fila.

Código Fuente (C++)
? #include <iostream>
? using namespace std;
? 
? int sumaFilaRec(int mat[][3], int fila, int col, int nCol){
?     if(col==nCol) return 0;
?     return mat[fila][col] + sumaFilaRec(mat,fila,col+1,nCol);
? }
? 
? int main() {
?     int mat[2][3]={{1,2,3},{4,5,6}};
?     for(int i=0;i<2;i++)
?         cout << "Suma fila " << i << ": " << sumaFilaRec(mat,i,0,3) << endl; // 6, 15
?     return 0;
? }

Pruebas
? Caso 1: [[1,2,3],[4,5,6]] ? 6, 15

? Caso 2: [[0,0,0],[1,1,1]] ? 0, 3


Ejercicio 184
Título del Ejercicio: Sumar Columnas de Matriz Recursivamente
Análisis del Problema
? Descripción del Problema: Calcular la suma de los elementos de cada columna de una matriz usando recursión.

? Entradas y Salidas:

? Entrada: Matriz m×n.

? Salida: Suma de cada columna.

Código Fuente (C++)
? #include <iostream>
? using namespace std;
? 
? int sumaColRec(int mat[][3], int fila, int col, int nFilas){
?     if(fila==nFilas) return 0;
?     return mat[fila][col] + sumaColRec(mat,fila+1,col,nFilas);
? }
? 
? int main() {
?     int mat[2][3]={{1,2,3},{4,5,6}};
?     for(int j=0;j<3;j++)
?         cout << "Suma columna " << j << ": " << sumaColRec(mat,0,j,2) << endl; // 5,7,9
?     return 0;
? }

Pruebas
? Caso 1: [[1,2,3],[4,5,6]] ? 5,7,9


Ejercicio 185
Título del Ejercicio: Trasponer Matriz Recursivamente
Análisis del Problema
? Descripción del Problema: Trasponer una matriz (intercambiar filas por columnas) usando recursión.

? Entradas y Salidas:

? Entrada: Matriz m×n.

? Salida: Matriz traspuesta.

Código Fuente (C++)
? #include <iostream>
? using namespace std;
? 
? void trasponerRec(int mat[][3], int trans[][2], int i, int j, int m, int n){
?     if(i==m) return;
?     if(j<n){
?         trans[j][i] = mat[i][j];
?         trasponerRec(mat, trans, i, j+1, m, n);
?     } else trasponerRec(mat, trans, i+1, 0, m, n);
? }
? 
? int main() {
?     int mat[2][3]={{1,2,3},{4,5,6}}, trans[3][2];
?     trasponerRec(mat, trans, 0, 0, 2, 3);
?     for(int i=0;i<3;i++){
?         for(int j=0;j<2;j++) cout << trans[i][j] << " ";
?         cout << endl;
?     }
?     return 0;
? }

Pruebas
? Caso 1: [[1,2,3],[4,5,6]] ? [[1,4],[2,5],[3,6]]


Ejercicio 186
Título del Ejercicio: Verificar Matriz Simétrica
Análisis del Problema
? Descripción del Problema: Determinar si una matriz cuadrada es simétrica (igual a su traspuesta).

? Entradas y Salidas:

? Entrada: Matriz n×n.

? Salida: true si es simétrica, false si no.

Código Fuente (C++)
? #include <iostream>
? using namespace std;
? 
? int main() {
?     int mat[3][3]={{1,2,3},{2,5,6},{3,6,9}}, n=3;
?     bool simetrica=true;
?     for(int i=0;i<n;i++)
?         for(int j=0;j<n;j++)
?             if(mat[i][j]!=mat[j][i]) simetrica=false;
?     cout << (simetrica ? "Simétrica" : "No simétrica") << endl; // Simétrica
?     return 0;
? }

Pruebas
? Caso 1: [[1,2,3],[2,5,6],[3,6,9]] ? Simétrica

? Caso 2: [[1,0],[2,1]] ? No simétrica


Ejercicio 187
Título del Ejercicio: Calcular Factorial Recursivamente
Análisis del Problema
? Descripción del Problema: Calcular el factorial de un número usando recursión.

? Entradas y Salidas:

? Entrada: Número entero n?0.

? Salida: Factorial de n.

Código Fuente (C++)
? #include <iostream>
? using namespace std;
? 
? int factorial(int n){
?     if(n==0) return 1;
?     return n*factorial(n-1);
? }
? 
? int main() {
?     int n=5;
?     cout << "Factorial de " << n << ": " << factorial(n) << endl; // 120
?     return 0;
? }

Pruebas
? Caso 1: n=5 ? 120

? Caso 2: n=0 ? 1


Ejercicio 188
Título del Ejercicio: Calcular Potencia Recursivamente
Análisis del Problema
? Descripción del Problema: Calcular a^b usando recursión.

? Entradas y Salidas:

? Entrada: Base a y exponente b?0.

? Salida: Resultado de a^b.

Código Fuente (C++)
? #include <iostream>
? using namespace std;
? 
? int potencia(int a, int b){
?     if(b==0) return 1;
?     return a*potencia(a,b-1);
? }
? 
? int main() {
?     int a=2,b=3;
?     cout << a << "^" << b << " = " << potencia(a,b) << endl; // 8
?     return 0;
? }

Pruebas
? Caso 1: 2^3 ? 8

? Caso 2: 5^0 ? 1


Ejercicio 189
Título del Ejercicio: Contar Vocales Recursivamente
Análisis del Problema
? Descripción del Problema: Contar la cantidad de vocales en una cadena usando recursión.

? Entradas y Salidas:

? Entrada: Cadena de caracteres.

? Salida: Número de vocales.

Código Fuente (C++)
? #include <iostream>
? using namespace std;
? 
? int contarVocales(char *str){
?     if(*str=='\0') return 0;
?     char c = tolower(*str);
?     return ((c=='a'||c=='e'||c=='i'||c=='o'||c=='u')?1:0)+contarVocales(str+1);
? }
? 
? int main() {
?     char cadena[]="Hola Mundo";
?     cout << "Cantidad de vocales: " << contarVocales(cadena) << endl; // 4
?     return 0;
? }

Pruebas
? Caso 1: "Hola Mundo" ? 4

? Caso 2: "C++" ? 0


Ejercicio 190
Título del Ejercicio: Sumar Elementos de Pila
Análisis del Problema
? Descripción del Problema: Sumar todos los elementos de una pila implementada con array.

? Entradas y Salidas:

? Entrada: Pila de enteros.

? Salida: Suma de todos los elementos.

Código Fuente (C++)
? #include <iostream>
? using namespace std;
? 
? int main() {
?     int pila[5]={1,2,3,4,5}, n=5, suma=0;
?     for(int i=0;i<n;i++) suma+=pila[i];
?     cout << "Suma elementos de la pila: " << suma << endl; // 15
?     return 0;
? }

Pruebas
? Caso 1: [1,2,3,4,5] ? 15

? Caso 2: [0,0,0] ? 0
Ejercicio 191
Título del Ejercicio: Gestión de Estudiantes con POO
Análisis del Problema
? Descripción del Problema: Crear un sistema simple para almacenar información de estudiantes (nombre, edad, promedio). El programa debe permitir:

? Agregar estudiantes.

? Mostrar todos los estudiantes.

? Calcular promedio general.

? Entradas y Salidas:

? Entrada: Datos de cada estudiante (nombre, edad, promedio).

? Salida: Lista de estudiantes y promedio general.

Diseño de la Solución
? Algoritmo Propuesto:

1. Crear clase Estudiante con atributos: nombre, edad, promedio.

2. Crear métodos para mostrar información.

3. Guardar estudiantes en un array.

4. Recorrer array para calcular promedio general.

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class Estudiante{
public:
    string nombre;
    int edad;
    float promedio;

    void mostrarInfo(){
        cout << "Nombre: " << nombre << ", Edad: " << edad << ", Promedio: " << promedio << endl;
    }
};

int main() {
    Estudiante estudiantes[3];
    float sumaProm=0;

    // Agregar información
    estudiantes[0] = {"Juan", 20, 8.5};
    estudiantes[1] = {"Ana", 22, 9.2};
    estudiantes[2] = {"Luis", 19, 7.8};

    cout << "Lista de estudiantes:\n";
    for(int i=0;i<3;i++){
        estudiantes[i].mostrarInfo();
        sumaProm += estudiantes[i].promedio;
    }

    cout << "Promedio general: " << sumaProm/3 << endl; // 8.5 aprox
    return 0;
}

Pruebas
? Caso 1: 3 estudiantes ? Mostrar lista y promedio general

? Caso 2: Cambiar edades/promedios ? Verificar cálculo correcto


Ejercicio 192
Título del Ejercicio: Gestión de Libros con POO y Arreglo Dinámico
Análisis del Problema
? Descripción del Problema: Crear un sistema de biblioteca que permita:

? Agregar libros (título, autor, año).

? Mostrar todos los libros.

? Buscar libros por autor.

? Entradas y Salidas:

? Entrada: Datos de libros.

? Salida: Lista completa y libros filtrados por autor.

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class Libro{
public:
    string titulo, autor;
    int anio;
    void mostrar() { cout << titulo << " - " << autor << " (" << anio << ")\n"; }
};

int main(){
    int n = 3;
    Libro* biblioteca = new Libro[n];
    
    biblioteca[0] = {"C++ Moderno", "Bjarne", 2018};
    biblioteca[1] = {"Algoritmos", "Knuth", 1997};
    biblioteca[2] = {"Estructuras de Datos", "Weiss", 2013};

    cout << "Todos los libros:\n";
    for(int i=0;i<n;i++) biblioteca[i].mostrar();

    string autorBuscado = "Knuth";
    cout << "\nLibros de " << autorBuscado << ":\n";
    for(int i=0;i<n;i++)
        if(biblioteca[i].autor==autorBuscado) biblioteca[i].mostrar();

    delete[] biblioteca;
    return 0;
}

Pruebas
? Caso 1: Buscar autor existente ? Mostrar libro

? Caso 2: Autor inexistente ? Sin resultados


Ejercicio 193
Título del Ejercicio: Pila Dinámica con Funciones
Análisis del Problema
? Descripción del Problema: Implementar una pila con array dinámico que permita:

1. Insertar elementos (push)

2. Eliminar elementos (pop)

3. Mostrar la pila

4. Sumar todos los elementos

Código Fuente (C++)
#include <iostream>
using namespace std;

class Pila {
private:
    int* arr;
    int top;
    int capacidad;
public:
    Pila(int size){
        capacidad = size;
        arr = new int[size];
        top = -1;
    }

    void push(int x){
        if(top == capacidad-1) { cout << "Pila llena\n"; return; }
        arr[++top] = x;
    }

    int pop(){
        if(top == -1) { cout << "Pila vacía\n"; return -1; }
        return arr[top--];
    }

    void mostrar(){
        cout << "Pila: ";
        for(int i=0;i<=top;i++) cout << arr[i] << " ";
        cout << endl;
    }

    int sumar(){
        int suma=0;
        for(int i=0;i<=top;i++) suma+=arr[i];
        return suma;
    }

    ~Pila(){ delete[] arr; }
};

int main(){
    Pila pila(5);
    pila.push(1); pila.push(2); pila.push(3);
    pila.mostrar();
    cout << "Suma elementos: " << pila.sumar() << endl; // 6
    pila.pop();
    pila.mostrar(); // 1 2
    return 0;
}

Pruebas
? Caso 1: Push 3 elementos ? Mostrar y sumar

? Caso 2: Pop elemento ? Verificar pila y suma


Ejercicio 194
Título del Ejercicio: Cola Dinámica con Funciones
Análisis del Problema
? Descripción del Problema: Implementar una cola usando array dinámico:

1. Encolar (agregar)

2. Desencolar (eliminar)

3. Mostrar cola

4. Contar elementos

Código Fuente (C++)
#include <iostream>
using namespace std;

class Cola {
private:
    int* arr;
    int frente, fin, capacidad;
public:
    Cola(int size){
        capacidad = size;
        arr = new int[size];
        frente = 0; fin = -1;
    }

    void encolar(int x){
        if(fin == capacidad-1) { cout << "Cola llena\n"; return; }
        arr[++fin] = x;
    }

    int desencolar(){
        if(frente > fin) { cout << "Cola vacía\n"; return -1; }
        return arr[frente++];
    }

    void mostrar(){
        cout << "Cola: ";
        for(int i=frente;i<=fin;i++) cout << arr[i] << " ";
        cout << endl;
    }

    int contar(){ return fin-frente+1; }

    ~Cola(){ delete[] arr; }
};

int main(){
    Cola cola(5);
    cola.encolar(10); cola.encolar(20); cola.encolar(30);
    cola.mostrar();
    cout << "Cantidad elementos: " << cola.contar() << endl; // 3
    cola.desencolar();
    cola.mostrar(); // 20 30
    return 0;
}

Pruebas
? Caso 1: Agregar y eliminar ? Verificar contenido y conteo


Ejercicio 195
Título del Ejercicio: Recursión para Fibonacci
Análisis del Problema
? Descripción del Problema: Calcular n-ésimo número de Fibonacci usando recursión.

? Entradas y Salidas:

? Entrada: Número n?0

? Salida: Fibonacci(n)

Código Fuente (C++)
#include <iostream>
using namespace std;

int fibonacci(int n){
    if(n==0) return 0;
    if(n==1) return 1;
    return fibonacci(n-1)+fibonacci(n-2);
}

int main(){
    int n=10;
    cout << "Fibonacci(" << n << ") = " << fibonacci(n) << endl; // 55
    return 0;
}

Pruebas
? Caso 1: n=10 ? 55

? Caso 2: n=0 ? 0


Ejercicio 196
Título del Ejercicio: Búsqueda Binaria Recursiva
Análisis del Problema
? Descripción del Problema: Implementar búsqueda binaria recursiva para un array ordenado.

? Entradas y Salidas:

? Entrada: Array ordenado, valor a buscar

? Salida: Índice del elemento o -1 si no existe

Código Fuente (C++)
#include <iostream>
using namespace std;

int busquedaBinaria(int arr[], int inicio, int fin, int x){
    if(inicio>fin) return -1;
    int mid = inicio + (fin-inicio)/2;
    if(arr[mid]==x) return mid;
    if(arr[mid]<x) return busquedaBinaria(arr,mid+1,fin,x);
    else return busquedaBinaria(arr,inicio,mid-1,x);
}

int main(){
    int arr[]={1,3,5,7,9,11}, n=6, x=7;
    int indice = busquedaBinaria(arr,0,n-1,x);
    cout << (indice!=-1 ? "Elemento encontrado en indice " + to_string(indice) : "Elemento no encontrado") << endl; // 3
    return 0;
}

Pruebas
? Caso 1: x=7 ? índice 3

? Caso 2: x=2 ? -1


Ejercicio 197
Título del Ejercicio: Ordenamiento Burbuja
Análisis del Problema
? Descripción del Problema: Ordenar un array de enteros usando burbuja y mostrar antes/después.

Código Fuente (C++)
#include <iostream>
using namespace std;

int main(){
    int arr[]={5,3,8,1,2}, n=5;
    cout << "Antes: ";
    for(int i=0;i<n;i++) cout << arr[i] << " ";
    cout << endl;

    for(int i=0;i<n-1;i++)
        for(int j=0;j<n-1-i;j++)
            if(arr[j]>arr[j+1]) swap(arr[j],arr[j+1]);

    cout << "Después: ";
    for(int i=0;i<n;i++) cout << arr[i] << " ";
    cout << endl;

    return 0;
}

Pruebas
? Caso 1: [5,3,8,1,2] ? [1,2,3,5,8]


Ejercicio 198
Título del Ejercicio: Ordenamiento por Inserción
Análisis del Problema:
? Descripción del Problema: Ordenar un array de enteros usando inserción.

Código Fuente (C++)
#include <iostream>
using namespace std;

int main(){
    int arr[]={9,5,1,4,3}, n=5;
    for(int i=1;i<n;i++){
        int key = arr[i];
        int j=i-1;
        while(j>=0 && arr[j]>key){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=key;
    }
    for(int i=0;i<n;i++) cout << arr[i] << " "; // 1 3 4 5 9
    cout << endl;
    return 0;
}

Pruebas
? Caso 1: [9,5,1,4,3] ? [1,3,4,5,9]


Ejercicio 199
Título del Ejercicio: Calculadora de Operaciones
Análisis del Problema:
? Descripción del Problema: Implementar calculadora que realice suma, resta, multiplicación y división usando funciones.

Código Fuente (C++)
#include <iostream>
using namespace std;

float suma(float a,float b){return a+b;}
float resta(float a,float b){return a-b;}
float mult(float a,float b){return a*b;}
float divi(float a,float b){return b!=0?a/b:0;}

int main(){
    float x=10,y=5;
    cout << "Suma: " << suma(x,y) << endl;
    cout << "Resta: " << resta(x,y) << endl;
    cout << "Multiplicación: " << mult(x,y) << endl;
    cout << "División: " << divi(x,y) << endl;
    return 0;
}

Pruebas
? Caso 1: x=10,y=5 ? 15,5,50,2


Ejercicio 200
Título del Ejercicio: Sistema Completo de Banco con POO
Análisis del Problema:
? Descripción del Problema: Implementar clase CuentaBancaria que permita:

1. Depositar dinero

2. Retirar dinero

3. Consultar saldo

4. Mostrar información de la cuenta

Código Fuente (C++)
#include <iostream>
#include <string>
using namespace std;

class CuentaBancaria{
private:
    string titular;
    float saldo;
public:
    CuentaBancaria(string n,float s){ titular=n; saldo=s; }
    void depositar(float monto){ saldo+=monto; }
    void retirar(float monto){ if(saldo>=monto) saldo-=monto; else cout<<"Saldo insuficiente\n"; }
    void mostrar(){ cout << "Titular: " << titular << ", Saldo: " << saldo << endl; }
    float getSaldo(){ return saldo; }
};

int main(){
    CuentaBancaria c("Juan",1000);
    c.mostrar();
    c.depositar(500);
    c.mostrar();
    c.retirar(2000); // Saldo insuficiente
    c.retirar(800);
    c.mostrar(); // Saldo 700
    return 0;
}

Pruebas
? Depositar, retirar y consultar saldo ? Verificar correctitud de operaciones







